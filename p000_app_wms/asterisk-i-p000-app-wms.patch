diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/apps/app_originate.c asterisk-11.3.0.p000/apps/app_originate.c
--- asterisk-base-11.3.0/apps/app_originate.c	2013-05-02 16:10:16.344437793 +0100
+++ asterisk-11.3.0.p000/apps/app_originate.c	2013-05-13 14:00:43.201187619 +0100
@@ -185,7 +185,7 @@
 
 		ast_pbx_outgoing_app(chantech, cap_slin, chandata,
 				timeout * 1000, args.arg1, args.arg2, &outgoing_status, 0, NULL,
-				NULL, NULL, NULL, NULL);
+				NULL, NULL, NULL, NULL, NULL);
 	} else {
 		ast_log(LOG_ERROR, "Incorrect type, it should be 'exten' or 'app': %s\n",
 				args.type);
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/apps/app_parkandannounce.c asterisk-11.3.0.p000/apps/app_parkandannounce.c
--- asterisk-base-11.3.0/apps/app_parkandannounce.c	2013-05-02 16:10:16.240437732 +0100
+++ asterisk-11.3.0.p000/apps/app_parkandannounce.c	2013-05-13 14:00:43.077187991 +0100
@@ -178,7 +178,7 @@
 		&outstate,
 		S_COR(caller_id.number.valid, caller_id.number.str, NULL),
 		S_COR(caller_id.name.valid, caller_id.name.str, NULL),
-		&oh);
+		&oh, NULL);
 	ast_variables_destroy(oh.vars);
 	ast_party_id_free(&caller_id);
 	if (dchan) {
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/apps/app_wms.c asterisk-11.3.0.p000/apps/app_wms.c
--- asterisk-base-11.3.0/apps/app_wms.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-11.3.0.p000/apps/app_wms.c	2013-05-13 14:00:47.676437707 +0100
@@ -0,0 +1,1067 @@
+/*******************************************************************************
+ *        FILE: app_wms.c
+ * DESCRIPTION: 
+ *              
+ * 
+ * $Archive: $
+ * $Revision: 1.5.0 $
+ * $Author: $
+ * $History: $
+ * 
+ * Luis Reis
+ * Copyright (c) 2006-09 PT Inovação SA. All Rights Reserved
+ ******************************************************************************/
+
+ /******************************************************************************
+ *
+ * SYSTEM HEADER FILES
+ *
+ ******************************************************************************/
+#include <stdio.h>
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 0032 $")
+
+#include <asterisk/lock.h>
+#include <asterisk/file.h>
+#include <asterisk/logger.h>
+#include <asterisk/channel.h>
+#include <asterisk/features.h>
+#include <asterisk/pbx.h>
+#include <asterisk/module.h>
+#include <asterisk/translate.h>
+#include <asterisk/chanvars.h>
+#include <asterisk/causes.h>
+#include <asterisk/options.h>
+#include <asterisk/translate.h>
+#include <asterisk/manager.h>
+#include <asterisk/musiconhold.h>
+#include <asterisk/app.h>
+#include <errno.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <sys/un.h>
+
+/*******************************************************************************
+ *
+ * APPLICATION HEADER FILES
+ *
+ ******************************************************************************/
+#include "vsrvdefs.h"
+#include "app_wms.h"
+#include "wms_inoapi.h"
+#include "wms_aux.h"
+
+
+/*** DOCUMENTATION
+	<application name="WMSApp" language="en_US">
+		<synopsis>
+			IVR Application.
+		</synopsis>
+		<syntax>
+			<parameter name="filename" required="false" />
+		</syntax>
+		<description>
+			<para>Let WMS assume control over all received calls.</para>
+		</description>
+	</application>
+ ***/
+
+/*******************************************************************************
+ *
+ * VARIABLES
+ *  
+ ******************************************************************************/
+static char *app = "WMSApp";
+
+//Can't have variables here 'cause they are shared with other channels
+ast_mutex_t digmux_lock;	
+
+int wms_debug = 1;
+
+/*******************************************************************************
+ *
+ * FUNCTION PROTOTYPES
+ *
+ ******************************************************************************/
+static void run_asterisk_channel(struct ast_channel *chan, ast_vars *chan_vars);
+static void run_smra_channel(struct ast_channel *chan, ast_vars *chan_vars);
+
+/*******************************************************************************
+ *
+ * FUNCTIONS
+ *
+ ******************************************************************************/
+/******************************************************************************
+ *        NAME: wms_exec()
+ * DESCRIPTION: Main()
+ *              
+ *****************************************************************************/
+static int wms_exec(struct ast_channel *chan, const char *data)
+{
+   char strnum[128], *stringp1, *stringp2, *stringp3;
+   struct ast_module_user *u;
+   int trs_sock_fd = -1;
+   struct sockaddr_un peeraddr_un;  /* for peer socket address */
+	ast_vars *chan_vars = (ast_vars *)calloc(1, sizeof(ast_vars));
+   int flags;
+
+   if (chan_vars == NULL)
+   {
+       ast_log(LOG_ERROR, "No memory to alloc chan_vars on channel %s", ast_channel_name(chan));
+       return -1;
+   }
+
+   if ((trs_sock_fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
+   {
+      ast_log(LOG_ERROR, "Socket creation error (%d) on channel %s! Exiting.\n", errno, ast_channel_name(chan));
+
+      // Remove chan_vars
+      if (chan_vars != NULL)
+      {
+         free(chan_vars);
+         chan_vars = NULL;
+      }
+      // Return
+      return -1;
+   }
+   memset((char *) &peeraddr_un, 0, sizeof(peeraddr_un));
+
+   /* Now, let us set up the peer to which we will connect */
+   peeraddr_un.sun_family = AF_UNIX;
+   strncpy(peeraddr_un.sun_path, "/var/ptin/wms/socket", sizeof(peeraddr_un.sun_path));
+
+   if ((connect(trs_sock_fd, (struct sockaddr *)&peeraddr_un, sizeof(peeraddr_un))) == -1)
+   {
+		ast_log(LOG_ERROR, "Connect error (%d) to TRS socket on channel %s! Exiting.\n", errno, ast_channel_name(chan));
+
+	   shutdown(trs_sock_fd, SHUT_RDWR);
+		close(trs_sock_fd);
+		trs_sock_fd = -1;
+
+      // Remove chan_vars
+      if (chan_vars != NULL) 
+      {
+         free(chan_vars);
+         chan_vars = NULL;
+      }
+      // Return
+      return -1;
+   }
+   // Meetme blows up if not
+   flags = fcntl(trs_sock_fd, F_GETFL, 0);
+   fcntl(trs_sock_fd, F_SETFL, flags | O_NONBLOCK);
+
+   u = ast_module_user_add(chan);
+
+   memset(strnum, 0, sizeof(strnum));
+   chan_vars->dtmf = 1; //Set DTMF true by default
+	chan_vars->trs_fd = trs_sock_fd;
+	chan_vars->trs_reply.in_ast_chan = (void *)chan;
+   snprintf(chan_vars->trs_reply.body.userData, sizeof(chan_vars->trs_reply.body.userData), ast_channel_uniqueid(chan));
+   snprintf(chan_vars->trs_reply.body.channelId, sizeof(chan_vars->trs_reply.body.channelId), ast_channel_name(chan));
+   chan_vars->conf_thread = AST_PTHREADT_NULL;
+
+	/* --> */
+	if (strchr((char *)data,'#') == NULL)	// INBOUND CALL
+	{
+		chan_vars->trs_reply.event = INCOMING_CALL_EVENT;
+      
+		if (wms_debug)
+		{
+      //change to LOG_EVENT afterwords
+      ast_log(LOG_DEBUG, "\nName          : %-30s |\n"
+                          "Caller Number : %-30s | Caller Name   : %s\n"
+                          "ANI           : %-30s | ANI (digits)  : %-30s\n"
+                          "Addr          : %-30s | Addr 2        : %-30s\n"
+                             "ANI 2         : %-30d | Type of Number: %-30d\n"
+                             "Conn Number   : %-30s | Conn Name     : %-30s\n"
+                          "Conn ANI      : %-30s | Conn ANI 2    : %-30s\n"
+                          "Addr          : %-30s | Addr 2        : %-30s\n"
+                             "Redir Number  : %-30s | Redir Name    : %-30s\n"
+                          "Redir ANI     : %-30s | Redir ANI 2   : %-30s\n"
+                          "Addr          : %-30s | Addr 2        : %-30s\n"
+                          "Count         : %-30d | Reason        : %-30d\n"
+                          "DNID          : %-30s | DNID Addr     : %-30s\n"
+                          "Data          : %-30s | Exten         : %-30s |\n"
+                             "UNIQUEID      : %-30s | SMRA          : %-30s\n"
+                             "DNIS          : %-30s | ANI           : %s\n"
+                             "CALLID        : %-30s | REQ URI       : %s\n"
+                             "URL PARAMS    : %-30s | Extra data    : %-30s\n",
+                             ast_channel_name(chan),
+                             S_COR(ast_channel_caller(chan)->id.number.valid, ast_channel_caller(chan)->id.number.str, "<unknown>"), // From: Number
+                             S_COR(ast_channel_caller(chan)->id.name.valid, ast_channel_caller(chan)->id.name.str, "<unknown>"),     // From: Name
+                             S_COR(ast_channel_caller(chan)->ani.name.valid, ast_channel_caller(chan)->ani.name.str, "<unknown>"),
+                             S_COR(ast_channel_caller(chan)->ani.number.valid, ast_channel_caller(chan)->ani.number.str, "<unknown>"),
+                             S_COR(ast_channel_caller(chan)->id.subaddress.valid, ast_channel_caller(chan)->id.subaddress.str, "<unknown>"),
+                             S_COR(ast_channel_caller(chan)->ani.subaddress.valid, ast_channel_caller(chan)->ani.subaddress.str, "<unknown>"),
+                                ast_channel_caller(chan)->ani2, ast_channel_caller(chan)->id.number.plan,
+                             S_COR(ast_channel_connected(chan)->id.number.valid, ast_channel_connected(chan)->id.number.str, "<unknown>"),
+                             S_COR(ast_channel_connected(chan)->id.name.valid, ast_channel_connected(chan)->id.name.str, "<unknown>"),
+                             S_COR(ast_channel_connected(chan)->ani.name.valid, ast_channel_connected(chan)->ani.name.str, "<unknown>"),
+                             S_COR(ast_channel_connected(chan)->ani.number.valid, ast_channel_connected(chan)->ani.number.str, "<unknown>"),
+                             S_COR(ast_channel_connected(chan)->id.subaddress.valid, ast_channel_connected(chan)->id.subaddress.str, "<unknown>"),
+                             S_COR(ast_channel_connected(chan)->ani.subaddress.valid, ast_channel_connected(chan)->ani.subaddress.str, "<unknown>"),
+
+                             S_COR(ast_channel_redirecting(chan)->from.name.valid, ast_channel_redirecting(chan)->from.name.str, "<unknown>"),
+                             S_COR(ast_channel_redirecting(chan)->from.number.valid, ast_channel_redirecting(chan)->from.number.str, "<unknown>"),
+                             S_COR(ast_channel_redirecting(chan)->to.name.valid, ast_channel_redirecting(chan)->to.name.str, "<unknown>"),
+                             S_COR(ast_channel_redirecting(chan)->to.number.valid, ast_channel_redirecting(chan)->to.number.str, "<unknown>"),
+                             S_COR(ast_channel_redirecting(chan)->from.subaddress.valid, ast_channel_redirecting(chan)->from.subaddress.str, "<unknown>"),
+                             S_COR(ast_channel_redirecting(chan)->to.subaddress.valid, ast_channel_redirecting(chan)->to.subaddress.str, "<unknown>"),
+
+                             ast_channel_redirecting(chan)->count, ast_channel_redirecting(chan)->reason,
+
+                             (ast_channel_dialed(chan)->number.str != NULL ? ast_channel_dialed(chan)->number.str : "<unknown>"),
+                             S_COR(ast_channel_dialed(chan)->subaddress.valid, ast_channel_dialed(chan)->subaddress.str, "<unknown>"), // Req-U
+                             (char *)data, ast_channel_exten(chan),
+                                ast_channel_uniqueid(chan), ast_opt_use_smra ? "ON" : "OFF",
+                             ast_channel_cid_dnis(chan), ast_channel_cid_ani(chan),
+                             ast_channel_cid_callid(chan), ast_channel_cid_uri(chan),
+                             ast_channel_url_params(chan), ast_channel_extradata(chan));
+
+         if (ast_opt_use_smra)
+         {
+            ast_log(LOG_DEBUG,
+               "L AUDIO IP    : %-30s | L VIDEO IP    : %s\n"
+               "L AUDIO PORT  : %-30d | L VIDEO PORT  : %d\n"
+               "R AUDIO IP    : %-30s | R VIDEO IP    : %s\n"
+               "R AUDIO PORT  : %-30d | R VIDEO PORT  : %d\n",
+               ast_channel_server_smra_attrib(chan)->rtpa_ip, ast_channel_server_smra_attrib(chan)->rtpv_ip,
+               ast_channel_server_smra_attrib(chan)->rtpa_port, ast_channel_server_smra_attrib(chan)->rtpv_port,
+               ast_channel_client_smra_attrib(chan)->rtpa_ip, ast_channel_client_smra_attrib(chan)->rtpv_ip,
+               ast_channel_client_smra_attrib(chan)->rtpa_port, ast_channel_client_smra_attrib(chan)->rtpv_port);
+         }
+		}
+      //Get ANI
+		if ((ast_channel_cid_asserted_id(chan) != NULL) && !ast_strlen_zero(ast_channel_cid_asserted_id(chan)))
+		   strncpy(chan_vars->trs_reply.body.ic_event.ic_ani, ast_channel_cid_asserted_id(chan),
+		         sizeof(chan_vars->trs_reply.body.ic_event.ic_ani));
+		else if (ast_channel_cid_ani(chan) != NULL && !ast_strlen_zero(ast_channel_cid_ani(chan)))
+		         strncpy(chan_vars->trs_reply.body.ic_event.ic_ani, ast_channel_cid_ani(chan),
+		               sizeof(chan_vars->trs_reply.body.ic_event.ic_ani));
+      else if (ast_channel_caller(chan)->id.number.valid)
+         strncpy(chan_vars->trs_reply.body.ic_event.ic_ani, ast_channel_caller(chan)->id.number.str,
+         sizeof(chan_vars->trs_reply.body.ic_event.ic_ani));
+      // else chan_vars->trs_reply.body.ic_event.ic_ani[0] = '\0'; // we don't need this cause trs_reply was memset'd
+
+      //Get DNIS
+      if (ast_channel_cid_uri(chan) != NULL)
+   		strncpy(chan_vars->trs_reply.body.ic_event.ic_dnis, 
+   		      ast_channel_cid_uri(chan),
+   		      sizeof(chan_vars->trs_reply.body.ic_event.ic_dnis));
+      else if (ast_channel_cid_dnis(chan) != NULL)
+         strncpy(chan_vars->trs_reply.body.ic_event.ic_dnis,
+               ast_channel_cid_dnis(chan),
+               sizeof(chan_vars->trs_reply.body.ic_event.ic_dnis));
+      else if (ast_channel_dialed(chan)->number.str != NULL)
+         strncpy(chan_vars->trs_reply.body.ic_event.ic_dnis, 
+               ast_channel_dialed(chan)->number.str,
+            sizeof(chan_vars->trs_reply.body.ic_event.ic_dnis));
+
+      //Get To:
+      if (ast_channel_cid_dnis(chan) != NULL)
+         strncpy(chan_vars->trs_reply.body.ic_event.ic_to, 
+               ast_channel_cid_dnis(chan),
+            sizeof(chan_vars->trs_reply.body.ic_event.ic_to));
+
+      //Get call forwarding - chan->call_forward
+      if (ast_channel_redirecting(chan)->from.number.valid)
+         strncpy(chan_vars->trs_reply.body.ic_event.redirecting_num,
+               ast_channel_redirecting(chan)->from.number.str,
+            sizeof(chan_vars->trs_reply.body.ic_event.redirecting_num));
+      else if (ast_channel_redirecting(chan)->to.number.valid)
+         strncpy(chan_vars->trs_reply.body.ic_event.redirecting_num,
+               ast_channel_redirecting(chan)->to.number.str,
+            sizeof(chan_vars->trs_reply.body.ic_event.redirecting_num));
+      
+      //Get extra params
+		if (strlen(ast_channel_url_params(chan)) > 0)
+			strncpy(chan_vars->trs_reply.body.urlParams, ast_channel_url_params(chan), sizeof(chan_vars->trs_reply.body.urlParams));
+		else
+			sprintf(chan_vars->trs_reply.body.urlParams, " ");
+
+		if (ast_channel_cid_privacy(chan) != NULL && !ast_strlen_zero(ast_channel_cid_privacy(chan)) && strncmp(ast_channel_cid_privacy(chan), "none", 4)) // != "none"
+		   chan_vars->trs_reply.body.ic_event.ani_pre_indicator = 1;
+
+      if (ast_channel_caller(chan)->id.name.valid)
+      {
+         if (strlen(ast_channel_caller(chan)->id.name.str) > 0)
+            strncpy(chan_vars->trs_reply.body.ic_event.ic_location, ast_channel_caller(chan)->id.name.str,
+               sizeof(chan_vars->trs_reply.body.ic_event.ic_location));
+         else sprintf(chan_vars->trs_reply.body.ic_event.ic_location, " ");
+      }
+      else
+         sprintf(chan_vars->trs_reply.body.ic_event.ic_location, " ");
+
+      //Get Terminal
+      if (ast_format_cap_has_type(ast_channel_jointcapability(chan), AST_FORMAT_TYPE_VIDEO)) chan_vars->trs_reply.body.ic_event.ic_terminal = 3; //VIDEO_TERMINAL
+
+      //Get INVITE in extradata
+      if (ast_channel_extradata(chan)[0] != '\0')
+         strncpy(chan_vars->trs_reply.body.ic_event.ic_extradata, ast_channel_extradata(chan),
+            sizeof(chan_vars->trs_reply.body.ic_event.ic_extradata));
+      else
+         sprintf(chan_vars->trs_reply.body.ic_event.ic_extradata, " ");
+
+      if (ast_opt_use_smra)
+      {
+         // Set SMRA values
+         memcpy(&chan_vars->trs_reply.body.smra_attrib, ast_channel_client_smra_attrib(chan), sizeof(chan_vars->trs_reply.body.smra_attrib));
+         memcpy(&chan_vars->trs_reply.body.sdp, ast_channel_client_sdp(chan), sizeof(chan_vars->trs_reply.body.sdp));
+         chan_vars->trs_reply.use_smra = 1;
+      }
+	}
+	else	// OUTBOUND CALLs
+	{
+		strncpy(strnum, (char *)data, sizeof(strnum)-1);
+		stringp1 = strnum;
+		strsep(&stringp1, "#");
+		stringp2 = stringp1;
+		strsep(&stringp2, "#");
+      stringp3 = stringp2;
+      strsep(&stringp3, "#");
+
+      if (wms_debug)
+      {
+         //change to LOG_EVENT afterwords
+         ast_log(LOG_DEBUG, "\nName          : %-30s |\n"
+                          "Caller Number : %-30s | Caller Name   : %s\n"
+                             "ANI           : %-30s | ANI (digits)  : %-30s\n"
+                             "Addr          : %-30s | Addr 2        : %-30s\n"
+                             "ANI 2         : %-30d | Type of Number: %-30d\n"
+                             "Conn Number   : %-30s | Conn Name     : %-30s\n"
+                             "Conn ANI      : %-30s | Conn ANI 2    : %-30s\n"
+                             "Addr          : %-30s | Addr 2        : %-30s\n"
+                             "Redir Number  : %-30s | Redir Name    : %-30s\n"
+                             "Redir ANI     : %-30s | Redir ANI 2   : %-30s\n"
+                             "Addr          : %-30s | Addr 2        : %-30s\n"
+                             "Count         : %-30d | Reason        : %-30d\n"
+                             "DNID          : %-30s | DNID Addr     : %-30s\n"
+                             "Data          : %-30s | Exten         : %-30s |\n"
+                          "UNIQUEID      : %-30s | SMRA          : %-30s\n"
+                          "DNIS          : %-30s | ANI           : %s\n"
+                          "CALLID        : %-30s | REQ URI       : %s\n",
+                                ast_channel_name(chan),
+                                S_COR(ast_channel_caller(chan)->id.number.valid, ast_channel_caller(chan)->id.number.str, "<unknown>"), // From: Number
+                                S_COR(ast_channel_caller(chan)->id.name.valid, ast_channel_caller(chan)->id.name.str, "<unknown>"),     // From: Name
+                                S_COR(ast_channel_caller(chan)->ani.name.valid, ast_channel_caller(chan)->ani.name.str, "<unknown>"),
+                                S_COR(ast_channel_caller(chan)->ani.number.valid, ast_channel_caller(chan)->ani.number.str, "<unknown>"),
+                                S_COR(ast_channel_caller(chan)->id.subaddress.valid, ast_channel_caller(chan)->id.subaddress.str, "<unknown>"),
+                                S_COR(ast_channel_caller(chan)->ani.subaddress.valid, ast_channel_caller(chan)->ani.subaddress.str, "<unknown>"),
+                                ast_channel_caller(chan)->ani2, ast_channel_caller(chan)->id.number.plan,
+                                S_COR(ast_channel_connected(chan)->id.number.valid, ast_channel_connected(chan)->id.number.str, "<unknown>"),
+                                S_COR(ast_channel_connected(chan)->id.name.valid, ast_channel_connected(chan)->id.name.str, "<unknown>"),
+                                S_COR(ast_channel_connected(chan)->ani.name.valid, ast_channel_connected(chan)->ani.name.str, "<unknown>"),
+                                S_COR(ast_channel_connected(chan)->ani.number.valid, ast_channel_connected(chan)->ani.number.str, "<unknown>"),
+                                S_COR(ast_channel_connected(chan)->id.subaddress.valid, ast_channel_connected(chan)->id.subaddress.str, "<unknown>"),
+                                S_COR(ast_channel_connected(chan)->ani.subaddress.valid, ast_channel_connected(chan)->ani.subaddress.str, "<unknown>"),
+                                S_COR(ast_channel_redirecting(chan)->from.name.valid, ast_channel_redirecting(chan)->from.name.str, "<unknown>"),
+                                S_COR(ast_channel_redirecting(chan)->from.number.valid, ast_channel_redirecting(chan)->from.number.str, "<unknown>"),
+                                S_COR(ast_channel_redirecting(chan)->to.name.valid, ast_channel_redirecting(chan)->to.name.str, "<unknown>"),
+                                S_COR(ast_channel_redirecting(chan)->to.number.valid, ast_channel_redirecting(chan)->to.number.str, "<unknown>"),
+                                S_COR(ast_channel_redirecting(chan)->from.subaddress.valid, ast_channel_redirecting(chan)->from.subaddress.str, "<unknown>"),
+                                S_COR(ast_channel_redirecting(chan)->to.subaddress.valid, ast_channel_redirecting(chan)->to.subaddress.str, "<unknown>"),
+                                ast_channel_redirecting(chan)->count, ast_channel_redirecting(chan)->reason,
+                                (ast_channel_dialed(chan)->number.str != NULL ? ast_channel_dialed(chan)->number.str : "<unknown>"),
+                                S_COR(ast_channel_dialed(chan)->subaddress.valid, ast_channel_dialed(chan)->subaddress.str, "<unknown>"), // Req-U
+                                (char *)data, ast_channel_exten(chan),
+                             ast_channel_uniqueid(chan), ast_opt_use_smra ? "ON" : "OFF",
+                             ast_channel_cid_dnis(chan), ast_channel_cid_ani(chan),
+                             ast_channel_cid_callid(chan), ast_channel_cid_uri(chan));
+
+      if (ast_opt_use_smra)
+      {
+         ast_log(LOG_DEBUG, 
+            "L AUDIO IP    : %-30s | L VIDEO IP    : %s\n"
+            "L AUDIO PORT  : %-30d | L VIDEO PORT  : %d\n"
+            "R AUDIO IP    : %-30s | R VIDEO IP    : %s\n"
+            "R AUDIO PORT  : %-30d | R VIDEO PORT  : %d\n",
+            ast_channel_server_smra_attrib(chan)->rtpa_ip, ast_channel_server_smra_attrib(chan)->rtpv_ip,
+            ast_channel_server_smra_attrib(chan)->rtpa_port, ast_channel_server_smra_attrib(chan)->rtpv_port,
+            ast_channel_client_smra_attrib(chan)->rtpa_ip, ast_channel_client_smra_attrib(chan)->rtpv_ip,
+            ast_channel_client_smra_attrib(chan)->rtpa_port, ast_channel_client_smra_attrib(chan)->rtpv_port);
+      }
+      }
+		ast_answer(chan); // make sure channel is in UP STATE
+		chan_vars->trs_reply.event = MAKE_CALL_COMPLETED;
+
+      //Get call forwarding
+      if (ast_channel_dialed(chan)->number.str != NULL)
+		   strncpy(chan_vars->trs_reply.body.mk_info.redirection_num, 
+		      ast_channel_dialed(chan)->number.str,
+            sizeof(chan_vars->trs_reply.body.mk_info.redirection_num));
+
+      if (ast_channel_caller(chan)->id.name.valid)
+      {
+         if (strlen(ast_channel_caller(chan)->id.name.str) > 0)
+            strncpy(chan_vars->trs_reply.body.ic_event.ic_location, ast_channel_caller(chan)->id.name.str,
+            sizeof(chan_vars->trs_reply.body.ic_event.ic_location));
+         else sprintf(chan_vars->trs_reply.body.ic_event.ic_location, " ");
+      }
+      else
+         sprintf(chan_vars->trs_reply.body.ic_event.ic_location, " ");
+
+      //Get mk_terminal
+      if (ast_format_cap_has_type(ast_channel_jointcapability(chan), AST_FORMAT_TYPE_VIDEO)) chan_vars->trs_reply.body.mk_info.mk_terminal = 3; //VIDEO_TERMINAL
+		chan_vars->trs_reply.body.mk_info.redirecting_cause = 0;
+		chan_vars->trs_reply.body.terminator.call_connected = 1; // must support line_busy, no_answer, no_dial_tone and no_ring replies!
+		chan_vars->trs_reply.con_id = atoi(strnum);
+		chan_vars->trs_reply.sender = atoi(stringp1);
+		chan_vars->trs_reply.cmd_cnt= atoi(stringp2);
+      chan_vars->chan_id = atoi(stringp3);
+      chan_vars->trs_reply.chan_id = chan_vars->chan_id;
+
+      if (ast_opt_use_smra)
+      {
+         // Set SMRA values
+         memcpy(&chan_vars->trs_reply.body.smra_attrib, ast_channel_client_smra_attrib(chan), sizeof(chan_vars->trs_reply.body.smra_attrib));
+         memcpy(&chan_vars->trs_reply.body.sdp, ast_channel_client_sdp(chan), sizeof(chan_vars->trs_reply.body.sdp));
+         chan_vars->trs_reply.use_smra = 1;
+      }
+	}
+	asteriskSendReply(&chan_vars->trs_reply, chan_vars);
+
+   // Initialize before loop
+   memset(&chan_vars->trs_reply, 0, sizeof(chan_vars->trs_reply));
+
+   if (ast_opt_send_ringing)
+      ast_indicate(chan, AST_CONTROL_RINGING);
+
+   if (!ast_opt_use_smra) run_asterisk_channel(chan, chan_vars);
+   else run_smra_channel(chan, chan_vars);
+
+   shutdown(trs_sock_fd, SHUT_RDWR);
+	close(trs_sock_fd);
+	trs_sock_fd = -1;
+
+   if (chan_vars != NULL) 
+   {
+      free(chan_vars);
+      chan_vars = NULL;
+   }
+
+   ast_module_user_remove(u);
+	return -1;
+}
+
+/******************************************************************************
+ *        NAME: run_smra_channel()
+ * DESCRIPTION: Run Channel with SMRA resources
+ *              
+ *****************************************************************************/
+static void run_smra_channel(struct ast_channel *chan, ast_vars *chan_vars)
+{
+   int nbytes = 0, data_available = 0;
+   struct timeval select_timeout;
+   ast_fdset master;	// master file descriptor list
+   cmd_ast trs_cmd;
+
+   //- MAIN LOOP ------------------------------------------------------------------------
+   while (!chan_vars->shutdown)
+   {
+      // TODO: lock on usage
+      if (chan == NULL)
+      {
+         ast_log(LOG_NOTICE, "Chan is NULL\n");
+         chan_vars->shutdown = 1;
+         break;
+      }
+      if (!ast_tvzero(chan_vars->early_media) && ast_tvdiff_sec(ast_tvnow(), chan_vars->early_media) > 25000)
+      {
+         //Must comment chan_sip.c ast_indicate AST_CONTROL_PROGRESS -> !ast_test_flag(&p->flags[0], SIP_PROGRESS_SENT) &&
+         ast_indicate(chan, AST_CONTROL_PROGRESS);
+         chan_vars->early_media = ast_tvnow();
+      }
+      FD_ZERO(&master); 	// clear the master and temp sets
+      FD_SET(chan_vars->trs_fd, &master);
+   
+      select_timeout.tv_sec = 0;
+      select_timeout.tv_usec = 100000;
+   
+      // TODO: chan_vars->trs_fd + 1 can be bigger than FDSET_SIZE
+      // See if sockets have activity
+      if ((data_available = ast_select(chan_vars->trs_fd + 1, &master, NULL, NULL, &select_timeout)) < 0)
+      {
+         ast_log(LOG_WARNING, "select failed (%s)\n", strerror(errno));
+      
+         chan_vars->shutdown = 1;
+         // ast_softhangup(chan, AST_CAUSE_NORMAL);// hangup line
+         break;
+      }
+   
+      //- TRS socket had activity -------------------------------------------------------------------------------
+      if (data_available > 0 && chan)
+      {
+         while ((nbytes = recv(chan_vars->trs_fd, &trs_cmd, sizeof(trs_cmd), 0)) > 0)
+         {
+            if (nbytes != sizeof(trs_cmd))
+            {
+               ast_log(LOG_ERROR, "Got incomplete command on chan %s\n", ast_channel_name(chan));
+               usleep(1000);
+               continue;
+            }
+            chan_vars->trs_reply.cmd_cnt = trs_cmd.cmd_cnt;
+            switch(trs_cmd.cmd_id)
+            {
+            case RELEND: release_endpoint(chan, trs_cmd, chan_vars); break;
+            case CONCAL: connect_call(chan, trs_cmd, chan_vars); break;
+               // is ! STATE_UP
+            case ACCICA: accept_icall(chan, trs_cmd, chan_vars); break;
+            case REJICA: reject_icall(chan, trs_cmd, chan_vars); break;                  
+            default: ast_log(LOG_ERROR, "Got unknown cmd_id %d\n", trs_cmd.cmd_id); break;
+            }
+         }
+         if (!nbytes || (errno != EWOULDBLOCK && errno != EAGAIN))
+         {
+            // Don't hangup again if already hanging up
+            if (chan_vars->shutdown) break;
+         
+            if (!nbytes || errno == ECONNRESET) ast_log(LOG_WARNING, "TRS socket closed on channel %s\n", ast_channel_name(chan));
+            else ast_log(LOG_ERROR, "TRS socket error (%d: %s) on channel %s\n", errno, strerror(errno), ast_channel_name(chan));
+
+            chan_vars->shutdown = 1;
+         
+            if (ast_channel_state(chan) != AST_STATE_UP)
+               ast_channel_hangupcause_set(chan, ast_channel_defhangcause(chan));
+         
+            // ast_softhangup(chan, AST_CAUSE_NORMAL);// hangup line
+            break;
+         }		
+      }
+      if (ast_test_flag(ast_channel_inoflags(chan), SIP_GOT_REINVITE))
+      {
+         reply_ast trs_reply;
+      
+         memset(&trs_reply, 0, sizeof(reply_ast));
+         if (option_verbose >= 4)
+            ast_verbose(VERBOSE_PREFIX_4 "Got a SIP re-INVITE!\n");
+         ast_clear_flag(ast_channel_inoflags(chan), SIP_GOT_REINVITE);
+      
+         // Set SMRA values
+         memcpy(&trs_reply.body.smra_attrib, ast_channel_client_smra_attrib(chan), sizeof(chan_vars->trs_reply.body.smra_attrib));
+         memcpy(&trs_reply.body.sdp, ast_channel_client_sdp(chan), sizeof(trs_reply.body.sdp));
+
+         trs_reply.body.mk_info.sig_cause = 200;
+         if (ast_format_cap_has_type(ast_channel_jointcapability(chan), AST_FORMAT_TYPE_VIDEO)) trs_reply.body.mk_info.mk_terminal = 3; //VIDEO_TERMINAL
+
+         trs_reply.cmd_cnt = chan_vars->trs_reply.cmd_cnt;
+         trs_reply.con_id = chan_vars->trs_reply.con_id;
+         trs_reply.sender = chan_vars->trs_reply.sender;
+         trs_reply.evt_type = CALL_PROGRESS_DETECTED;
+         trs_reply.event = UNSOLICITED_EVENT;
+      
+         asteriskSendReply(&trs_reply, chan_vars);
+      }
+      //- Other checks --------------------------------------------------------------------------------------------------
+      // This must be first so we don't send COMPLETED events before LOOP_CURRENT_ENDPOINT
+      if (ast_check_hangup(chan) || ast_test_flag(ast_channel_flags(chan), AST_FLAG_ZOMBIE))
+      {
+         if (option_verbose >= 3)
+            ast_verbose(VERBOSE_PREFIX_3 "Hangup on channel %s\n", ast_channel_name(chan));
+         chan_vars->shutdown = 1;
+         // ast_softhangup(chan, AST_CAUSE_NORMAL);// hangup line
+         break;
+      }      
+   }
+}
+
+/******************************************************************************
+ *        NAME: run_asterisk_channel()
+ * DESCRIPTION: Run Channel with Asterisk resources
+ *              
+ *****************************************************************************/
+static void run_asterisk_channel(struct ast_channel *chan, ast_vars *chan_vars)
+{
+   int times = 0, data_available = 0, numcs = 0;
+   struct ast_channel *tempcs[2], *who;
+   struct ast_frame *f;
+   cmd_ast trs_cmd;
+   int nbytes = 0;
+
+   tempcs[0] = chan;
+   numcs = 1;
+
+//- MAIN LOOP ------------------------------------------------------------------------
+	while (!chan_vars->shutdown)
+	{
+	   if (chan == NULL)
+	   {
+         ast_log(LOG_NOTICE, "Chan is NULL\n");
+         chan_vars->shutdown = 1;
+         break;
+	   }
+      // If conference is enabled or we are the 2nd channel in a route_endpoint, don't lock channel
+      if (chan_vars->conference.id || (ast_bridged_channel(chan) && chan_vars->action.type != ACTION_ROUEND)) 
+      {
+         //don't block channel 
+         tempcs[0] = 0; numcs = 0;
+      }
+      else if (chan_vars->action.cs[1] != NULL)
+      {
+         tempcs[0] = chan_vars->action.cs[0];
+         tempcs[1] = chan_vars->action.cs[1];
+         numcs = 2;
+      }
+      else
+      {
+         tempcs[0] = chan; numcs = 1;
+      }
+      if (chan_vars->ms <= 0 || chan_vars->ms > 1000)
+      {
+         if (chan_vars->action.type == ACTION_PLAANN && chan_vars->action.fp != NULL && 
+            chan_vars->action.cs[0] == NULL) chan_vars->ms = 20;
+         else chan_vars->ms = 200;
+      }
+      // This must be first so we don't send COMPLETED events before LOOP_CURRENT_ENDPOINT
+      if (ast_check_hangup(chan) || ast_test_flag(ast_channel_flags(chan), AST_FLAG_ZOMBIE))
+      {
+         if (option_verbose >= 3)
+            ast_verbose(VERBOSE_PREFIX_3 "Hangup on channel %s\n", ast_channel_name(chan));
+
+         chan_vars->shutdown = 1;
+         // ast_softhangup(chan, AST_CAUSE_NORMAL); // hangup line
+         break;
+		}
+      if (!ast_tvzero(chan_vars->early_media) && ast_tvdiff_sec(ast_tvnow(), chan_vars->early_media) > 25000)
+      {
+         //Must comment chan_sip.c ast_indicate AST_CONTROL_PROGRESS -> !ast_test_flag(&p->flags[0], SIP_PROGRESS_SENT) &&
+         ast_indicate(chan, AST_CONTROL_PROGRESS);
+         chan_vars->early_media = ast_tvnow();
+      }
+      who = ast_waitfor_nandfds(tempcs, numcs, &chan_vars->trs_fd, 1, NULL, &data_available, &chan_vars->ms);
+		if (!who && (data_available < 0) && (chan_vars->ms)) 
+      {
+			// Continue 
+			if (errno == EINTR) continue;
+
+			ast_log(LOG_ERROR, "Wait failed (%s)\n", strerror(errno));
+			chan_vars->shutdown = 1;
+			// ast_softhangup(chan, AST_CAUSE_NORMAL);// hangup line
+         break;
+		}
+
+      //- TRS socket had activity -------------------------------------------------------------------------------
+      if (data_available > -1)
+		{
+         //- TRS socket had activity -------------------------------------------------------------------------------
+         while ((nbytes = recv(chan_vars->trs_fd, &trs_cmd, sizeof(trs_cmd), 0)) > 0)
+         {
+            if (nbytes != sizeof(trs_cmd))
+         {
+               ast_log(LOG_ERROR, "Got incomplete command on chan %s\n", ast_channel_name(chan));
+               sleep(1000);
+               continue;
+            }
+				chan_vars->trs_reply.cmd_cnt = trs_cmd.cmd_cnt;
+
+				if (trs_cmd.term_cond.maxtime == 0) trs_cmd.term_cond.maxtime = 60000;
+				switch(trs_cmd.cmd_id)
+				{
+      			case ATTCAP: attach_capabilities(chan, trs_cmd, chan_vars); break;
+               case CLEDIB: chan_vars->digit_buffer[0] = '\0'; break;
+					case EXEAST: exec_asterisk(chan, trs_cmd, chan_vars); break;
+					case GETDIX:
+					case GETDIG: get_digits(chan, trs_cmd, chan_vars); break;
+					case PLAANN:
+					case PLADAT:
+					case PLAIND: 
+					case TTSPRO: play_announcement(chan, trs_cmd, chan_vars); break;
+					case PLADIG: play_digits(chan, trs_cmd, chan_vars); break;
+					case RECVOX:
+					case RECVOI: record_voice(chan, trs_cmd, chan_vars); break;
+					case SETHST:
+					case RELEND: release_endpoint(chan, trs_cmd, chan_vars); break;
+					case RESEND: reset_endpoint(chan, trs_cmd, chan_vars); break;
+					case ROUEND: route_endpoint(chan, trs_cmd, chan_vars); break;
+					case STOPER: stop_operation(chan, trs_cmd, chan_vars); break;
+               case CNFMGR: conference_call(chan, trs_cmd, chan_vars); break;
+               case CONCAL: connect_call(chan, trs_cmd, chan_vars); break;
+					case ACCICA: accept_icall(chan, trs_cmd, chan_vars); break;
+               case REJICA: reject_icall(chan, trs_cmd, chan_vars); break;                  
+               default: ast_log(LOG_ERROR, "Got unknown cmd_id %d\n", trs_cmd.cmd_id); break;
+				}
+         }
+         if (!nbytes || (errno != EWOULDBLOCK && errno != EAGAIN))
+         {
+            // Don't hangup again if already hanging up
+            if (chan_vars->shutdown) break;
+            
+            if (!nbytes || errno == ECONNRESET) ast_log(LOG_WARNING, "TRS socket closed on channel %s\n", ast_channel_name(chan));
+            else ast_log(LOG_ERROR, "TRS socket error (%d: %s) on channel %s\n", errno, strerror(errno), ast_channel_name(chan));
+
+				chan_vars->shutdown = 1;
+				
+            if (ast_channel_state(chan) != AST_STATE_UP)
+               ast_channel_hangupcause_set(chan, ast_channel_defhangcause(chan));
+            
+				// ast_softhangup(chan, AST_CAUSE_NORMAL);// hangup line
+            break;
+         }		
+		}
+
+      //- Channel(s) had activity -----------
+      if (who)
+      {
+         if ((f = ast_read(who)))
+			{
+            if (f->frametype == AST_FRAME_TEXT)
+            {
+               if (option_verbose >= 4)
+                  ast_verbose(VERBOSE_PREFIX_4 "Got SIP INFO on channel %s\n", ast_channel_name(chan));
+
+               if (f->subclass.integer == AST_TEXT_XML)
+               {
+	               //build_reply(chan_vars);
+	               chan_vars->trs_reply.event = UNSOLICITED_EVENT;
+	               chan_vars->trs_reply.evt_type = SIP_INFO;
+	               chan_vars->trs_reply.error = FALSE;
+
+                  if (sizeof(chan_vars->trs_reply.body.userData) < f->datalen + 3) // 2 x ESC + 1 x \0
+                  {
+                     ast_log(LOG_NOTICE, "AST_FRAME_TEXT size bigger than buffer on channel %s\n", ast_channel_name(chan));
+   
+                     snprintf(chan_vars->trs_reply.body.userData, sizeof(chan_vars->trs_reply.body.userData) - 1,
+                        "%c%s", 27, (char *)f->data.ptr); // writes "\ESC + f->data + \0" and leaves space for the last \ESC
+                     strcat(chan_vars->trs_reply.body.userData, "\033");
+                  }
+                  // size = 1 (\ESC) + f->datalen + 1 (\ESC) + \ (\0) = f->datalen + 3
+                  else snprintf(chan_vars->trs_reply.body.userData, f->datalen + 3, "%c%s%c", 27, (char *)f->data.ptr, 27);
+
+	               asteriskSendReply(&chan_vars->trs_reply, chan_vars);
+               }
+            }
+				else if (f->frametype == AST_FRAME_DTMF && who == chan) process_digit(chan, chan_vars, f->subclass.integer);
+				else if (f->frametype == AST_FRAME_CONTROL && who == chan && (f->subclass.integer == AST_CONTROL_HANGUP ||
+                         f->subclass.integer == AST_CONTROL_BUSY || f->subclass.integer == AST_CONTROL_CONGESTION || f->subclass.integer == AST_CONTROL_TRANSFER))
+				{
+               if (option_verbose >= 3)
+                  ast_verbose(VERBOSE_PREFIX_3 "Got control hangup on channel %s\n", ast_channel_name(chan));
+   
+					chan_vars->shutdown = 1;
+					// ast_softhangup(chan, AST_CAUSE_NORMAL);// hangup line
+               break;
+				}
+				if (chan_vars->asr.asr_sock > 0) 
+            {
+               if (who == chan && (f->frametype == AST_FRAME_DTMF || 
+                      f->frametype == AST_FRAME_VOICE || f->frametype == AST_FRAME_VIDEO))
+                  send_asr(f, chan_vars);
+            }
+            //--- 2 CH ROUTING ------------------------------------------------------------------------------
+            if (chan_vars->action.cs[1])
+            {
+               struct ast_channel *ctmp;
+               if (f->frametype == AST_FRAME_VOICE || f->frametype == AST_FRAME_VIDEO || 
+                  f->frametype == AST_FRAME_DTMF_BEGIN || f->frametype == AST_FRAME_DTMF_END)
+		         {
+			         // Don't copy packets if there is a generator on either one, since they're not supposed to be listening anyway 
+			         if (who == chan_vars->action.cs[0]) ast_write(chan_vars->action.cs[1], f);
+			         else ast_write(chan_vars->action.cs[0], f);
+		         }
+		         // Swap who gets priority 
+		         ctmp = chan_vars->action.cs[0];
+		         chan_vars->action.cs[0] = chan_vars->action.cs[1];
+		         chan_vars->action.cs[1] = ctmp;
+            }
+            //--- ACTION_RECVOI ------------------------------------------------------------------------------
+            if (chan_vars->action.type == ACTION_RECVOI)
+	         {
+	            if (chan_vars->action.cs[0] == NULL)
+	            {
+		            if (f->frametype == AST_FRAME_VOICE || f->frametype == AST_FRAME_VIDEO)
+		            {
+                     if (chan_vars->action.record == NULL)
+                     {
+                        if (chan_vars->action.fp != NULL)
+                        {
+                           rec_frame recs;
+                           int res;
+         
+                           recs.ts = ast_tvnow();
+                           recs.frametype = f->frametype;
+	                        recs.subclass = f->subclass;
+	                        recs.datalen = f->datalen;
+	                        recs.samples = f->samples;
+         	               recs.mallocd = f->mallocd;
+	                        recs.offset = f->offset;
+	                        recs.delivery = f->delivery;
+                           if ((res = fwrite(&recs, 1, sizeof(recs), chan_vars->action.fp)) != sizeof(recs)) 
+                           {
+			                     ast_log(LOG_WARNING, "Bad write (%d/%d)\n", res, sizeof(recs));
+
+				                  build_reply(chan_vars);
+                              chan_vars->trs_reply.error = TRUE;
+                              chan_vars->trs_reply.body.error_value = RESOURCE_ERROR;
+				                  stop_action(chan, chan_vars);
+	                        }
+                           if ((res = fwrite(f->data.ptr, 1, f->datalen, chan_vars->action.fp)) != f->datalen)
+                           {
+			                     ast_log(LOG_WARNING, "Bad write (%d/%d): %s\n", res, f->datalen, strerror(errno));
+
+				                  build_reply(chan_vars);
+                              chan_vars->trs_reply.error = TRUE;
+                              chan_vars->trs_reply.body.error_value = RESOURCE_ERROR;
+				                  stop_action(chan, chan_vars);
+	                        }
+                        }
+                        else
+                        {
+				               ast_log(LOG_WARNING, "Record(): Problem writing frame to file. File error!\n");
+				               build_reply(chan_vars);
+                           chan_vars->trs_reply.error = TRUE;
+                           chan_vars->trs_reply.body.error_value = RESOURCE_ERROR;
+				               stop_action(chan, chan_vars);
+                        }
+                     }
+                     else 
+                     {
+                        //Don't use asterisk's embeded video framing
+                        if (f->frametype == AST_FRAME_VOICE && ast_writestream(chan_vars->action.record, f) < 0)
+                        {
+				               ast_log(LOG_WARNING, "Record(): Problem writing frame to file\n");
+				               build_reply(chan_vars);
+                           chan_vars->trs_reply.error = TRUE;
+                           chan_vars->trs_reply.body.error_value = RESOURCE_ERROR;
+				               stop_action(chan, chan_vars);
+                        }
+                     }
+		            }
+               }
+            }
+            //--- ACTION_ROUEND ------------------------------------------------------------------------------
+            else if (chan_vars->action.type == ACTION_ROUEND &&
+                     f->frametype == AST_FRAME_DTMF && chan_vars->action.bridge_retkey != '\0' &&
+		               chan_vars->action.bridge_retkey == f->subclass.integer)
+            {
+	            build_reply(chan_vars);
+	            chan_vars->trs_reply.event = UNSOLICITED_EVENT;
+	            chan_vars->trs_reply.evt_type = CALL_RETURN_KEY_DETECTED;
+	            chan_vars->trs_reply.body.terminator.specific_digit_received = 1;
+	            asteriskSendReply(&chan_vars->trs_reply, chan_vars);
+            }
+				if (f) ast_frfree(f);
+			}
+			else
+			{
+            if (option_verbose >= 3)
+               ast_verbose(VERBOSE_PREFIX_3 "Got hangup on channel %s\n", ast_channel_name(chan));
+
+            if (chan_vars->action.type == ACTION_ROUEND && who != chan)
+            {
+               if (option_verbose >= 4)
+                  ast_verbose(VERBOSE_PREFIX_4 "Unlinking routed channel %s\n", ast_channel_name(chan));
+               stop_action(chan, chan_vars);
+               continue;
+            }
+
+				chan_vars->shutdown = 1;
+				// ast_softhangup(chan, AST_CAUSE_NORMAL);// hangup line
+            break;
+			}                
+      } //if (who)
+
+      //- Do other events -------------------------------------------------------------------------------
+      if (chan_vars->ms > 0) continue;
+
+      if (chan_vars->action.type == ACTION_PLAANN)
+      {
+         if (chan_vars->action.cs[0] == NULL)
+	      {
+            //---- play file section ---------------------------
+            if (chan_vars->action.fp == NULL)
+            {
+               chan_vars->ms = ast_sched_wait(ast_channel_sched(chan));
+			      if ((chan_vars->ms < 0) && !ast_channel_timingfunc(chan))
+			      {
+			         ast_stopstream(chan);
+				      build_reply(chan_vars);
+				      chan_vars->trs_reply.body.terminator.end_of_data = 1;
+				      stop_action(chan, chan_vars);
+               }
+               ast_sched_runq(ast_channel_sched(chan)); //it's important to run queue or audio cuts
+               if (chan_vars->ms == 0) chan_vars->ms = 1;
+            }
+            //---- play IVX file section ---------------------------
+            else
+            {
+               struct timeval clockTime = ast_tvnow();
+               struct ast_frame fsend;
+               char data[30000];
+               int res;
+
+               while (!feof(chan_vars->action.fp))
+               {
+                  if (!chan_vars->ivx.recFrame.frametype)
+                  {
+                     if (ast_tvzero(chan_vars->ivx.startclock)) chan_vars->ivx.startclock = clockTime;
+
+                     if ((res = fread(&chan_vars->ivx.recFrame, 1, sizeof(chan_vars->ivx.recFrame), 
+                        chan_vars->action.fp)) == sizeof(chan_vars->ivx.recFrame))
+                     {
+                        if (ast_tvzero(chan_vars->ivx.firstts)) chan_vars->ivx.firstts = chan_vars->ivx.recFrame.ts;
+                     }
+                     else 
+                     {
+                        ast_log(LOG_WARNING, "Bad read: received %d bytes from %d\n", res, chan_vars->ivx.recFrame.datalen);
+				            build_reply(chan_vars);
+				            chan_vars->trs_reply.body.terminator.end_of_data = 1;
+				            stop_action(chan, chan_vars);
+                        chan_vars->ivx.recFrame.frametype = 0;
+                        break;
+                     }
+                  }
+                  if (chan_vars->ivx.recFrame.frametype) //chan_vars->ivx.recFrame.frametype
+                  {
+                     if (ast_tvdiff_ms(clockTime, chan_vars->ivx.startclock) >=
+                           ast_tvdiff_ms(chan_vars->ivx.recFrame.ts, chan_vars->ivx.firstts))
+                     {
+                        if (chan_vars->ivx.recFrame.datalen > sizeof(data))
+                        {
+                           ast_log(LOG_WARNING, "Data length %d exceeds buffer size %d\n", 
+                              chan_vars->ivx.recFrame.datalen, sizeof(data));
+
+		                     build_reply(chan_vars);
+		                     chan_vars->trs_reply.body.terminator.end_of_data = 1;
+		                     stop_action(chan, chan_vars);
+                           break;
+                        }
+                        else if ((res = fread(data, 1, chan_vars->ivx.recFrame.datalen, 
+                           chan_vars->action.fp)) == chan_vars->ivx.recFrame.datalen)
+                        {
+                           fsend.frametype = chan_vars->ivx.recFrame.frametype;
+	                        fsend.subclass = chan_vars->ivx.recFrame.subclass;
+	                        fsend.datalen = chan_vars->ivx.recFrame.datalen;
+	                        fsend.samples = chan_vars->ivx.recFrame.samples;
+         	               fsend.mallocd = chan_vars->ivx.recFrame.mallocd;
+	                        fsend.offset = chan_vars->ivx.recFrame.offset;
+	                        fsend.delivery = chan_vars->ivx.recFrame.delivery;
+                           fsend.src = "RTP";
+                           fsend.data.ptr = data;
+
+                           ast_write(chan, &fsend);
+                           chan_vars->ivx.recFrame.frametype = 0;
+                        }
+                        else 
+                        {
+                           ast_log(LOG_WARNING, "Bad read: received %d bytes from %d\n", res, sizeof(chan_vars->ivx.recFrame));
+		                     build_reply(chan_vars);
+		                     chan_vars->trs_reply.body.terminator.end_of_data = 1;
+		                     stop_action(chan, chan_vars);
+                           break;
+                        }
+                     }
+                     else break;
+                  }
+                  if (feof(chan_vars->action.fp))
+                  {
+				         build_reply(chan_vars);
+				         chan_vars->trs_reply.body.terminator.end_of_data = 1;
+				         stop_action(chan, chan_vars);
+                     break;
+                  }
+               }
+            }
+	      }
+      }
+
+      //- Check Terminations ------------
+      check_timeout_terminators(chan, chan_vars);
+
+//- Other checks --------------------------------------------------------------------------------------------------
+      //- do conference events ---------------------------------------------------------------------------------------
+      if (chan_vars->conference.id && ast_test_flag(ast_channel_inoflags(chan), MEETME_DO_PLAY))
+      {
+         reply_ast trs_reply;
+
+         //TODO: This should come in and AST_Text frame or another custom AST_FRAME
+         if (!strncmp(ast_channel_conf_playann(chan), "-1", 2)) //end of file
+         {
+//            ast_verbose(VERBOSE_PREFIX_3 "End of file on play_announcement on conference %d\n", chan_vars->conference.id);
+            memset(&trs_reply, 0, sizeof(trs_reply));
+	         trs_reply.cmd_cnt = chan_vars->conference.cmd_cnt;
+	         trs_reply.con_id = chan_vars->conference.con_id;
+	         trs_reply.sender = chan_vars->conference.edp_id;
+	         trs_reply.event = CONFERENCE_MANAGER_COMPLETED;
+            trs_reply.error = FALSE;
+            trs_reply.body.g_ret_value = 64; //CONF_PLAY
+            asteriskSendReply(&trs_reply, chan_vars);
+            ast_clear_flag(ast_channel_inoflags(chan), MEETME_DO_PLAY);
+         }
+         else if (!strncmp(ast_channel_conf_playann(chan), "-2", 2)) //error
+         {
+            ast_log(LOG_WARNING, "Error on play_announcement on conference %d\n", chan_vars->conference.id);
+            memset(&trs_reply, 0, sizeof(trs_reply));
+	         trs_reply.cmd_cnt = chan_vars->conference.cmd_cnt;
+	         trs_reply.con_id = chan_vars->conference.con_id;
+	         trs_reply.sender = chan_vars->conference.edp_id;
+	         trs_reply.event = CONFERENCE_MANAGER_COMPLETED;
+            trs_reply.error = TRUE;
+            trs_reply.body.error_value = RESOURCE_ERROR;
+            trs_reply.body.g_ret_value = 64; //CONF_PLAY
+            asteriskSendReply(&trs_reply, chan_vars);
+            ast_clear_flag(ast_channel_inoflags(chan), MEETME_DO_PLAY);
+         }
+      }
+	}
+   //- END OF MAIN LOOP -------------------------------------------------------------------
+   stop_action(chan, chan_vars);
+
+   //This must be here or else HANGUP will come before MeetMeLeave and channel: will have garbage
+   while (chan_vars->conference.id)
+   {
+      ++times;
+
+      if (chan_vars->conference.id) ast_set_flag(ast_channel_inoflags(chan), EXEC_APP_EXIT);
+
+      if (times == 100)  // 10 sec
+      {
+         if (option_verbose >= 3)
+            ast_verbose(VERBOSE_PREFIX_3 "Waited 10 secs for meetme to exit before hanging up\n");
+      }
+      if (times == 600) // 30 secs
+         ast_log(LOG_WARNING, "Waited 1 min for meetme to exit before hanging up\n");
+      if (times > 6000) // 600 secs
+      {         
+         ast_log(LOG_ERROR, "Waited 10 mins for meetme to exit before hanging up. Forcing hangup!\n");
+
+         kill_conference_thread(chan_vars);
+
+         break;
+      }
+      usleep(100000); // 100 milliseconds
+   }
+	if (chan_vars->asr.asr_writetrans) ast_translator_free_path(chan_vars->asr.asr_writetrans);
+   if (chan_vars->asr.asr_sock > 0)
+	{
+		close(chan_vars->asr.asr_sock);
+		chan_vars->asr.asr_sock = -1;
+	}
+}
+
+// TODO: Module debug
+
+//- Asterisk app functions ---------------------------------------------------------------
+static int unload_module(void)
+{
+	int res;
+
+	res = ast_unregister_application(app);
+
+	ast_module_user_hangup_all();
+
+	return res;
+}
+
+static int load_module(void)
+{
+   return ast_register_application_xml(app, wms_exec);
+}
+
+AST_MODULE_INFO_STANDARD(ASTERISK_GPL_KEY, "WMS Call Control Application");
+
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/apps/app_wms.h asterisk-11.3.0.p000/apps/app_wms.h
--- asterisk-base-11.3.0/apps/app_wms.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-11.3.0.p000/apps/app_wms.h	2013-05-13 14:00:47.680437842 +0100
@@ -0,0 +1,112 @@
+/*******************************************************************************
+ *        FILE: 
+ * DESCRIPTION: 
+ *              
+ * 
+ * $Archive: $
+ * $Revision: 1.0 $
+ * $Author: $
+ * $History: $
+ * 
+ * 
+ *   Copyright (c) 2005 PT Inovação SA. All Rights Reserved
+ ******************************************************************************/
+#ifndef APP_WMS_H
+#define APP_WMS_H
+
+/********************************************************************************
+*
+* GLOBAL VARIABLES
+*
+*********************************************************************************/
+
+extern ast_mutex_t digmux_lock;
+typedef enum
+{ 
+   NO_ACTION       = 0,
+   ACTION_GETDIG   = 1,
+   ACTION_PLAANN   = 2,
+   ACTION_RECVOI   = 3,
+   ACTION_ROUEND   = 4,
+} action_type;
+
+typedef struct {
+   struct timeval ts;
+   enum ast_frame_type frametype;
+   union ast_frame_subclass subclass;
+	int datalen;	/*! Length of data */
+	int samples;	/*! Number of 8khz samples in this frame */
+	int mallocd;	/*! Was the data malloc'd?  i.e. should we free it when we discard the frame? */
+	int offset;		/*! How many bytes exist _before_ "data" that can be used if needed */
+	struct timeval delivery;/*! Global delivery time */
+} rec_frame;
+
+typedef struct
+{
+   int asr_sock;   // ASR server socket descriptor
+	struct sockaddr_in asr_serv_addr;
+	int asr_lasttxformat;
+	unsigned int asr_lastts;
+	unsigned int asr_lastovidtimestamp;
+	unsigned int asr_rtp_ssrc;
+	unsigned short asr_rtp_seqno;
+	struct timeval asr_txcore;
+	struct ast_trans_pvt *asr_writetrans; // Write translation path
+} asr_struct;
+
+typedef struct
+{
+	int trs_fd;
+	struct timeval early_media;
+	int ms;
+	int shutdown;				      // used to control wms app existence
+   int dtmf;
+	char digit_buffer[DIGIT_LENGTH];
+   asr_struct asr;
+	reply_ast trs_reply;
+   int chan_id;                  // InoVox Channel ID
+   struct
+   {
+      rec_frame recFrame;
+      struct timeval startclock;
+      struct timeval firstts;
+   } ivx;
+   struct
+   {
+      int id;
+      char args[10];
+      unsigned long con_id;		// connection id
+	   unsigned long cmd_cnt;		// command count
+	   endpoint_id edp_id;			// endpoint id
+      int exit;
+   } conference;
+   pthread_t conf_thread;
+   struct
+   {
+      int enabled;
+      unsigned long con_id;		// connection id
+	   unsigned long cmd_cnt;		// command count
+	   endpoint_id edp_id;			// endpoint id
+   } stream;			// used for get_digitsEx
+   struct
+   {
+      action_type type;
+      unsigned long con_id;		// connection id
+	   unsigned long cmd_cnt;		// command count
+	   unsigned long cmd_id;		// command id
+	   endpoint_id edp_id;			// endpoint id
+      struct timeval cmd_start;
+	   struct timeval cmd_last;
+	   struct timeval cmd_end;
+	   float rtsp_play_duration;
+	   int cmd_event;				// event that shall be returned
+	   termination_cond term_cond;	// termination conditions
+	   struct ast_filestream *record;	// filestream used by record voice command
+      FILE *fp;
+	   struct ast_channel *cs[2];		// channel queue used in route endpoint command
+	   char bridge_retkey;				// key used to return from bridged mode
+	   char FILE_URL[256];
+   }  action;
+} ast_vars;
+
+#endif
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/apps/Makefile asterisk-11.3.0.p000/apps/Makefile
--- asterisk-base-11.3.0/apps/Makefile	2013-05-02 16:10:16.400437843 +0100
+++ asterisk-11.3.0.p000/apps/Makefile	2013-05-13 14:00:43.265187928 +0100
@@ -15,6 +15,20 @@
 MENUSELECT_CATEGORY=APPS
 MENUSELECT_DESCRIPTION=Applications
 
+# WMS SECTION
+
+OLD_ASTCFLAGS=ASTCFLAGS
+KERNEL = $(shell uname -r | sed -e 's/xenU//;s/xen//')
+ASTCFLAGS+=-g
+ASTCFLAGS+=-D_GNU_SOURCE -I../../cman/inc -I../../inoproto/inc -I. -I/opt/ptin/include
+
+SRCS =  app_wms.c \
+        wms_inoapi.c \
+        wms_aux.c
+
+OBJS = $(patsubst %.c, %.o, $(SRCS))
+
+# WMS END OF SECTION
 MENUSELECT_OPTS_app_directory:=$(MENUSELECT_OPTS_app_voicemail)
 ifneq ($(findstring ODBC_STORAGE,$(MENUSELECT_OPTS_app_voicemail)),)
   MENUSELECT_DEPENDS_app_voicemail+=$(MENUSELECT_DEPENDS_ODBC_STORAGE)
@@ -25,6 +39,12 @@
 
 all: _all
 
+# // App WMS ------------
+app_wms.so: $(OBJS)
+	@$(CC) $(SOLINK) -o $@ $(OBJS)
+	@echo "   [LD] $@"
+# // END ----------------
+
 include $(ASTTOPDIR)/Makefile.moddir_rules
 
 clean::
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/apps/vsrvdefs.h asterisk-11.3.0.p000/apps/vsrvdefs.h
--- asterisk-base-11.3.0/apps/vsrvdefs.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-11.3.0.p000/apps/vsrvdefs.h	2013-05-13 14:00:47.696438013 +0100
@@ -0,0 +1,533 @@
+/*******************************************************************************
+* Copyright (C) 2003, PTInovação SA.
+*
+* $Module       : vsrvdefs.h $
+* $Description  : Header file with main type definitions and channel information
+*                 for InoVox module. $
+* $Created      : 1998 - Version 1 started $
+* $Comments     : $
+*
+* $Author: lreis $
+* $Revision: 1.4 $
+* $Date: 2005/09/29 14:21:05 $
+* $Source: /home/cvs/DesenVox/InoDev_v3/InoVoxIP/inc/vsrvdefs.h,v $
+*
+* 64 bits
+* Data model   |short|int|long|long long|pointers/size_t|Sample operating systems 
+* LLP64/IL32P64|16   | 32|  32|       64|             64|Microsoft Windows (X64/IA-64) 
+* LP64/I32LP64 |16   | 32|  64|       64|             64|Most Unix and Unix-like systems, e.g. Solaris, Linux, and Mac OS X 
+*
+* Joaquim Azevedo
+* Copyright (c) 2003 PT Inovação SA. All Rights Reserved
+********************************************************************************
+*/
+
+#ifndef _VSRVDEFS_H
+#define _VSRVDEFS_H
+
+#include <time.h>
+
+/*******************************************************************************
+ *
+ * TYPE DEFINITIONS
+ *
+ ******************************************************************************/
+/* Termination conditions definitions */
+#define PERIOD                   1
+
+#define	DIGIT_LENGTH			   128		//GC_ADDRSIZE    // 128
+#define MAX_CALLID_LEN           64
+#define URLSTRINGSIZE            256
+#define NUM_ACCEPTED_CODECS      20
+#define MAXTERMCOND              10  // maximum number of non ASR termination conditions
+
+#ifndef FALSE				            // Standard definition for FALSE
+#define FALSE					      0
+#endif
+
+#ifndef TRUE				            // Standard definition for TRUE
+#define TRUE					      1
+#endif
+
+#ifndef ACCEPT
+#define ACCEPT						   1
+#endif
+
+/* Conference_event */
+#define USER_EXITED_CONFERENCE   0
+
+/* Digit Streaming Definitions */
+#define STREAM_IGNORE      -1
+#define STREAM_STOP        0
+#define STREAM_START       1
+#define STREAM_LOAD        2
+#define STREAM_UNLOAD      3
+
+#define OFFSET_END      -1
+#define OFFSET_BEGIN    0	/* Default value */
+
+/*
+ * Masked DTMF termination/initiation equates
+ */
+#define  DM_D        0x0001    /* Mask for DTMF d. */
+#define  DM_1        0x0002    /* Mask for DTMF 1. */
+#define  DM_2        0x0004    /* Mask for DTMF 2. */
+#define  DM_3        0x0008    /* Mask for DTMF 3. */
+#define  DM_4        0x0010    /* Mask for DTMF 4. */
+#define  DM_5        0x0020    /* Mask for DTMF 5. */
+#define  DM_6        0x0040    /* Mask for DTMF 6. */
+#define  DM_7        0x0080    /* Mask for DTMF 7. */
+#define  DM_8        0x0100    /* Mask for DTMF 8. */
+#define  DM_9        0x0200    /* Mask for DTMF 9. */
+#define  DM_0        0x0400    /* Mask for DTMF 0. */
+#define  DM_S        0x0800    /* Mask for DTMF *. */
+#define  DM_P        0x1000    /* Mask for DTMF #. */
+#define  DM_A        0x2000    /* Mask for DTMF a. */
+#define  DM_B        0x4000    /* Mask for DTMF b. */
+#define  DM_C        0x8000    /* Mask for DTMF c. */
+
+typedef int				period;
+typedef unsigned int	endpoint_id;
+typedef unsigned int	bit;
+typedef char            digits[DIGIT_LENGTH];
+typedef char			   ani[DIGIT_LENGTH];
+typedef char			   dnis[DIGIT_LENGTH];
+typedef char            loc_t[DIGIT_LENGTH];
+
+
+
+/* Errors returned in the reply data structure */
+typedef enum error_value
+{
+   NO_ENDPOINTS_AVAILABLE			      = 100,
+	ENDPOINT_NOT_KNOWN				      = 101,
+	INVALID_VOICE_FILE_PARAMETER	      = 102,
+	RESOURCE_ERROR					         = 103,
+	NO_CAPABILITIES_AVAILABLE		      = 104,
+	DEVICE_NOT_BUSY					      = 105,
+	STOP_OPERATION_FAILED			      = 106,
+   INVALID_HOOK_STATE                  = 107,
+   ASR_RESOURCE_ERROR                  = 108,
+   INVALID_MASK                        = 109,
+   TASKFAIL_ERROR                      = 110,
+	TTS_RESOURCE_ERROR				      = 111,
+   NO_ASR_CAPABILITIES_AVAILABLE	      = 112,
+   NO_TTS_CAPABILITIES_AVAILABLE	      = 113,
+   NO_FAX_CAPABILITIES_AVAILABLE	      = 114,
+   ENDPOINT_TRANSFER_TIMEOUT           = 115,
+   ENDPOINT_TRANSFER_INVALID_SERVICE   = 116,
+   ENDPOINT_OUT_OF_RANGE               = 117,
+   FUNCTION_NOT_SUPPORTED              = 118,
+   READ_ONLY_FILE                      = 119,
+   SV_RESOURCE_ERROR                   = 120,
+   SERVER_CONNECTION_REFUSED           = 121,
+   FILE_NOT_FOUND                      = 122,
+   ARGUMENTS_OUT_OF_RANGE              = 123,
+} error_value;
+
+/* Event types which can be returned in a reply data structure */
+typedef enum event
+{ 
+   INVALID_EVENT                    = -1,
+	CLAIM_ENDPOINT_COMPLETED			= 0,
+	RELEASE_ENDPOINT_COMPLETED			= 1,
+	GET_DIRECTORY_NUMBER_COMPLETED	= 2,
+	PLAY_ANNOUNCEMENT_COMPLETED		= 3,
+	RECORD_VOICE_COMPLETED				= 4,
+	GET_DIGITS_COMPLETED					= 5,
+	SET_ICALL_MASK_COMPLETED			= 6,
+	ACCEPT_ICALL_COMPLETED				= 7,
+	CLEAR_DIGIT_BUFFER_COMPLETED		= 8,
+	PLAY_DIGITS_COMPLETED				= 9,
+	LOOP_CURRENT_EVENT					= 10,
+	GET_ENDPOINT_INFO_COMPLETED		= 11,
+	STOP_OPERATION_COMPLETED			= 12,
+	GET_HOOK_STATE_COMPLETED			= 13,
+	SET_HOOK_STATE_COMPLETED			= 14,
+	RINGING_EVENT							= 15, // not used, just for compatibility
+	GET_ASR_WORD_COMPLETED				= 16,	// not used, just for compatibility
+	INCOMING_CALL_EVENT					= 17,
+	MAKE_CALL_COMPLETED					= 18,
+	ROUTE_ENDPOINT_COMPLETED			= 19,
+	RESET_ENDPOINT_COMPLETED			= 20,
+	ADJUST_ANNOUNCEMENT_COMPLETED		= 21,
+	GET_ENDPOINT_STATUS_COMPLETED		= 22,
+	ATTACH_CAPABILITIES_COMPLETED		= 23,
+	PLAY_DATA_COMPLETED					= 24,
+	PLAY_INDEX_FILE_COMPLETED        = 25,
+	DETACH_CAPABILITIES_COMPLETED		= 26, // not used, just for compatibility
+	PING_CONNECTION_COMPLETED			= 27,
+	TRANSFERED_CALL_EVENT				= 28, // not used, just for compatibility
+	TRANSFER_ENDPOINT_COMPLETED		= 29,
+	ASR_CONFIG_RESOURCE_COMPLETED		= 30,
+	ASR_START_RECOG_COMPLETED			= 31,
+	TTS_CONFIG_RESOURCE_COMPLETED		= 32,
+	TTS_PROCESS_COMPLETED				= 33,
+	CONNECT_CALL_COMPLETED				= 34,
+   UNSOLICITED_EVENT					   = 35,
+   SEND_FAX_COMPLETED					= 36,
+   RECEIVE_FAX_COMPLETED				= 37,
+   SUSPEND_RESUME_COMPLETED			= 38,
+   FSK_TXRX_MSG_COMPLETED				= 39,
+   RELEASE_ICALL_MASK_COMPLETED     = 40,   
+   ASR_LOAD_GRAMMAR_COMPLETED       = 41,
+   ASR_UNLOAD_GRAMMAR_COMPLETED     = 42,
+   ASR_ACTIVATE_GRAMMAR_COMPLETED   = 43,
+   ASR_DEACTIVATE_GRAMMAR_COMPLETED = 44,
+   ASR_ACTIVATE_RULE_COMPLETED      = 45,
+   ASR_DEACTIVATE_RULE_COMPLETED    = 46,   
+   FILE_OPERATION_COMPLETED         = 47,
+   PLAY_COMPOSE_COMPLETED           = 48,
+   RUN_SCRIPT_COMPLETED             = 49,
+   CONFERENCE_MANAGER_COMPLETED     = 50,
+   SPEAKER_VERIFICATION_COMPLETED   = 51,
+   EXEC_ASTERISK_COMPLETED          = 52,
+   START_RECOGNITION_COMPLETED      = 53,
+   ASR_MRCP_LOG_COMPLETED           = 54,
+   ASR_SET_PARAM_COMPLETED          = 55,
+   TOTAL_NUMBER_EVENTS
+}event;
+
+/* Event types which can be associated to UNSOLICITED_EVENT */
+typedef enum event_type
+{
+   USR_DEF_TONE_DETECTED            = 200,
+	CALL_RETURN_KEY_DETECTED	      = 201,
+	DIGIT_DETECTED                   = 202,
+   ASR_RECOG_RESULTS                = 203,
+	SUSPEND_DETECTED                 = 204,
+	RESUME_DETECTED                  = 205,
+	RM_EVENT                         = 206, 
+   CALL_PROGRESS_DETECTED           = 207,
+   START_OF_SPEECH                  = 208,
+   RECOG_IN_PROGRESS                = 209,
+   ASTERISK_MANAGER_EVENT           = 210,  
+   RECOGNITION_RESULTS              = 211,
+   RINGING                          = 212,
+   CONFERENCE_EVENT                 = 213,
+   SIP_INFO                         = 214,
+   FAX_PAGE_DETECTED                = 215,
+	TOTAL_NUMBER_EVENT_TYPES
+}event_type;
+
+/* SRMA ports for SDP */
+typedef struct
+{
+   char rtpa_ip[20];
+   unsigned short rtpa_port;
+   char rtpv_ip[20];
+   unsigned short rtpv_port;
+}SMRA_ATTRIB;
+
+/* Route Endpoint parameters */
+typedef struct
+{
+   int ret_key_active;
+   char ret_key[2];
+   int trans_rec_active;
+   char trans_rec_fname[256];
+} ROUEND_PARAM;
+
+/* Termination conditions */
+typedef struct
+{
+   int maxtime;               // maximum function time in secs. (*100ms) -> x*10
+   int maxdtmf;               // maximum DTMF digits received
+   int firstdigittime;        // maximum length of silence in secs. (*100ms) -> x*10
+   int iddtime;               // maximum delay between digits in secs. (*100ms) -> x*10
+   int digmask;               // specific digit received
+   int minlength;             // minimum length of string to recognize
+   int maxlength;             // maximum length of string to recognize
+   int ntermcond;             // number of non ASR termination conditions
+   int finalpausetimeout;     // Amount of silence to stop recognition after speech detection
+   int initialpausetimeout;   // Amount of silence to stop recognition before speech detection
+   int cond_id[MAXTERMCOND];  // termination conditions id number
+}termination_cond;
+
+/* ASR/DTMF Resource Attributes */
+typedef struct
+{
+   unsigned int start_sd;               // Start speech detection timeout
+   unsigned int record_dur;             // Record duration
+   unsigned int end_sp;                 // End speech detection timeout
+   char lrname[128];             // Language resource name
+   char fname[128];              // Filename to store audio input
+   unsigned int rtype;                  // Recognition type
+   unsigned int nbest;                  // Nbest
+   unsigned int dtmf_interdigit_timeout;// DTMF interdigit timeout
+   unsigned int dtmf_term_timeout;      // DTMF term timeout
+   char dtmf_term_char;          // DTMF terminator char
+   unsigned int bargein;                // Bargein flag
+   unsigned short rtp_port;
+   unsigned short rtcp_port;
+   char server_ip[50];
+}ASR_RES_ATTRIB;
+
+/* Terminator data structure */
+typedef struct
+{
+   bit period	: 1;
+	bit number_of_digits : 1;
+	bit asr_silence_detected : 1;
+	bit first_digit_period : 1;
+	bit inter_digit_period : 1;
+	bit specific_digit_received : 1;
+	bit end_of_data : 1;
+	bit stopped : 1;
+	bit speech_digits_received : 1;
+	bit asr_word_received : 1;
+	bit io_error : 1;
+	bit line_busy : 1;
+	bit call_connected : 1;
+	bit faxtone_detected : 1;
+	bit no_answer : 1;
+	bit no_dial_tone : 1;
+	bit no_ring : 1;
+	bit operator_intercept : 1;
+	bit call_error : 1;
+	bit loop_current_off : 1;
+   bit cadence_break : 1;
+   bit positive_voice_detection : 1;
+   bit pos_answ_machine_detection : 1;
+   bit timer_expiry : 1;
+   bit temporary_failure : 1;
+   bit no_circuit_available : 1;
+   bit network_congestion : 1;
+   bit unassigned_number : 1;
+   bit no_route : 1;
+   bit channel_unacceptable : 1;
+   bit no_user_responding : 1;
+   bit number_changed : 1;
+   bit dest_out_of_order : 1;
+   bit invalid_number_format : 1;
+   bit facility_rejected : 1;
+   bit resp_to_stat_enq : 1;
+   bit unspecified_cause : 1;
+   bit network_out_of_order : 1;
+   bit access_info_discarded : 1;
+   bit req_channel_not_avail : 1;
+   bit pre_empted : 1;
+   bit facility_not_subscribed : 1;
+   bit outgoing_call_barred : 1;
+   bit incoming_call_barred : 1;
+   bit bear_cap_not_avail : 1;
+   bit service_not_avail : 1;
+   bit cap_not_implemented : 1;
+   bit chan_not_implemented : 1;
+   bit facility_not_implement : 1;
+   bit invalid_call_ref : 1;
+   bit chan_does_not_exist : 1;
+   bit incompatible_dest : 1;
+   bit invalid_msg_unspec : 1;
+   bit mandatory_ie_missing : 1;
+   bit nonexistent_msg : 1;
+   bit wrong_message : 1;
+   bit bad_info_elem : 1;
+   bit invalid_elem_contents : 1;
+   bit wrong_msg_for_state : 1;
+   bit mandatory_ie_len_err : 1;
+   bit protocol_error : 1;
+   bit interworking_unspec : 1;
+   bit call_rejected : 1;
+   bit send_sit : 1;
+   bit no_route_to_destination : 1;
+   bit misdialled_trunk_prefix : 1;
+   bit ported_number : 1;
+   bit asr_max_speech_received : 1;
+	bit digit_streaming_started : 1;
+	bit digit_streaming_stopped : 1;
+	bit null_synthesis : 1;
+	bit asr_no_match : 1;
+	bit asr_recognition_timeout : 1;
+	bit asr_speech_too_early : 1;
+	bit asr_uri_failure : 1;
+	bit asr_language_unsupported : 1;
+   bit subscriber_absent : 1;
+ 	bit digit_streaming_loaded : 1;
+	bit digit_streaming_unloaded : 1;
+   bit resource_unavailable : 1;
+} terminator;
+
+// Codec structures to pass to inovox
+typedef struct
+{
+   int 	      payload;
+   long long  type;
+   char  fmtp[128];
+   char  rtpmap[64];
+} sdp_format;
+
+typedef struct
+{
+   sdp_format codec[NUM_ACCEPTED_CODECS];
+   unsigned int bandwidth;
+   int num;
+} sdp_codec;
+
+typedef struct
+{
+   sdp_codec media[2];
+   unsigned int bandwidth;
+   unsigned int framerate;
+   unsigned int dtmfpayload;
+} sdp_media;
+
+/* Digit result data structure */
+typedef struct
+{
+   digits digits;
+	unsigned int confidence;
+   unsigned int crypt;
+} digit_result;
+
+/* Incoming call event data structure */
+typedef struct
+{
+   ani      ic_ani;
+   dnis     ic_dnis;
+   digits   redirecting_num;
+   int      redirection_cause;
+   int      ani_pre_indicator;
+   period   timeout;
+   int      transfer_endpnt;
+   int      ic_terminal;
+   int      ic_nature;
+   int      rdg_pre_indicator;
+   loc_t    ic_location;
+   int      ic_userinfo;
+   int      ic_restype;
+   char     ic_extradata[2048];
+   dnis     ic_to;
+   char     ic_callid[MAX_CALLID_LEN];
+}ic_event_t;
+
+/* Outbound call data structure */
+typedef struct
+{
+   digits      redirection_num;     /* number to which the call was redirected */
+   int         redirecting_cause;   /* redirecting cause */
+   int         rdn_pre_indicator;   /* redirection number presentation indicator */      
+   int         sig_cause;           /* signalling cause of the operation */
+   ani         mc_ani;              /* calling party number set on make_call */
+   dnis        mc_dnis;             /* called party number of make_call */
+   int         mk_terminal;
+}mk_info_t;
+
+/* Command acronyms related to the API functions*/
+typedef enum CMD
+{
+   CLAEND = 0,
+   RELEND = 1,
+   GETDIN = 2,
+   SETHST = 3,
+   PLAANN = 4,
+   GETDIG = 5,
+   CLEDIB = 6,
+   RECVOI = 7,
+   STOPER = 8,
+   ROUEND = 9,
+   RESEND = 10,
+   ACCICA = 11,
+   MAKCAL = 12,
+   SETICM = 13,
+   RELCON = 14,
+   ADJANN = 15,
+   GETEST = 16,
+   GETEIN = 17,
+   GETHST = 18,
+   PLADIG = 19,
+   ATTCAP = 20,
+   PLADAT = 21,
+   PLAIND = 22,
+   TRFEDP = 23,
+	ACFRES = 24,
+   ASTREC = 25,
+   TCFRES = 26,
+   TTSPRO = 27,
+   CONCAL = 28,
+   SNDFAX = 29,
+   RCVFAX = 30,
+   SUSRES = 31,
+   FSKMSG = 32,
+   LODGRM = 33,
+   ULDGRM = 34,
+   ACTGRM = 35,
+   DECGRM = 36,
+   ACTRUL = 37,
+   DECRUL = 38,
+   PLYCOM = 39,
+   RUNSCR = 40,
+   IVRSTA = 41,
+   RECVOX = 42,
+   GETDIX = 43,
+   FILOPE = 44,
+   REJICA = 45,
+   PING   = 46,
+   CNFMGR = 47,
+   SPKVER = 48,
+   EXEAST = 49,
+   STARTR = 50,
+   ASRLOG = 51,
+   SETPAR = 52,
+	TOTAL_NUMBER_CMDS
+}cmd;
+
+typedef struct
+{
+   unsigned int con_id;         // connection id
+   unsigned int cmd_cnt;        // command count
+   unsigned int cmd_id;         // command id
+   endpoint_id edp_id;           // endpoint id
+   int clear_dig_buf;            // clear digit buffer before dx_play
+   termination_cond term_cond;   // termination conditions
+   unsigned int ch_index;            // channel index of incoming call
+   digits dial_number;           // ASCII dial string
+   int dtmf;                     // Enable DTMF detection of this endpoint (TRUE/FALSE)
+   int asr;                      // Associate ASR resources to the specified endpoint                                 // 0 = NONE, 1 = C_TROUGH, 2 = NO_C_TROUGH
+   ASR_RES_ATTRIB asr_rattrib;	 // ASR Resource Attributes
+   ROUEND_PARAM rouend_param;    // Route Endpoint parameters
+   int al_int_val1;              // arg_list int value 1
+   int al_int_val2;              // arg_list int value 2
+   long long al_long_val1;        // arg_list long int value 1
+   void *in_ast_chan;
+   char al_char_val1[256];       // arg_list char value 1
+   char al_char_val2[256];       // arg_list char value 2
+   char prompt_id[256];          // prompt id
+   char use_smra;
+   SMRA_ATTRIB       smra_attrib;      // SMRA Attributes
+   sdp_media sdp;
+} cmd_ast;
+
+
+/* Reply data structure */
+typedef struct
+{
+   unsigned int con_id;                  // connection id
+   unsigned int cmd_cnt;                 // command count
+   endpoint_id	sender;
+	event event;
+	unsigned char error;
+   event_type evt_type;                   // Unsolicited Event type
+   void *in_ast_chan;
+   int chan_id;                           // InoVox Channel ID
+   char use_smra;
+	struct
+	{
+	   endpoint_id			endpoint_id;
+		terminator			terminator;
+		digit_result		digit_result;
+		error_value			error_value;
+		ic_event_t		   ic_event;
+      int               g_ret_value;      // generic return value        
+      mk_info_t         mk_info;          // outbound call information
+      char              userData[URLSTRINGSIZE];  // uniqueid for IC, ASTERISK_EVENTS data
+	   char				   urlParams[URLSTRINGSIZE]; // ;<URL end parameters>
+      char              channelId[32];
+      SMRA_ATTRIB       smra_attrib;      // SMRA Attributes
+      sdp_media sdp;
+   } body;
+} reply_ast;
+// - LR - WARNING - LOOK OUT FOR SIZEOF(reply_ast) ...
+
+
+#endif
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/apps/wms_aux.c asterisk-11.3.0.p000/apps/wms_aux.c
--- asterisk-base-11.3.0/apps/wms_aux.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-11.3.0.p000/apps/wms_aux.c	2013-05-13 14:00:47.684437741 +0100
@@ -0,0 +1,737 @@
+/*******************************************************************************
+ *        FILE: asterisk_run.c
+ * DESCRIPTION: 
+ *              
+ * 
+ * $Archive: $
+ * $Revision: 1.0 $
+ * $Author: $
+ * $History: $
+ * 
+ * Luis Reis
+ * Copyright (c) 2006 PT Inovação SA. All Rights Reserved
+ ******************************************************************************/
+
+ /*******************************************************************************
+ *
+ * SYSTEM HEADER FILES
+ *
+ ******************************************************************************/
+#include <stdio.h>
+#include "asterisk.h"
+#include <asterisk/lock.h>
+#include <asterisk/file.h>
+#include <asterisk/logger.h>
+#include <asterisk/channel.h>
+#include <asterisk/pbx.h>
+#include <asterisk/module.h>
+#include <asterisk/translate.h>
+#include <asterisk/chanvars.h>
+#include <asterisk/causes.h>
+#include <asterisk/options.h>
+#include <asterisk/manager.h>
+#include <string.h>
+
+/*******************************************************************************
+ *
+ * APPLICATION HEADER FILES
+ *
+ ******************************************************************************/
+#include "vsrvdefs.h"
+#include "app_wms.h"
+#include "wms_inoapi.h"
+#include "wms_aux.h"
+
+#define MAX_TIMESTAMP_SKEW	640
+#define TYPE_HIGH	      0x0
+#define TYPE_LOW	      0x1
+#define TYPE_SILENCE	   0x2
+#define TYPE_DONTSEND	0x3
+#define TYPE_MASK	      0x3
+#define RTSP_RTP_TIMEOUT 1
+
+/*******************************************************************************
+ *
+ * FUNCTIONS PROTOTYPES
+ *
+ ******************************************************************************/
+static int check_termination_digit(int, char);
+static int local_g723_len(unsigned char);
+static int local_g723_samples(unsigned char *, int);
+
+/*******************************************************************************
+ *
+ * FUNCTIONS
+ *
+ ******************************************************************************/
+//- AUX FUNCTIONS ------------------------------------------------------------------------
+
+/******************************************************************************
+ *        NAME: build_terminator()
+ * DESCRIPTION: Creates the terminations reasons on chan_vars->action
+ *              
+ *****************************************************************************/
+void build_terminator(struct ast_channel *chan, ast_vars *chan_vars, cmd_ast trs_cmd)
+{
+   chan_vars->action.term_cond = trs_cmd.term_cond;
+
+   //Check if digit buffer already has digits
+   check_digit_terminators(chan, chan_vars);
+}
+
+/******************************************************************************
+ *        NAME: check_timeout_terminators()
+ * DESCRIPTION: Check if action has reached a timeout termination cenario (from active terminations)
+ *        NOTE: Only check timer related terminations, nr of digit or specific digits 
+ *             are checked only when a digit arrives for optimization purposes
+ *****************************************************************************/
+void check_timeout_terminators(struct ast_channel *chan, ast_vars *chan_vars)
+{
+   if (chan_vars->action.type == NO_ACTION) return;
+   if (!chan_vars->action.term_cond.ntermcond) return;
+   
+   gettimeofday(&(chan_vars->action.cmd_end), NULL);
+
+	if ((chan_vars->action.cmd_end.tv_sec - chan_vars->action.cmd_start.tv_sec) >= chan_vars->action.term_cond.maxtime)
+	{
+		build_reply(chan_vars);
+		chan_vars->trs_reply.body.terminator.period = 1;
+		stop_action(chan, chan_vars);
+	}
+	else if (chan_vars->digit_buffer[0] == '\0' && (chan_vars->action.term_cond.firstdigittime > 0) &&
+		(chan_vars->action.cmd_end.tv_sec - chan_vars->action.cmd_start.tv_sec >= chan_vars->action.term_cond.firstdigittime))
+	{
+		build_reply(chan_vars);
+		chan_vars->trs_reply.body.terminator.first_digit_period = 1;
+		stop_action(chan, chan_vars);
+	}
+   else if (chan_vars->action.term_cond.iddtime > 0 && chan_vars->digit_buffer[0] != '\0' &&
+   (chan_vars->action.cmd_end.tv_sec - chan_vars->action.cmd_last.tv_sec >= chan_vars->action.term_cond.iddtime))
+	{
+		build_reply(chan_vars);
+		chan_vars->trs_reply.body.terminator.inter_digit_period = 1;
+		stop_action(chan, chan_vars);
+	}
+   //--- ACTION_PLAANN ------------------------------------------------------------------------------
+   if (chan_vars->action.type == ACTION_PLAANN)
+   {
+      if (chan_vars->action.cs[0] != NULL)
+	   {  
+		   if (chan_vars->action.rtsp_play_duration > 0 && ((chan_vars->action.cmd_end.tv_sec - chan_vars->action.cmd_start.tv_sec) > chan_vars->action.rtsp_play_duration) &&
+			   ((chan_vars->action.cmd_end.tv_sec - chan_vars->action.cmd_last.tv_sec) > RTSP_RTP_TIMEOUT))
+		   {
+			   build_reply(chan_vars);
+			   chan_vars->trs_reply.body.terminator.end_of_data = 1;
+			   stop_action(chan, chan_vars);
+		   }
+	   }
+   }
+}
+
+/******************************************************************************
+ *        NAME: check_digit_terminators()
+ * DESCRIPTION: Check number of digits and specific digit terminations
+ *
+ *****************************************************************************/
+void check_digit_terminators(struct ast_channel *chan, ast_vars *chan_vars)
+{
+   int len = 0;
+
+   if ((len = strlen(chan_vars->digit_buffer)))
+   {
+      if (chan_vars->action.term_cond.maxdtmf && (len >= chan_vars->action.term_cond.maxdtmf))
+      {
+         build_reply(chan_vars);
+         chan_vars->trs_reply.body.terminator.number_of_digits = 1;
+         stop_action(chan, chan_vars);
+      }
+      if (chan_vars->action.term_cond.digmask != 0)
+      {
+         if (check_termination_digit(chan_vars->action.term_cond.digmask, chan_vars->digit_buffer[len - 1]))
+         {
+            build_reply(chan_vars);
+            chan_vars->trs_reply.body.terminator.specific_digit_received = 1;
+            stop_action(chan, chan_vars);
+         }
+      }
+   }
+}
+
+/******************************************************************************
+ *        NAME: check_termination_digit()
+ * DESCRIPTION: Transform digit mask into digit string
+ *              
+ *****************************************************************************/
+static int check_termination_digit(int spec_digit_mask, char digit)
+{
+   unsigned maskforDTMF[]={DM_0, DM_1, DM_2,
+                           DM_3, DM_4, DM_5,
+                           DM_6, DM_7, DM_8,
+                           DM_9, DM_S, DM_P,
+                           DM_A, DM_B, DM_C,
+                           DM_D};
+   unsigned DTMFSTAR  = 10;     // Index for "*" in maskforDTMF
+   unsigned DTMFHASH  = 11;     // Index for "#" in maskforDTMF
+   unsigned DTMFA = 12;     // Index for "A" in maskforDTMF
+   unsigned DTMFB = 13;     // Index for "B" in maskforDTMF
+   unsigned DTMFC = 14;     // Index for "C" in maskforDTMF
+   unsigned DTMFD = 15;     // Index for "D" in maskforDTMF
+
+   if (digit >= 48 && digit <= 57 && (spec_digit_mask & maskforDTMF[digit-48])) return 1;
+   else if (digit == '*' && (spec_digit_mask & maskforDTMF[DTMFSTAR])) return 1;
+   else if (digit == '#' && (spec_digit_mask & maskforDTMF[DTMFHASH])) return 1;
+   else if (digit == 'A' && (spec_digit_mask & maskforDTMF[DTMFA])) return 1;
+   else if (digit == 'B' && (spec_digit_mask & maskforDTMF[DTMFB])) return 1;
+   else if (digit == 'C' && (spec_digit_mask & maskforDTMF[DTMFC])) return 1;
+   else if (digit == 'D' && (spec_digit_mask & maskforDTMF[DTMFD])) return 1;
+   return 0;
+}
+
+/******************************************************************************
+ *        NAME: process_digit()
+ * DESCRIPTION: Process received digits
+ *              
+ *****************************************************************************/
+void process_digit(struct ast_channel *chan, ast_vars *chan_vars, int digit)
+{
+   char temp[] = { '\0', '\0' };
+ 	reply_ast trs_reply;
+   int len = 0;
+
+   if (digit < 0) return;
+   if (chan_vars->dtmf == 0) return;
+
+   temp[0] = digit;
+	if (chan_vars->action.type != NO_ACTION) gettimeofday(&chan_vars->action.cmd_last, NULL);
+
+   if (!chan_vars->stream.enabled)
+   {
+   ast_mutex_lock(&digmux_lock);
+
+      if (option_verbose >= 3)
+         ast_verbose(VERBOSE_PREFIX_3 "DTMF '%c' -> [%s] on channel %s\n", digit, chan_vars->digit_buffer, ast_channel_name(chan));
+
+      // chan_vars->digit_buffer = DIGIT_LENGHT
+      // termination.digits[0] = \"
+      // termination.digits[1..n-2] = <digits>
+      // termination.digits[n-1] = \"
+      // termination.digits[n] = '\0'
+      // So DIGIT_LENGTH - 3
+      if ((len = strlen(chan_vars->digit_buffer)) < DIGIT_LENGTH - 3)
+      strcat(chan_vars->digit_buffer, temp); //current size + 1 to use down in comparison
+      else ast_log(LOG_WARNING, "Digit buffer overflow on channel %s!\n", ast_channel_name(chan));
+
+   ast_mutex_unlock(&digmux_lock);
+   }
+   else
+	{
+      if (option_verbose >= 3)
+         ast_verbose(VERBOSE_PREFIX_3 "DTMF '%c' on channel %s\n", digit, ast_channel_name(chan));
+
+      memset(&trs_reply, 0, sizeof(trs_reply));
+      trs_reply.cmd_cnt = chan_vars->stream.cmd_cnt;
+	   trs_reply.con_id = chan_vars->stream.con_id;
+	   trs_reply.sender = chan_vars->stream.edp_id;
+      trs_reply.error = FALSE;
+		trs_reply.event = UNSOLICITED_EVENT;
+		trs_reply.evt_type = DIGIT_DETECTED;
+		sprintf(trs_reply.body.digit_result.digits, "\"%c\"", digit);
+		asteriskSendReply(&trs_reply, chan_vars);
+	}
+   //Check number of digits and specific digit terminations
+   check_digit_terminators(chan, chan_vars);
+}
+
+/******************************************************************************
+ *        NAME: build_action()
+ * DESCRIPTION: Build action
+ *              
+ *****************************************************************************/
+void build_action(ast_vars *chan_vars, cmd_ast *trs_cmd, int actype, int cmdevent)
+{
+   //_DebugSay(VOICE, INFO, 5, 0, "[ASTERISK] build_action() called");
+
+   memset(&chan_vars->action, 0, sizeof(chan_vars->action));
+   chan_vars->action.type = actype;
+	chan_vars->action.con_id = trs_cmd->con_id;
+	chan_vars->action.cmd_cnt = trs_cmd->cmd_cnt;
+	chan_vars->action.cmd_id = trs_cmd->cmd_id;
+	chan_vars->action.edp_id = trs_cmd->edp_id;
+	chan_vars->action.cmd_event = cmdevent;
+	gettimeofday(&chan_vars->action.cmd_start, NULL);
+   gettimeofday(&chan_vars->action.cmd_last, NULL);
+}
+
+/******************************************************************************
+ *        NAME: stop_action()
+ * DESCRIPTION: Stop action
+ *              
+ *****************************************************************************/
+void stop_action(struct ast_channel *chan, ast_vars *chan_vars)
+{
+   if (chan_vars->conference.id) ast_set_flag(ast_channel_inoflags(chan), EXEC_APP_EXIT);
+   if (chan_vars->action.type == NO_ACTION) return;
+
+//--- ACTION_GETDIG ------------------------------------------------------------------------------
+	if (chan_vars->action.type == ACTION_GETDIG)
+	{
+      int num_digits;
+
+		if (!chan_vars->shutdown)
+		{
+         ast_mutex_lock(&digmux_lock);
+			if (chan_vars->trs_reply.body.terminator.number_of_digits)
+			{
+				if( chan_vars->action.term_cond.maxdtmf &&
+					(strlen(chan_vars->digit_buffer) > chan_vars->action.term_cond.maxdtmf))
+				{
+					num_digits = chan_vars->action.term_cond.maxdtmf;
+				}
+				else num_digits = strlen(chan_vars->digit_buffer);
+			}
+			else num_digits = strlen(chan_vars->digit_buffer);
+
+         // Check if num_digits > buffer - 3 for \"\"\0
+         if (num_digits > sizeof(chan_vars->trs_reply.body.digit_result.digits) - 3)
+            num_digits = sizeof(chan_vars->trs_reply.body.digit_result.digits) - 3;
+
+			chan_vars->trs_reply.body.digit_result.digits[0] = '"';
+
+         strncpy(chan_vars->trs_reply.body.digit_result.digits + 1, chan_vars->digit_buffer, num_digits);
+			chan_vars->trs_reply.body.digit_result.digits[num_digits+1] = '"';
+			chan_vars->trs_reply.body.digit_result.digits[num_digits+2] = '\0';
+
+         // Get num_digits from buffer and delete them leaving the rest on the beggining
+         if (num_digits < strlen(chan_vars->digit_buffer))
+         {
+            memmove(chan_vars->digit_buffer, chan_vars->digit_buffer + num_digits, 
+               strlen(chan_vars->digit_buffer) - num_digits);
+            chan_vars->digit_buffer[strlen(chan_vars->digit_buffer) - num_digits] = '\0';
+         }
+         else chan_vars->digit_buffer[0] = '\0';//memset(chan_vars->digit_buffer, 0, sizeof(chan_vars->digit_buffer));
+
+         ast_mutex_unlock(&digmux_lock);
+
+         chan_vars->trs_reply.body.digit_result.confidence = 100;
+         if (chan_vars->trs_reply.body.terminator.stopped == 0)
+   			asteriskSendReply(&chan_vars->trs_reply, chan_vars);
+		}
+		memset(&chan_vars->action, 0, sizeof(chan_vars->action));
+   }
+//--- ACTION_RECVOI ------------------------------------------------------------------------------
+   else if (chan_vars->action.type == ACTION_RECVOI)
+	{
+	   if (chan_vars->action.cs[0] == NULL)
+	   {
+         if (chan_vars->action.record != NULL) ast_closestream(chan_vars->action.record);
+         if (chan_vars->action.fp != NULL) fclose(chan_vars->action.fp);
+
+         if (!chan_vars->shutdown && !chan_vars->trs_reply.body.terminator.stopped)
+   			asteriskSendReply(&chan_vars->trs_reply, chan_vars);
+
+         memset(&chan_vars->action, 0, sizeof(chan_vars->action));
+		}
+      else
+      {
+         // Being done ???
+#ifdef _DSAYMODE
+			_DebugSay(VOICE, INFO, 5, 0, "[ASTERISK] Record_voice completed on channel %s", ast_channel_name(chan));
+#endif
+//         if (option_verbose >= 3)
+//            ast_verbose(VERBOSE_PREFIX_3 "Record_voice completed on channel %s\n", ast_channel_name(chan));
+			
+			if (!chan_vars->shutdown && !chan_vars->trs_reply.body.terminator.stopped)
+					asteriskSendReply(&chan_vars->trs_reply, chan_vars);
+
+         if (chan == chan_vars->action.cs[0])
+			{
+				ast_channel_setoption(chan_vars->action.cs[1], 3, chan_vars->action.FILE_URL, 1, 0);
+				ast_hangup(chan_vars->action.cs[1]);
+			}
+			else
+			{
+				ast_channel_setoption(chan_vars->action.cs[0], 3, chan_vars->action.FILE_URL, 1, 0);
+				ast_hangup(chan_vars->action.cs[0]);
+			}
+			memset(&chan_vars->action, 0, sizeof(chan_vars->action));
+      }
+   }
+//--- ACTION_PLAANN ------------------------------------------------------------------------------
+   else if (chan_vars->action.type == ACTION_PLAANN)
+   {
+      if (chan_vars->action.cs[0] == NULL)
+	   {
+         memset(&chan_vars->ivx, 0, sizeof(chan_vars->ivx));
+			if (chan_vars->action.fp == NULL) ast_stopstream(chan);
+         else fclose(chan_vars->action.fp);
+
+#ifdef _DSAYMODE
+			_DebugSay(VOICE, INFO, 5, 0, "[ASTERISK] play_announcement completed on channel %s", ast_channel_name(chan));
+#endif
+//         if (option_verbose >= 3)
+//            ast_verbose(VERBOSE_PREFIX_3 "End of play_announcement on channel %s\n", ast_channel_name(chan));
+			if (!chan_vars->shutdown && !chan_vars->trs_reply.body.terminator.stopped)
+         {
+            strcpy(chan_vars->trs_reply.body.userData, chan_vars->action.FILE_URL);
+				asteriskSendReply(&chan_vars->trs_reply, chan_vars);
+         }
+			memset(&chan_vars->action, 0, sizeof(chan_vars->action));
+      }
+      else
+      {
+			if (!chan_vars->shutdown && !chan_vars->trs_reply.body.terminator.stopped)
+   		   asteriskSendReply(&chan_vars->trs_reply, chan_vars);
+
+         if (chan == chan_vars->action.cs[0])
+			{
+				ast_channel_setoption(chan_vars->action.cs[1], 3, chan_vars->action.FILE_URL, 1, 0);
+				ast_hangup(chan_vars->action.cs[1]);
+			}
+			else
+			{
+				ast_channel_setoption(chan_vars->action.cs[0], 3, chan_vars->action.FILE_URL, 1, 0);
+				ast_hangup(chan_vars->action.cs[0]);
+			}
+			memset(&chan_vars->action, 0, sizeof(chan_vars->action));
+		}
+   }
+//--- ACTION_ROUEND ------------------------------------------------------------------------------
+   else if (chan_vars->action.type == ACTION_ROUEND)
+	{
+	   if (chan_vars->action.record != NULL) ast_closestream(chan_vars->action.record);	                  
+	   if (!chan_vars->shutdown)
+		   asteriskSendReply(&chan_vars->trs_reply, chan_vars);
+
+      if (chan_vars->action.cs[0]) ast_channel_internal_bridged_channel_set(chan_vars->action.cs[0], NULL);
+      else ast_log(LOG_WARNING, "Route endpoint bridge 0 failed to stop\n");
+	   if (chan_vars->action.cs[1]) ast_channel_internal_bridged_channel_set(chan_vars->action.cs[1], NULL);
+      else ast_log(LOG_WARNING, "Route endpoint bridge 1 failed to stop\n");
+
+      if (chan_vars->action.cs[0] && chan_vars->action.cs[1])
+	      manager_event(EVENT_FLAG_CALL, "Unlink", 
+					      "Channel1: %s\r\n"
+					      "Channel2: %s\r\n"
+					      "Uniqueid1: %s\r\n"
+					      "Uniqueid2: %s\r\n",
+					      ast_channel_name(chan_vars->action.cs[0]), ast_channel_name(chan_vars->action.cs[1]),
+                     ast_channel_uniqueid(chan_vars->action.cs[0]), ast_channel_uniqueid(chan_vars->action.cs[1]));
+      else ast_log(LOG_WARNING, "Route endpoint failed to stop\n");
+
+      memset(&chan_vars->action, 0, sizeof(chan_vars->action));
+   }
+}
+
+/******************************************************************************
+ *        NAME: build_reply()
+ * DESCRIPTION: Build reply for InoVox
+ *              
+ *****************************************************************************/
+void build_reply(ast_vars *chan_vars)
+{
+   //_DebugSay(VOICE, INFO, 5, 0, "[ASTERISK] build_reply() called");
+
+	memset(&chan_vars->trs_reply, 0, sizeof(reply_ast));
+	chan_vars->trs_reply.con_id = chan_vars->action.con_id;
+	chan_vars->trs_reply.cmd_cnt = chan_vars->action.cmd_cnt;
+	chan_vars->trs_reply.sender = chan_vars->action.edp_id;
+	chan_vars->trs_reply.event = chan_vars->action.cmd_event;
+	chan_vars->trs_reply.error = FALSE;
+
+	memset(&chan_vars->trs_reply.body.terminator, 0, sizeof(terminator));
+}
+
+/******************************************************************************
+ *        NAME: post_error()
+ * DESCRIPTION: Build reply with error to InoVox
+ *              
+ *****************************************************************************/
+void post_error(cmd_ast trs_cmd, ast_vars *chan_vars, int event, int error)
+{
+	reply_ast trs_reply;
+
+   //_DebugSay(VOICE, INFO, 5, 0, "[ASTERISK] post_error() called");
+   memset(&trs_reply, 0, sizeof(reply_ast));
+	trs_reply.cmd_cnt = trs_cmd.cmd_cnt;
+	trs_reply.con_id = trs_cmd.con_id;
+	trs_reply.sender = trs_cmd.edp_id;
+	trs_reply.event = event;
+	trs_reply.error = TRUE;
+	trs_reply.body.error_value = error;
+	asteriskSendReply(&trs_reply, chan_vars);
+}
+
+/******************************************************************************
+ *        NAME: send_asr()
+ * DESCRIPTION: Send ASR RTP packets
+ *              
+ *****************************************************************************/
+void send_asr(struct ast_frame *usr_frame, ast_vars *chan_vars)
+{
+	unsigned int *rtpheader;
+	int hdrlen = 12, pred, payload, x, mark = 0;
+	unsigned int ms;
+	struct timeval now;
+	struct ast_frame *rtp_frame;
+	char digit, dtmf[64];
+
+   if (usr_frame == NULL || chan_vars == NULL) return;
+
+	if ((usr_frame->frametype != AST_FRAME_DTMF) && (usr_frame->frametype != AST_FRAME_VOICE)) return; // only send voice packets to ASR server
+
+	if (!chan_vars->asr.asr_txcore.tv_sec && !chan_vars->asr.asr_txcore.tv_usec)
+	{
+		gettimeofday(&chan_vars->asr.asr_txcore, NULL);
+		chan_vars->asr.asr_txcore.tv_usec -= chan_vars->asr.asr_txcore.tv_usec % 20000; // Round to 20ms for nice, pretty timestamps
+	}
+	if (usr_frame->frametype == AST_FRAME_VOICE)
+	{
+		if (chan_vars->asr.asr_writetrans) rtp_frame = ast_translate(chan_vars->asr.asr_writetrans, usr_frame, 0);
+
+		else rtp_frame = usr_frame;
+
+		if(&rtp_frame->delivery && (rtp_frame->delivery.tv_sec || rtp_frame->delivery.tv_usec))
+		{
+			// Use previous chan_vars->asr_txcore 
+			ms = (rtp_frame->delivery.tv_sec - chan_vars->asr.asr_txcore.tv_sec) * 1000;
+			ms += (1000000 + rtp_frame->delivery.tv_usec - chan_vars->asr.asr_txcore.tv_usec) / 1000 - 1000;
+			chan_vars->asr.asr_txcore.tv_sec = rtp_frame->delivery.tv_sec;
+			chan_vars->asr.asr_txcore.tv_usec = rtp_frame->delivery.tv_usec;
+		}
+		else
+		{
+			gettimeofday(&now, NULL);
+			ms = (now.tv_sec - chan_vars->asr.asr_txcore.tv_sec) * 1000;
+			ms += (1000000 + now.tv_usec - chan_vars->asr.asr_txcore.tv_usec) / 1000 - 1000;
+			// Use what we just got for next time 
+			chan_vars->asr.asr_txcore.tv_sec = now.tv_sec;
+			chan_vars->asr.asr_txcore.tv_usec = now.tv_usec;
+		}
+
+		payload = rtp_frame->subclass.integer;
+		
+		// Default prediction
+			pred = chan_vars->asr.asr_lastts + ms * 8;
+			
+      switch(rtp_frame->subclass.format.id)
+			{
+			case AST_FORMAT_ULAW:
+			case AST_FORMAT_ALAW:
+			// If we're within +/- 20ms from when where we predict we should be, use that
+				pred = chan_vars->asr.asr_lastts + rtp_frame->datalen;
+				break;
+			case AST_FORMAT_ADPCM:
+			case AST_FORMAT_G726:
+			// If we're within +/- 20ms from when where we predict we should be, use that 
+				pred = chan_vars->asr.asr_lastts + rtp_frame->datalen * 2;
+				break;
+			case AST_FORMAT_G729A:
+				pred = chan_vars->asr.asr_lastts + rtp_frame->datalen * 8;
+				break;
+			case AST_FORMAT_GSM:
+				pred = chan_vars->asr.asr_lastts + (rtp_frame->datalen * 160 / 33);
+				break;
+			case AST_FORMAT_ILBC:
+				pred = chan_vars->asr.asr_lastts + (rtp_frame->datalen * 240 / 50);
+				break;
+			case AST_FORMAT_G723_1:
+         pred = chan_vars->asr.asr_lastts + local_g723_samples(rtp_frame->data.ptr, rtp_frame->datalen);
+				break;
+			case AST_FORMAT_SPEEX:
+				pred = chan_vars->asr.asr_lastts + 160;
+				// assumes that the RTP packet contains one Speex frame 
+				break;
+			case AST_FORMAT_LPC10:
+				// assumes that the RTP packet contains one LPC10 frame
+				pred = chan_vars->asr.asr_lastts + 22 * 8;
+         pred += (((char *)(rtp_frame->data.ptr))[7] & 0x1) * 8;
+				break;
+			default:
+            if (option_verbose >= 2)
+            ast_log(LOG_DEBUG, "Not sure about timestamp format for codec format %s\n", ast_getformatname(&(rtp_frame->subclass.format)));
+			}
+			// Re-calculate last TS 
+			chan_vars->asr.asr_lastts = chan_vars->asr.asr_lastts + ms * 8;
+			if (!rtp_frame->delivery.tv_sec && !rtp_frame->delivery.tv_usec)
+			{
+			// If this isn't an absolute delivery time, Check if it is close to our prediction, and if so, go with our prediction 
+				if (abs(chan_vars->asr.asr_lastts - pred) < MAX_TIMESTAMP_SKEW)
+					chan_vars->asr.asr_lastts = pred;
+				else
+				{
+					ast_log(LOG_DEBUG, "Difference is %d, ms is %d\n", abs(chan_vars->asr.asr_lastts - pred), ms);
+					mark = 1;
+				}
+			}
+		
+		// Get a pointer to the header 
+		rtpheader = (unsigned int *)(rtp_frame->data.ptr - hdrlen);
+		rtpheader[0] = htonl((2 << 30) | (payload << 16) | (chan_vars->asr.asr_rtp_seqno++) | (mark << 23));
+		rtpheader[1] = htonl(chan_vars->asr.asr_lastts);
+		rtpheader[2] = htonl(chan_vars->asr.asr_rtp_ssrc);
+
+		if (sendto(chan_vars->asr.asr_sock, (void *)rtpheader, rtp_frame->datalen + hdrlen, 0, (struct sockaddr *) &chan_vars->asr.asr_serv_addr, sizeof(chan_vars->asr.asr_serv_addr)) < 0)
+		ast_log(LOG_WARNING, "Unable to send audio packet to ASR server\n");
+	}
+	else if (usr_frame->frametype == AST_FRAME_DTMF)
+	{
+		rtp_frame = usr_frame;
+
+		if(&rtp_frame->delivery && (rtp_frame->delivery.tv_sec || rtp_frame->delivery.tv_usec))
+		{
+			// Use previous chan_vars->asr.asr_txcore 
+			ms = (rtp_frame->delivery.tv_sec - chan_vars->asr.asr_txcore.tv_sec) * 1000;
+			ms += (1000000 + rtp_frame->delivery.tv_usec - chan_vars->asr.asr_txcore.tv_usec) / 1000 - 1000;
+			chan_vars->asr.asr_txcore.tv_sec = rtp_frame->delivery.tv_sec;
+			chan_vars->asr.asr_txcore.tv_usec = rtp_frame->delivery.tv_usec;
+		}
+		else
+		{
+			gettimeofday(&now, NULL);
+			ms = (now.tv_sec - chan_vars->asr.asr_txcore.tv_sec) * 1000;
+			ms += (1000000 + now.tv_usec - chan_vars->asr.asr_txcore.tv_usec) / 1000 - 1000;
+			// Use what we just got for next time 
+			chan_vars->asr.asr_txcore.tv_sec = now.tv_sec;
+			chan_vars->asr.asr_txcore.tv_usec = now.tv_usec;
+		}
+
+		digit = usr_frame->subclass.integer;
+
+		if ((digit <= '9') && (digit >= '0'))
+			digit -= '0';
+		else if (digit == '*')
+			digit = 10;
+		else if (digit == '#')
+			digit = 11;
+		else if ((digit >= 'A') && (digit <= 'D')) 
+			digit = digit - 'A' + 12;
+		else if ((digit >= 'a') && (digit <= 'd')) 
+			digit = digit - 'a' + 12;
+		else {
+			ast_log(LOG_WARNING, "Don't know how to represent '%c'\n", digit);
+			return;
+		}
+
+		payload = 101; // ast_rtp_lookup_code(rtp, 0, AST_RTP_DTMF);
+
+		// Re-calculate last TS 
+		chan_vars->asr.asr_lastts = chan_vars->asr.asr_lastts + ms * 8;
+
+		// Get a pointer to the header 
+		rtpheader = (unsigned int *) dtmf;
+		rtpheader[0] = htonl((2 << 30) | (1 << 23) | (payload << 16) | (chan_vars->asr.asr_rtp_seqno++));
+		rtpheader[1] = htonl(chan_vars->asr.asr_lastts);
+		rtpheader[2] = htonl(chan_vars->asr.asr_rtp_ssrc);
+		rtpheader[3] = htonl((digit << 24) | (0xa << 16) | (0));
+
+		for (x = 0; x < 4; x++) 
+      {
+			if (sendto(chan_vars->asr.asr_sock, (void *)rtpheader, hdrlen + 4, 0, (struct sockaddr *) &chan_vars->asr.asr_serv_addr, sizeof(chan_vars->asr.asr_serv_addr)) < 0)
+			{
+				ast_log(LOG_WARNING, "Unable to send DTMF packet to ASR server\n");
+			}
+			if (x == 0)
+			{
+				// Clear marker bit and increment seqno 
+				rtpheader[0] = htonl((2 << 30)  | (payload << 16) | (chan_vars->asr.asr_rtp_seqno++));
+				// Make duration 800 (100ms) 
+				rtpheader[3] |= htonl((800));
+				// Set the End bit for the last 3 
+				rtpheader[3] |= htonl((1 << 23));
+			}
+			else if ( x < 3)
+			{
+				rtpheader[0] = htonl((2 << 30) | (payload << 16) | (chan_vars->asr.asr_rtp_seqno++));
+			}
+		}
+	}
+}
+
+/******************************************************************************
+ *        NAME: asteriskSendReply()
+ * DESCRIPTION: 
+ *              
+ *****************************************************************************/
+int asteriskSendReply(reply_ast *reply, ast_vars *chan_vars)
+{
+	int total = 0; // how many bytes we've sent
+	int bytesleft; // how many we have left to send
+	int n = 0;
+   int datalen = sizeof(reply_ast);
+
+   bytesleft = datalen;
+
+   reply->chan_id = chan_vars->chan_id;
+
+	while((n = send(chan_vars->trs_fd, reply+total, bytesleft, 0)) != -1) 
+   {
+		if (n == bytesleft) break;
+		total += n;
+		bytesleft -= n;
+      usleep(1000); // only sleep if n != bytesleft
+	}
+	return n == -1 ? -1 : 0; // return -1 on failure, 0 on success
+}
+
+/******************************************************************************
+ *        NAME: local_g723_len()
+ * DESCRIPTION: Used on SendASR
+ *              
+ *****************************************************************************/
+static int local_g723_len(unsigned char buf)
+{
+	switch(buf & TYPE_MASK) 
+   {
+	case TYPE_DONTSEND:
+		return 0;
+		break;
+	case TYPE_SILENCE:
+		return 4;
+		break;
+	case TYPE_HIGH:
+		return 24;
+		break;
+	case TYPE_LOW:
+		return 20;
+		break;
+	default:
+		ast_log(LOG_WARNING, "Badly encoded frame (%d)\n", buf & TYPE_MASK);
+	}
+	return -1;
+}
+
+/******************************************************************************
+ *        NAME: local_g723_samples()
+ * DESCRIPTION: Used on SendASR
+ *              
+ *****************************************************************************/
+static int local_g723_samples(unsigned char *buf, int maxlen)
+{
+	int pos = 0;
+	int samples = 0;
+	int res;
+	while(pos < maxlen) 
+   {
+		res = local_g723_len(buf[pos]);
+		if (res <= 0)
+			break;
+		samples += 240;
+		pos += res;
+	}
+	return samples;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/apps/wms_aux.h asterisk-11.3.0.p000/apps/wms_aux.h
--- asterisk-base-11.3.0/apps/wms_aux.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-11.3.0.p000/apps/wms_aux.h	2013-05-13 14:00:47.688437468 +0100
@@ -0,0 +1,48 @@
+/*******************************************************************************
+ *        FILE: 
+ * DESCRIPTION: 
+ *              
+ * 
+ * $Archive: $
+ * $Revision: 1.0 $
+ * $Author: $
+ * $History: $
+ * 
+ * 
+ *   Copyright (c) 2005 PT Inovação SA. All Rights Reserved
+ ******************************************************************************/
+#ifndef ASTERISK_AUX
+#define ASTERISK_AUX
+
+/********************************************************************************
+*
+* INCLUDES
+*
+*********************************************************************************/
+#include "vsrvdefs.h"
+
+/********************************************************************************
+*
+* DEFINES
+*
+*********************************************************************************/
+#define TRS_PORT 60000
+#define TRS_PORT_STR "60000"
+
+/********************************************************************************
+*
+* FUNCTION PROTOTYPES
+*
+*********************************************************************************/
+void check_timeout_terminators(struct ast_channel *chan, ast_vars *chan_vars);
+void check_digit_terminators(struct ast_channel *chan, ast_vars *chan_vars);
+void stop_action(struct ast_channel *chan, ast_vars *chan_vars);
+void process_digit(struct ast_channel *chan, ast_vars *chan_vars, int digit);
+void build_action(ast_vars *chan_vars, cmd_ast *trs_cmd, int actype, int cmdevent);
+void build_terminator(struct ast_channel *chan, ast_vars *chan_vars, cmd_ast trs_cmd);
+void build_reply(ast_vars *chan_vars);
+void post_error(cmd_ast trs_cmd, ast_vars *chan_vars, int event, int error);
+void send_asr(struct ast_frame *, ast_vars *);
+int asteriskSendReply(reply_ast *, ast_vars *);
+
+#endif
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/apps/wms_inoapi.c asterisk-11.3.0.p000/apps/wms_inoapi.c
--- asterisk-base-11.3.0/apps/wms_inoapi.c	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-11.3.0.p000/apps/wms_inoapi.c	2013-05-13 14:00:47.692437811 +0100
@@ -0,0 +1,1394 @@
+/*******************************************************************************
+ *        FILE: asterisk_inoapi.c
+ * DESCRIPTION: 
+ *              
+ * 
+ * $Archive: $
+ * $Revision: 1.0 $
+ * $Author: $
+ * $History: $
+ * 
+ * Luis Reis
+ * Copyright (c) 2006 PT Inovação SA. All Rights Reserved
+ ******************************************************************************/
+
+ /*******************************************************************************
+ *
+ * SYSTEM HEADER FILES
+ *
+ ******************************************************************************/
+#include <stdio.h>
+#include <errno.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <signal.h>
+#include "asterisk.h"
+#include <asterisk/lock.h>
+#include <asterisk/file.h>
+#include <asterisk/logger.h>
+#include <asterisk/channel.h>
+#include <asterisk/features.h>
+#include <asterisk/options.h>
+#include <asterisk/pbx.h>
+#include <asterisk/translate.h>
+#include <asterisk/chanvars.h>
+#include <asterisk/causes.h>
+#include <asterisk/manager.h>
+#include <asterisk/musiconhold.h>
+#include <asterisk/app.h>
+#include <asterisk/utils.h>
+
+/*******************************************************************************
+ *
+ * APPLICATION HEADER FILES
+ *
+ ******************************************************************************/
+#include "vsrvdefs.h"
+#include "app_wms.h"
+#include "wms_inoapi.h"
+#include "wms_aux.h"
+
+/*******************************************************************************
+ *
+ * VARIABLES
+ *
+ ******************************************************************************/
+struct conf_struct
+{
+   struct ast_channel *chan;
+   ast_vars *chan_vars;
+} conf_data;
+
+struct inast_localuser 
+{
+	struct ast_channel *chan;
+	int stillgoing;
+	int allowredirect_in;
+	int allowredirect_out;
+	int allowdisconnect;
+   struct inast_localuser *next;
+};
+
+/*******************************************************************************
+ *
+ * FUNCTION PROTOTYPES
+ *  
+ ******************************************************************************/
+static void *conference_thread(void *);
+static struct ast_channel *wait_for_answer(struct ast_channel *, struct inast_localuser *, int *);
+static struct ast_channel *get_rtsp_chan(struct ast_channel *, char *);
+
+/*******************************************************************************
+ *
+ * FUNCTIONS
+ *
+ ******************************************************************************/
+//- INOVOX API FUNCTIONS -----------------------------------------------------------------
+/******************************************************************************
+ *        NAME: accept_icall()
+ * DESCRIPTION: 
+ *              
+ *****************************************************************************/
+void accept_icall(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars)
+{
+	reply_ast trs_reply;
+   int res;
+
+   memset(&trs_reply, 0, sizeof(reply_ast));
+	trs_reply.cmd_cnt = trs_cmd.cmd_cnt;
+	trs_reply.con_id = trs_cmd.con_id;
+	trs_reply.sender = trs_cmd.edp_id;
+	trs_reply.event = ACCEPT_ICALL_COMPLETED;
+   if (!chan_vars->chan_id) chan_vars->chan_id = trs_cmd.ch_index;
+
+	// Set SMRA values
+   //memcpy(&chan->server_smra_attrib, &trs_cmd.smra_attrib, sizeof(chan->server_smra_attrib));
+   ast_channel_server_smra_attrib_set(chan, &(trs_cmd.smra_attrib));
+	
+   // trs_cmd.al_int_val1 = con_type
+   // trs_cmd.al_int_val2 == charge_type - CHARGE
+   if(!trs_cmd.al_int_val2)
+      ast_channel_charge_type_set(chan, 1);
+   else
+      ast_channel_charge_type_set(chan, 0);
+   //chan->charge_type = trs_cmd.al_int_val2;
+
+   ast_log(LOG_DEBUG, "InoAPI says Charge %d\n", trs_cmd.al_int_val2);
+
+	if (trs_cmd.al_int_val1 == ACCEPT)
+	{
+	   if (option_verbose >= 3)
+	               ast_verbose(VERBOSE_PREFIX_3 "Sending session progress(%s) on ch %03d\n", ast_channel_name(chan), trs_cmd.ch_index);
+      ast_indicate(chan, AST_CONTROL_PROGRESS);
+      chan_vars->early_media = ast_tvnow();
+	}
+   else 
+   {
+      chan_vars->early_media = ast_tv(0, 0);
+      if ((res = ast_answer(chan)) < 0)// answer line
+      {
+   		ast_log(LOG_WARNING, "Error on ast_answer(%s) on ch %03d\n", ast_channel_name(chan), trs_cmd.ch_index);
+      	trs_reply.error = TRUE;
+         trs_reply.body.error_value = TASKFAIL_ERROR;
+         asteriskSendReply(&trs_reply, chan_vars);
+         return;
+      }
+   }   
+	chan_vars->trs_reply.con_id = trs_cmd.con_id;
+	chan_vars->trs_reply.sender = trs_cmd.edp_id;
+	
+	asteriskSendReply(&trs_reply, chan_vars);
+}
+
+/******************************************************************************
+ *        NAME: connect_call()
+ * DESCRIPTION: 
+ *              
+ *****************************************************************************/
+void connect_call(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars)
+{
+	reply_ast trs_reply;
+   int res;
+
+   memset(&trs_reply, 0, sizeof(reply_ast));
+	trs_reply.cmd_cnt = trs_cmd.cmd_cnt;
+	trs_reply.con_id = trs_cmd.con_id;
+	trs_reply.sender = trs_cmd.edp_id;
+	trs_reply.event = CONNECT_CALL_COMPLETED;
+   chan_vars->early_media = ast_tv(0, 0);
+   if (!chan_vars->chan_id) chan_vars->chan_id = trs_cmd.ch_index;
+
+   if(!trs_cmd.al_int_val2)
+      ast_channel_charge_type_set(chan, 1);
+      else
+         ast_channel_charge_type_set(chan, 0);
+   ast_log(LOG_DEBUG, "InoAPI says Charge %d\n", trs_cmd.al_int_val2);
+       
+	if (ast_channel_state(chan) != AST_STATE_UP)
+   {
+      if ((res = ast_answer(chan)) < 0) // answer line
+      {
+         ast_log(LOG_WARNING, "Error on ast_answer(%s) on ch %03d\n", ast_channel_name(chan), trs_cmd.ch_index);
+   	   trs_reply.error = TRUE;
+         trs_reply.body.error_value = TASKFAIL_ERROR;
+         asteriskSendReply(&trs_reply, chan_vars);
+         return;
+      }
+   }
+	asteriskSendReply(&trs_reply, chan_vars);
+}
+
+/******************************************************************************
+ *        NAME: attach_capabilities()
+ * DESCRIPTION: 
+ *              
+ *****************************************************************************/
+void attach_capabilities(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars)
+{
+	struct ast_format rtp_ulaw;
+	struct ast_format rtp_alaw;
+	struct ast_format_cap *asr_cap;
+	struct ast_format src;
+	int res;
+
+	if (trs_cmd.dtmf != -1)
+   {
+      chan_vars->dtmf = trs_cmd.dtmf;
+   }
+	if (trs_cmd.asr != -1)
+	{
+		if ((chan_vars->asr.asr_sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+		{
+         ast_log(LOG_WARNING, "Couldn't create ASR socket on ch %03d\n", trs_cmd.ch_index);
+			chan_vars->asr.asr_sock = -1;
+		}
+		else
+		{
+			memset(&chan_vars->asr.asr_serv_addr, 0, sizeof(chan_vars->asr.asr_serv_addr)); // Zero out structure  
+			chan_vars->asr.asr_serv_addr.sin_family = AF_INET; // Internet addr family  
+			chan_vars->asr.asr_serv_addr.sin_addr.s_addr = inet_addr(trs_cmd.asr_rattrib.server_ip); // Server IP address  
+			chan_vars->asr.asr_serv_addr.sin_port = htons(trs_cmd.asr_rattrib.rtp_port); // Server port 
+			chan_vars->asr.asr_rtp_seqno = 0;
+			chan_vars->asr.asr_rtp_ssrc = rand();
+			chan_vars->asr.asr_lastts = 0;
+			chan_vars->asr.asr_lastovidtimestamp = 0;
+
+			gettimeofday(&chan_vars->asr.asr_txcore, NULL);
+
+			ast_format_set(&rtp_ulaw, AST_FORMAT_ULAW, 0);
+			ast_format_set(&rtp_alaw, AST_FORMAT_ALAW, 0);
+
+			if ((!ast_format_cap_iscompatible(ast_channel_nativeformats(chan), &rtp_ulaw)) && ((!ast_format_cap_iscompatible(ast_channel_nativeformats(chan), &rtp_alaw))))
+			{
+			   asr_cap = ast_format_cap_alloc();
+			   ast_format_cap_add(asr_cap, &rtp_alaw);
+			   ast_format_cap_add(asr_cap, &rtp_ulaw);
+
+				res = ast_translator_best_choice(asr_cap, ast_channel_nativeformats(chan), &rtp_alaw, &src);
+				if (chan_vars->asr.asr_writetrans) ast_translator_free_path(chan_vars->asr.asr_writetrans);
+				chan_vars->asr.asr_writetrans = ast_translator_build_path(&rtp_alaw, &src);
+			}
+		}
+	}
+}
+
+/******************************************************************************
+ *        NAME: exec_asterisk()
+ * DESCRIPTION: 
+ *              
+ *****************************************************************************/
+void exec_asterisk(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars)
+{
+	struct ast_app *app; // AGI RELATED
+	reply_ast trs_reply;
+   static cmd_ast trs_cmd2;
+   int res;
+
+   memset(&trs_reply, 0, sizeof(reply_ast));
+	trs_reply.cmd_cnt = trs_cmd.cmd_cnt;
+	trs_reply.con_id = trs_cmd.con_id;
+	trs_reply.sender = trs_cmd.edp_id;
+	trs_reply.event = EXEC_ASTERISK_COMPLETED;
+   memcpy(&trs_cmd2, &trs_cmd, sizeof(trs_cmd));
+
+   if (!strncmp(trs_cmd.al_char_val1, "ConfJoin", 8) || !strncmp(trs_cmd.al_char_val1, "ConfLeave", 9))
+   {
+      char *tmp;
+
+      if ((tmp = strchr(trs_cmd.al_char_val2, '|')) != NULL)
+      {
+         *tmp = '\0'; //cut string
+         trs_cmd2.al_int_val2 = atoi(trs_cmd.al_char_val2);
+         ++tmp;
+         snprintf(trs_cmd2.al_char_val1, sizeof(trs_cmd2.al_char_val1), tmp);
+      }
+      else
+      {
+         trs_cmd2.al_int_val2 = atoi(trs_cmd.al_char_val2);
+         trs_cmd2.al_char_val1[0] = '\0';
+      }
+      if (!strncmp(trs_cmd.al_char_val1, "ConfJoin", 8)) trs_cmd2.al_int_val1 = 1;
+      else trs_cmd2.al_int_val1 = 2;
+
+      conference_call(chan, trs_cmd2, chan_vars);
+      return;
+   }
+   else if (!strncmp(trs_cmd.al_char_val1, "ConfBcast", 9))
+   {
+      if (chan_vars->conference.id) 
+      {
+         if (option_verbose >= 4)
+            ast_verbose(VERBOSE_PREFIX_4 "ConfBcast received [%s]!\n", trs_cmd.al_char_val2);
+         ast_channel_conf_playann_set(chan, trs_cmd.al_char_val2);
+         ast_set_flag(ast_channel_inoflags(chan), MEETME_BROADCAST_ME);
+      }
+      return;
+   }
+   else if (!strncmp(trs_cmd.al_char_val1, "BcastStop", 9))
+   {
+      if (chan_vars->conference.id && (ast_test_flag(ast_channel_inoflags(chan), MEETME_BROADCAST_ME) ||
+         ast_test_flag(ast_channel_inoflags(chan), MEETME_BROADCASTING)))
+      {
+         if (option_verbose >= 4)
+            ast_verbose(VERBOSE_PREFIX_4 "BcastStop received!\n");
+         ast_set_flag(ast_channel_inoflags(chan), MEETME_STOP_BROADCAST);
+      }
+      return;
+   }   
+   //- NEW --
+   else if (!strncmp(trs_cmd.al_char_val1, "SipInfo", 7))
+   {
+   	if (ast_channel_tech(chan)->send_text)
+   	   res = ast_sendtext(chan, trs_cmd.al_char_val2);
+      else 
+      {
+         ast_log(LOG_WARNING, "Error sending SIP INFO\n");
+		   trs_reply.error = TRUE;
+		   trs_reply.body.error_value = RESOURCE_ERROR;
+      }
+
+   	asteriskSendReply(&trs_reply, chan_vars);
+      return;
+   }
+	else if ((app = pbx_findapp(trs_cmd.al_char_val1))) // application found// AGI RELATED
+	{
+		trs_reply.error = FALSE;
+		trs_reply.body.g_ret_value = pbx_exec(chan, app, trs_cmd.al_char_val2);
+	}
+	else // application doesn't exist
+	{
+      ast_log(LOG_NOTICE, "App [%s] not found!\n", trs_cmd.al_char_val1);
+
+		trs_reply.error = TRUE;
+		trs_reply.body.error_value = FUNCTION_NOT_SUPPORTED;
+	}
+	asteriskSendReply(&trs_reply, chan_vars);
+}
+
+/******************************************************************************
+ *        NAME: play_digits()
+ * DESCRIPTION: 
+ *              
+ *****************************************************************************/
+void play_digits(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars)
+{
+	reply_ast trs_reply;
+   int res = 0;
+
+	if (ast_bridged_channel(chan) || chan_vars->action.type != NO_ACTION || chan_vars->conference.id)
+	{
+		post_error(trs_cmd, chan_vars, PLAY_DIGITS_COMPLETED, RESOURCE_ERROR);
+		return;
+	}
+	if ((res = ast_dtmf_stream(chan, NULL, trs_cmd.dial_number, 250, 0)) < 0)
+   {
+		post_error(trs_cmd, chan_vars, PLAY_DIGITS_COMPLETED, RESOURCE_ERROR);
+		return;
+   }
+   memset(&trs_reply, 0, sizeof(reply_ast));
+   trs_reply.cmd_cnt = trs_cmd.cmd_cnt;
+	trs_reply.con_id = trs_cmd.con_id;
+	trs_reply.sender = trs_cmd.edp_id;
+	trs_reply.event = PLAY_DIGITS_COMPLETED;
+
+	asteriskSendReply(&trs_reply, chan_vars);
+}
+
+/******************************************************************************
+ *        NAME: reject_icall()
+ * DESCRIPTION: 
+ *              
+ *****************************************************************************/
+void reject_icall(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars)
+{
+	chan_vars->shutdown = 1;
+	ast_channel_hangupcause_set(chan, trs_cmd.al_int_val1);
+	//ast_softhangup(chan, AST_CAUSE_NORMAL);// hangup line
+   chan_vars->shutdown = 1;
+}
+
+/******************************************************************************
+ *        NAME: release_endpoint()
+ * DESCRIPTION: 
+ *              
+ *****************************************************************************/
+void release_endpoint(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars)
+{
+   if (option_verbose >= 3)
+      ast_verbose(VERBOSE_PREFIX_3 "Release on channel %s\n", ast_channel_name(chan));
+
+	if (chan_vars->asr.asr_sock > 2)
+	{
+		close(chan_vars->asr.asr_sock);
+		chan_vars->asr.asr_sock = -1;
+	}
+   if (trs_cmd.al_int_val2 >= 100) 
+      ast_channel_hangupcause_set(chan, trs_cmd.al_int_val2);
+
+	//ast_softhangup(chan, AST_CAUSE_NORMAL);// hangup line
+	chan_vars->shutdown = 1;
+}
+
+/******************************************************************************
+ *        NAME: reset_endpoint()
+ * DESCRIPTION: 
+ *              
+ *****************************************************************************/
+void reset_endpoint(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars)
+{
+	reply_ast trs_reply;
+
+   memset(&trs_reply, 0, sizeof(reply_ast));
+   trs_reply.cmd_cnt = trs_cmd.cmd_cnt;
+	trs_reply.con_id = trs_cmd.con_id;
+	trs_reply.sender = trs_cmd.edp_id;
+	trs_reply.event = RESET_ENDPOINT_COMPLETED;
+   
+   chan_vars->trs_reply.body.terminator.stopped = 1;
+	stop_action(chan, chan_vars);
+
+   memset(&chan_vars->stream, 0, sizeof(chan_vars->stream));
+   memset(chan_vars->digit_buffer, 0, sizeof(chan_vars->digit_buffer));
+	asteriskSendReply(&trs_reply, chan_vars);
+}
+
+/******************************************************************************
+ *        NAME: stop_operation()
+ * DESCRIPTION: 
+ *              
+ *****************************************************************************/
+void stop_operation(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars)
+{
+	reply_ast trs_reply;
+
+   // stop play announcement in conference
+   if (chan_vars->conference.id) 
+   {
+      ast_set_flag(ast_channel_inoflags(chan), MEETME_STOP_PLAY);
+      ast_clear_flag(ast_channel_inoflags(chan), MEETME_DO_PLAY);
+   }
+
+   memset(&trs_reply, 0, sizeof(reply_ast));
+	trs_reply.cmd_cnt = trs_cmd.cmd_cnt;
+	trs_reply.con_id = trs_cmd.con_id;
+	trs_reply.sender = trs_cmd.edp_id;
+	trs_reply.event = STOP_OPERATION_COMPLETED;
+	trs_reply.body.terminator.stopped = 1;
+   //if the next line doesn't exist, stop_action will send message
+   chan_vars->trs_reply.body.terminator.stopped = 1;
+   stop_action(chan, chan_vars);
+
+	asteriskSendReply(&trs_reply, chan_vars);
+}
+
+/******************************************************************************
+ *        NAME: conference_call()
+ * DESCRIPTION: 
+ *              
+ *****************************************************************************/
+void conference_call(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars)
+{
+	int ret_evt = CONFERENCE_MANAGER_COMPLETED;
+	reply_ast trs_reply;
+	char *aux, *end;
+	char buff[1024];
+	char temp_record[1024];
+	int i;
+	//pthread_t confThread;
+   //pthread_attr_t attr;
+   //int ret;
+
+   if (option_verbose >= 4)
+      ast_verbose(VERBOSE_PREFIX_4 "Conference call operation %d on channel %s\n", trs_cmd.al_int_val1, ast_channel_name(chan));
+
+	if ((ast_bridged_channel(chan) || chan_vars->action.type != NO_ACTION) && trs_cmd.al_int_val1 == 1) goto error;
+
+   memset(&trs_reply, 0, sizeof(trs_reply));
+	trs_reply.cmd_cnt = trs_cmd.cmd_cnt;
+	trs_reply.con_id = trs_cmd.con_id;
+	trs_reply.sender = trs_cmd.edp_id;
+	trs_reply.event = CONFERENCE_MANAGER_COMPLETED;
+   trs_reply.error = FALSE;
+   trs_reply.body.g_ret_value = trs_cmd.al_int_val1;
+
+   //- ADD TO CONFERENCE -----------------------------------------
+   if (trs_cmd.al_int_val1 == 1) //conf_add
+   {
+      if (!chan_vars->conference.id)
+      {
+         //unsigned long stack_size = 240 * 1024;
+
+         conf_data.chan = chan;
+         conf_data.chan_vars = chan_vars;
+	      chan_vars->conference.cmd_cnt = trs_cmd.cmd_cnt;
+	      chan_vars->conference.con_id = trs_cmd.con_id;
+	      chan_vars->conference.edp_id = trs_cmd.edp_id;
+         ast_clear_flag(ast_channel_inoflags(chan), EXEC_APP_EXIT);
+
+         chan_vars->conference.id = trs_cmd.al_int_val2;
+
+         aux = trs_cmd.al_char_val1;
+
+         //Parser for escaped sequence
+         for(i=0; *aux != '\0'; i++)
+         {
+            if(*aux == '\e')
+            {
+               aux++;
+               continue;
+            }
+
+            //According to the position in the escaped params the value inside has a different meaning.
+            switch (i)
+            {
+               case 0:
+                  //Conference Record File
+                  if(trs_cmd.al_char_val1[0] == ' ')
+                     break;
+                  //strncpy(chan->conf_record, trs_cmd.al_char_val1, sizeof(chan->conf_record));
+                  strncpy(temp_record, trs_cmd.al_char_val1, sizeof(temp_record));
+                  if((end = strchr(temp_record, '\e')) != NULL)
+                  {
+                     *end = '\0';
+                  }
+
+                  if(strlen(temp_record) < 6 )
+                  {
+                     if (option_verbose >= 4)
+                        ast_verbose(VERBOSE_PREFIX_4 "Conference call record filename %s is too short on channel %s\n",
+                              temp_record, ast_channel_name(chan));
+                     ast_channel_conf_record_set(chan, "");
+                     break;
+                  }
+                  snprintf(buff, sizeof(buff), temp_record);
+                  if((end = strrchr(buff, '/')) == NULL)
+                  {
+                     ast_log(LOG_NOTICE, "Invalid record path (%s) provided to conference %d on ch %03d - %s\n", buff, chan_vars->conference.id, trs_cmd.ch_index, ast_channel_name(chan));
+                     chan_vars->conference.id = 0;
+                     goto error;
+                  }
+                  *end = '\0';
+                  if(access(buff, W_OK))
+                  {
+                     ast_log(LOG_NOTICE, "Invalid record path (%s) or bad dir permissions for conference %d on ch %03d - %s\n", buff, chan_vars->conference.id, trs_cmd.ch_index, ast_channel_name(chan));
+                     chan_vars->conference.id = 0;
+                     goto error;
+                  }
+
+                  if((end = strchr(temp_record, '.')) == NULL)
+                  {
+                     if (option_verbose >= 4)
+                        ast_verbose(VERBOSE_PREFIX_4 "Conference call record filename %s does not have extension on channel %s\n",
+                              temp_record, ast_channel_name(chan));
+                     ast_channel_conf_record_set(chan, "");
+                     break;
+                  }
+
+                  ast_channel_conf_record_format_set(chan, end + 1);
+                  *end = '\0';
+                  ast_channel_conf_record_set(chan, temp_record);
+
+                  ast_set_flag(ast_channel_inoflags(chan), MEETME_DO_RECORD);
+                  break;
+
+               default:
+                  break;
+            }
+
+            aux = strchr(aux, '\e');
+            if(aux != NULL)
+               aux++;
+            else
+               break;
+         }
+
+         trs_cmd.al_char_val1[0] = '\0';
+
+         snprintf(chan_vars->conference.args, sizeof(chan_vars->conference.args), trs_cmd.al_char_val1);
+/*
+         //InoBeginThreadEx
+         // Initialize and set thread detached attribute
+         pthread_attr_init(&attr);
+         // Set detached attribute
+         pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+         // Limit thread stack size to InoStackSize
+         pthread_attr_setstacksize (&attr, stack_size);
+         // Create the thread
+         ret = pthread_create(&confThread,  // thread id
+            &attr,                                    // thread attribute
+            conference_thread,                             // @parm thread function
+            NULL                                      // @parm thread argument
+            );
+
+         // We're done with the attribute object, so we can destroy it
+         pthread_attr_destroy(&attr);
+*/
+         if (chan_vars->conf_thread != AST_PTHREADT_NULL)
+         {
+            memset(&chan_vars->conference, 0, sizeof(chan_vars->conference));
+            ast_log(LOG_WARNING, "Thread in use! Ignoring conference %d on ch %03d - %s\n", trs_cmd.al_int_val2, trs_cmd.ch_index, ast_channel_name(chan));
+            goto error;
+         }
+         if (ast_pthread_create_background(&chan_vars->conf_thread, NULL, conference_thread, NULL) < 0)
+         {
+            memset(&chan_vars->conference, 0, sizeof(chan_vars->conference));
+            ast_log(LOG_WARNING, "Thread creation ERROR |%s| for conference %d on ch %03d - %s\n", strerror(errno), trs_cmd.al_int_val2, trs_cmd.ch_index, ast_channel_name(chan));
+            goto error;
+         }
+         else
+         {
+            if (option_verbose >= 4)
+               ast_verbose(VERBOSE_PREFIX_4 "User added to conference %d|%s on ch %03d - %s\n",
+                  trs_cmd.al_int_val2, trs_cmd.al_char_val1, trs_cmd.ch_index, ast_channel_name(chan));
+            asteriskSendReply(&trs_reply, chan_vars);
+         }
+      }
+      else
+      {
+         ast_log(LOG_NOTICE, "User already added to conference %d on ch %03d - %s\n", chan_vars->conference.id, trs_cmd.ch_index, ast_channel_name(chan));
+	      goto error;
+      }
+   }
+   //- REMOVE FROM CONFERENCE -----------------------------------------
+   else if (trs_cmd.al_int_val1 == 2) //remove
+   {
+      if (chan_vars->conference.id)
+      {
+         if (option_verbose >= 4)
+            ast_verbose(VERBOSE_PREFIX_4 "User removed from conference %d on ch %03d - %s\n", chan_vars->conference.id, trs_cmd.ch_index, ast_channel_name(chan));
+         ast_set_flag(ast_channel_inoflags(chan), EXEC_APP_EXIT);
+         chan_vars->conference.exit = 1;
+      }
+      else
+      {
+         if (option_verbose >= 3)
+            ast_verbose(VERBOSE_PREFIX_3 "User already removed from conference on ch %03d - %s\n", trs_cmd.ch_index, ast_channel_name(chan));
+         //No error on remove from conference
+         asteriskSendReply(&trs_reply, chan_vars);
+      }
+   }
+   else if (trs_cmd.al_int_val1 == 4) //CONF_MUTE
+   {
+      if (chan_vars->conference.id)
+      {
+         ast_set_flag(ast_channel_inoflags(chan), MEETME_MUTE_USER);
+         if (option_verbose >= 4)
+            ast_verbose(VERBOSE_PREFIX_4 "User muted from conference %d on ch %03d - %s\n", chan_vars->conference.id, trs_cmd.ch_index, ast_channel_name(chan));
+      	asteriskSendReply(&trs_reply, chan_vars);
+      }
+      else
+      {
+         ast_log(LOG_NOTICE, "User not in conference on ch %03d - %s\n", trs_cmd.ch_index, ast_channel_name(chan));
+	      goto error;
+      }
+   }
+   else if (trs_cmd.al_int_val1 == 8) //CONF_MUTEALL
+   {
+      if (chan_vars->conference.id)
+      {
+         ast_set_flag(ast_channel_inoflags(chan), MEETME_MUTE_ALL);
+
+         if (option_verbose >= 4)
+            ast_verbose(VERBOSE_PREFIX_4 "Muting conference %d on ch %03d - %s\n", chan_vars->conference.id, trs_cmd.ch_index, ast_channel_name(chan));
+      	asteriskSendReply(&trs_reply, chan_vars);
+      }
+      else
+      {
+         ast_log(LOG_NOTICE, "User not in conference on ch %03d - %s\n", trs_cmd.ch_index, ast_channel_name(chan));
+	      goto error;
+      }
+   }
+   else if (trs_cmd.al_int_val1 == 16) //CONF_UNMUTE
+   {
+      if (chan_vars->conference.id)
+      {
+         ast_set_flag(ast_channel_inoflags(chan), MEETME_UNMUTE_USER);
+
+         if (option_verbose >= 4)
+            ast_verbose(VERBOSE_PREFIX_4 "User unmuted from conference %d on ch %03d - %s\n", chan_vars->conference.id, trs_cmd.ch_index, ast_channel_name(chan));
+      	asteriskSendReply(&trs_reply, chan_vars);
+      }
+      else
+      {
+         ast_log(LOG_NOTICE, "User not in conference on ch %03d - %s\n", trs_cmd.ch_index, ast_channel_name(chan));
+	      goto error;
+      }
+   }
+   else if (trs_cmd.al_int_val1 == 32) //CONF_UNMUTEALL
+   {
+      if (chan_vars->conference.id)
+      {
+         ast_set_flag(ast_channel_inoflags(chan), MEETME_UNMUTE_ALL);
+
+         if (option_verbose >= 4)
+            ast_verbose(VERBOSE_PREFIX_4 "Unmuting conference %d on ch %03d - %s\n", chan_vars->conference.id, trs_cmd.ch_index, ast_channel_name(chan));
+      	asteriskSendReply(&trs_reply, chan_vars);
+      }
+      else
+      {
+         ast_log(LOG_NOTICE, "User not in conference on ch %03d - %s\n", trs_cmd.ch_index, ast_channel_name(chan));
+	      goto error;
+      }
+   }
+   else if (trs_cmd.al_int_val1 == 64) //CONF_PLAY
+   {
+      if (chan_vars->conference.id)
+      {
+         if (ast_test_flag(ast_channel_inoflags(chan), MEETME_DO_PLAY))
+         {
+            ast_log(LOG_NOTICE, "Conference %d ALREADY is playing announcement on ch %s\n", chan_vars->conference.id, ast_channel_name(chan));
+            goto error;
+         }
+         if (option_verbose >= 4)
+            ast_verbose(VERBOSE_PREFIX_4 "Play announcement %s to conference %d on ch %s\n", trs_cmd.al_char_val1, chan_vars->conference.id, ast_channel_name(chan));
+         ast_clear_flag(ast_channel_inoflags(chan), MEETME_STOP_PLAY);
+         ast_channel_conf_playann_set(chan, trs_cmd.al_char_val1);
+         ast_set_flag(ast_channel_inoflags(chan), MEETME_DO_PLAY);
+      }
+      else
+      {
+         ast_log(LOG_NOTICE, "User not in conference on ch %03d - %s\n", trs_cmd.ch_index, ast_channel_name(chan));
+	      goto error;
+      }
+   }
+   else
+   {
+	   goto error;
+   }
+	return;
+
+error:
+	post_error(trs_cmd, chan_vars, ret_evt, RESOURCE_ERROR);
+   
+}
+
+/******************************************************************************
+ *        NAME: conference_thread()
+ * DESCRIPTION: 
+ *              
+ *****************************************************************************/
+static void *conference_thread(void *data)
+{
+	struct ast_app *app; // AGI RELATED
+   struct ast_channel *chan = conf_data.chan;
+   ast_vars *chan_vars = conf_data.chan_vars;
+   char execCmd[15];
+	reply_ast trs_reply;
+
+   memset(&trs_reply, 0, sizeof(trs_reply));
+   trs_reply.cmd_cnt = chan_vars->conference.cmd_cnt;
+	trs_reply.con_id = chan_vars->conference.con_id;
+	trs_reply.sender = chan_vars->conference.edp_id;
+	trs_reply.event = CONFERENCE_MANAGER_COMPLETED;
+   trs_reply.error = FALSE;
+   trs_reply.body.g_ret_value = 2;
+     
+   if (chan == NULL)
+   {
+		ast_log(LOG_WARNING, "Chan is NULL\n");
+		return NULL;
+   }
+   snprintf(execCmd, sizeof(execCmd), "%d,dq%s", chan_vars->conference.id, chan_vars->conference.args);
+	if ((app = pbx_findapp("MeetMe"))) // application found// AGI RELATED
+	{
+      if (option_verbose >= 3)
+         ast_verbose(VERBOSE_PREFIX_3 "Conference_thread created |%s| on channel %s\n", execCmd, ast_channel_name(chan));
+		pbx_exec(chan, app, execCmd);
+
+      if (chan_vars->conference.exit) asteriskSendReply(&trs_reply, chan_vars);
+      else
+      {
+         trs_reply.event = UNSOLICITED_EVENT;
+         trs_reply.evt_type = CONFERENCE_EVENT;
+         trs_reply.body.g_ret_value = USER_EXITED_CONFERENCE;
+         asteriskSendReply(&trs_reply, chan_vars);
+      }
+      memset(&chan_vars->conference, 0, sizeof(chan_vars->conference));
+	}
+	else // application doesn't exist
+	{
+      ast_log(LOG_WARNING, "pbx_findapp failed on channel %s\n", ast_channel_name(chan));
+	   trs_reply.error = TRUE;
+	   trs_reply.body.error_value = RESOURCE_ERROR;
+	   asteriskSendReply(&trs_reply, chan_vars);
+      memset(&chan_vars->conference, 0, sizeof(chan_vars->conference));
+	}
+	chan_vars->conf_thread = AST_PTHREADT_NULL;
+
+   return NULL;
+}
+
+/******************************************************************************
+ *        NAME: kill_conference_thread()
+ * DESCRIPTION:
+ *
+ *****************************************************************************/
+void kill_conference_thread(ast_vars *chan_vars)
+{
+   if (chan_vars->conf_thread > AST_PTHREADT_NULL) {
+      while (pthread_kill(chan_vars->conf_thread, SIGURG) == 0)
+         sched_yield();
+      pthread_join(chan_vars->conf_thread, NULL);
+   }
+   chan_vars->conf_thread = AST_PTHREADT_STOP;
+}
+
+
+/******************************************************************************
+ *        NAME: get_digits()
+ * DESCRIPTION: 
+ *              
+ *****************************************************************************/
+void get_digits(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars)
+{
+   reply_ast trs_reply;
+
+	if (trs_cmd.cmd_id == GETDIX)
+	{
+		if (ast_bridged_channel(chan))
+		{
+			post_error(trs_cmd, chan_vars, GET_DIGITS_COMPLETED, RESOURCE_ERROR);
+			return;
+		}
+      if (chan_vars->dtmf == 0)
+	   {
+		   post_error(trs_cmd, chan_vars, GET_DIGITS_COMPLETED, NO_CAPABILITIES_AVAILABLE);
+		   if (option_verbose >= 3)
+		               ast_verbose(VERBOSE_PREFIX_3 "No DTMF capabilites on %s\n", ast_channel_name(chan));
+		   return;
+	   }
+		if (!chan_vars->stream.enabled && trs_cmd.al_int_val1 == STREAM_START)
+		{
+         memset(chan_vars->digit_buffer, 0, sizeof(chan_vars->digit_buffer));
+
+         chan_vars->stream.enabled = 1;
+         chan_vars->stream.cmd_cnt = trs_cmd.cmd_cnt;
+         chan_vars->stream.con_id = trs_cmd.con_id;
+         chan_vars->stream.edp_id = trs_cmd.edp_id;
+         memset(&trs_reply, 0, sizeof(reply_ast));
+	      trs_reply.cmd_cnt = trs_cmd.cmd_cnt;
+	      trs_reply.con_id = trs_cmd.con_id;
+	      trs_reply.sender = trs_cmd.edp_id;
+	      trs_reply.event = GET_DIGITS_COMPLETED;
+      	trs_reply.error = FALSE;
+			trs_reply.body.terminator.digit_streaming_started = 1;
+         sprintf(trs_reply.body.digit_result.digits, "\"\"");
+		   trs_reply.body.digit_result.confidence = 100;
+
+			asteriskSendReply(&trs_reply, chan_vars);
+		}
+		else if (chan_vars->stream.enabled && (trs_cmd.al_int_val1 == STREAM_STOP || trs_cmd.al_int_val1 == STREAM_UNLOAD))
+		{
+         memset(&chan_vars->stream, 0, sizeof(chan_vars->stream));
+         memset(&trs_reply, 0, sizeof(reply_ast));
+	      trs_reply.cmd_cnt = trs_cmd.cmd_cnt;
+	      trs_reply.con_id = trs_cmd.con_id;
+	      trs_reply.sender = trs_cmd.edp_id;
+	      trs_reply.event = GET_DIGITS_COMPLETED;
+      	trs_reply.error = FALSE;
+         sprintf(trs_reply.body.digit_result.digits, "\"\"");
+		   trs_reply.body.digit_result.confidence = 100;
+         if (trs_cmd.al_int_val1 == STREAM_STOP)
+			   trs_reply.body.terminator.digit_streaming_stopped = 1;
+         else if (trs_cmd.al_int_val1 == STREAM_UNLOAD)
+			   trs_reply.body.terminator.digit_streaming_unloaded = 1;
+
+			asteriskSendReply(&trs_reply, chan_vars);			
+		}
+		else if (trs_cmd.al_int_val1 == STREAM_LOAD)
+		{
+         memset(&trs_reply, 0, sizeof(reply_ast));
+	      trs_reply.cmd_cnt = trs_cmd.cmd_cnt;
+	      trs_reply.con_id = trs_cmd.con_id;
+	      trs_reply.sender = trs_cmd.edp_id;
+	      trs_reply.event = GET_DIGITS_COMPLETED;
+      	trs_reply.error = FALSE;
+			trs_reply.body.terminator.digit_streaming_loaded = 1;
+         sprintf(trs_reply.body.digit_result.digits, "\"\"");
+		   trs_reply.body.digit_result.confidence = 100;
+
+			asteriskSendReply(&trs_reply, chan_vars);
+		}
+      else
+      {
+		   post_error(trs_cmd, chan_vars, GET_DIGITS_COMPLETED, RESOURCE_ERROR);
+		   if (option_verbose >= 3)
+		               ast_verbose(VERBOSE_PREFIX_3 "DTMF capabilites already configured on %s\n", ast_channel_name(chan));
+		   return;
+      }
+	}
+	else
+	{
+      //removed  || chan_vars->conference.id
+		if (ast_bridged_channel(chan) || chan_vars->action.type != NO_ACTION)
+		{
+		   ast_log(LOG_NOTICE, "device busy on ch %03d - %s\n",trs_cmd.ch_index, ast_channel_name(chan));
+
+			post_error(trs_cmd, chan_vars, GET_DIGITS_COMPLETED, RESOURCE_ERROR);
+			return;
+		}
+	   else if (chan_vars->dtmf == 0)
+	   {
+		   post_error(trs_cmd, chan_vars, GET_DIGITS_COMPLETED, NO_CAPABILITIES_AVAILABLE);
+		   if (option_verbose >= 3)
+		               ast_verbose(VERBOSE_PREFIX_3 "No DTMF capabilites on %s\n", ast_channel_name(chan));
+		   return;
+	   }
+		build_action(chan_vars, &trs_cmd, ACTION_GETDIG, GET_DIGITS_COMPLETED);
+      build_terminator(chan, chan_vars, trs_cmd);
+   }
+}
+
+/******************************************************************************
+ *        NAME: play_announcement()
+ * DESCRIPTION: 
+ *              
+ *****************************************************************************/
+void play_announcement(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars)
+{
+	int ret_evt = 0, ret_error = RESOURCE_ERROR;
+	char stringp[256];
+	struct ast_channel *rtsp_chan;
+   FILE *fp;
+
+	switch (trs_cmd.cmd_id)
+	{
+		case PLAANN: ret_evt = PLAY_ANNOUNCEMENT_COMPLETED; break;
+		case PLADAT: ret_evt = PLAY_DATA_COMPLETED; break;
+		case PLAIND: ret_evt = PLAY_INDEX_FILE_COMPLETED; break;
+		case TTSPRO: ret_evt = TTS_PROCESS_COMPLETED; break;
+		default: ret_evt = PLAY_ANNOUNCEMENT_COMPLETED; //shouldn't happen
+	}
+   //Used to be sprintf buf http get files with %2f became 0.000000  
+   strncpy(stringp, trs_cmd.prompt_id, sizeof(stringp));
+
+   if (chan_vars->conference.id) //do it using ConferenceManager after adding support
+   {
+      if (!strncmp(stringp, "rtsp://", 7))
+      {
+         ast_log(LOG_WARNING, "Play to conference prompt not supported %s on chan %s\n", (char *)trs_cmd.prompt_id, ast_channel_name(chan));
+         post_error(trs_cmd, chan_vars, ret_evt, ret_error);
+         return;
+      }
+      // IF PROMPT ID DEFINED (NOT URL)
+		if (strchr(stringp, '.') != NULL)	*strrchr(stringp, '.') = '\0';
+		while (strchr(stringp, '\\') != NULL) *strchr(stringp, '\\') = '/';
+
+      if (ast_test_flag(ast_channel_inoflags(chan), MEETME_DO_PLAY))
+      {
+         ast_log(LOG_WARNING, "Play to conference busy on chan %s\n", ast_channel_name(chan));
+         post_error(trs_cmd, chan_vars, ret_evt, ret_error);
+         return;
+      }
+      ast_clear_flag(ast_channel_inoflags(chan), MEETME_STOP_PLAY);
+      ast_channel_conf_playann_set(chan, stringp);
+      ast_set_flag(ast_channel_inoflags(chan), MEETME_DO_PLAY);
+		return;
+   }
+   
+   if (ast_bridged_channel(chan) || chan_vars->action.type != NO_ACTION)
+   {
+      ast_log(LOG_NOTICE, "Channel busy %s\n", ast_channel_name(chan));
+      post_error(trs_cmd, chan_vars, ret_evt, ret_error);
+      return;
+   }
+	ast_stopstream(chan);
+
+	// GET STREAM FROM RTSP MEDIA SERVER (e.g. Apple Darwin Streaming Server)
+	if (strncmp(stringp, "rtsp://", 7) == 0)
+	{
+	   if ((rtsp_chan = get_rtsp_chan(chan, stringp)) != NULL)
+		{
+		// RTSP CHANNEL DIALING INSTRUCTIONS END HERE 
+         if (ast_channel_setoption(rtsp_chan, 1, stringp, 1, 0) == 0)
+		{
+         build_action(chan_vars, &trs_cmd, ACTION_PLAANN, ret_evt);
+			if (trs_cmd.clear_dig_buf) 
+            memset(chan_vars->digit_buffer, 0, sizeof(chan_vars->digit_buffer));
+			chan_vars->action.cs[0] = chan;
+			chan_vars->action.cs[1] = rtsp_chan;
+			chan_vars->action.rtsp_play_duration = atof(ast_channel_context(rtsp_chan));
+            strncpy(chan_vars->action.FILE_URL, stringp, sizeof(chan_vars->action.FILE_URL));
+         build_terminator(chan, chan_vars, trs_cmd);
+   		return;
+		}
+	   }
+      // TODO: Should do hangup and free??
+      // ast_hangup(tmp->chan);
+      // free(tmp);
+	}
+	else
+	{
+      // IF PROMPT ID DEFINED (NOT URL)
+		if (strchr(stringp, '.') != NULL) *strrchr(stringp, '.') = '\0';
+		while (strchr(stringp, '\\') != NULL) *strchr(stringp, '\\') = '/';
+
+      // IF PROMPT ID IS AN IVX FILE (ASTERISK STANDARD :P)
+      if (!strncmp(trs_cmd.prompt_id + strlen(trs_cmd.prompt_id) - 4, ".ivx", 4))
+      {
+         if ((fp = fopen( trs_cmd.prompt_id, "rb" )) != NULL)
+         {
+			   build_action(chan_vars, &trs_cmd, ACTION_PLAANN, ret_evt);
+			   if (trs_cmd.clear_dig_buf) 
+               memset(chan_vars->digit_buffer, 0, sizeof(chan_vars->digit_buffer));
+            chan_vars->action.fp = fp;
+			   strncpy(chan_vars->action.FILE_URL, trs_cmd.prompt_id, sizeof(chan_vars->action.FILE_URL));
+            build_terminator(chan, chan_vars, trs_cmd);
+			   return;
+         }
+         else ret_error = INVALID_VOICE_FILE_PARAMETER;
+      }
+      // PROMPT ID IS A NORMAL FILE
+      else 
+      {
+         if (ast_streamfile(chan, stringp, ast_channel_language(chan)) == 0)
+		   {
+			   build_action(chan_vars, &trs_cmd, ACTION_PLAANN, ret_evt);
+			   if (trs_cmd.clear_dig_buf) 
+               memset(chan_vars->digit_buffer, 0, sizeof(chan_vars->digit_buffer));
+			   strncpy(chan_vars->action.FILE_URL, trs_cmd.prompt_id, sizeof(chan_vars->action.FILE_URL));
+            build_terminator(chan, chan_vars, trs_cmd);
+			   return;
+		   }
+      }
+	}
+}
+
+/******************************************************************************
+ *        NAME: record_voice()
+ * DESCRIPTION: 
+ *              
+ *****************************************************************************/
+void record_voice(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars)
+{
+	char temp[256], *ext, *str;
+	struct ast_channel *rtsp_chan;
+	struct ast_filestream *s = NULL;
+   FILE *fp = NULL;
+   int ret_error = RESOURCE_ERROR;
+
+	if (ast_bridged_channel(chan) || chan_vars->action.type != NO_ACTION || chan_vars->conference.id)
+	{
+	   ast_log(LOG_NOTICE, "Channel busy %s\n", ast_channel_name(chan));
+		post_error(trs_cmd, chan_vars, RECORD_VOICE_COMPLETED, RESOURCE_ERROR);
+		return;
+	}
+	while(strchr(trs_cmd.prompt_id, '\\') != NULL) *strchr(trs_cmd.prompt_id, '\\') = '/';
+
+	// PROMPT ID IS A RTSP URL
+	if (strncmp(trs_cmd.prompt_id, "rtsp", 4) == 0)
+	{
+      if ((rtsp_chan = get_rtsp_chan(chan, trs_cmd.prompt_id)) != NULL)
+		{
+         if (ast_channel_setoption(rtsp_chan, 4, trs_cmd.prompt_id, 1, 0) == 0)
+      {
+		   build_action(chan_vars, &trs_cmd, ACTION_RECVOI, RECORD_VOICE_COMPLETED);
+		   chan_vars->action.cs[0] = chan;
+		   chan_vars->action.cs[1] = rtsp_chan;
+            strncpy(chan_vars->action.FILE_URL, trs_cmd.prompt_id, sizeof(chan_vars->action.FILE_URL));
+		   if (trs_cmd.clear_dig_buf) chan_vars->digit_buffer[0] = '\0';
+         build_terminator(chan, chan_vars, trs_cmd);
+		   return;
+      }
+      // TODO: Should do hangup and free??
+      // ast_hangup(tmp->chan);
+      // free(tmp);
+      }
+	}
+	else
+	{
+   	strncpy(temp, trs_cmd.prompt_id, sizeof(temp));
+
+      if ((str = strrchr(temp, '.')) == NULL)
+      {
+			ast_log(LOG_WARNING, "No extension found\n");
+			post_error(trs_cmd, chan_vars, RECORD_VOICE_COMPLETED, RESOURCE_ERROR);
+			return;
+		}
+      *str = '\0';
+      ext = str + 1;
+
+		ast_stopstream(chan);
+
+      /* define if tone initiated record will be set */
+      if(trs_cmd.al_int_val2 == 1) //beep = RM_TONE; 
+      {
+         ast_streamfile(chan, "bip", ast_channel_language(chan));
+         ast_waitstream(chan, "");
+         ast_stopstream(chan);
+      }
+
+      // Now the recording starts 
+      //If NOT an IVX file
+      if (strcmp(ext, "ivx"))
+      {
+   	   if (trs_cmd.cmd_id == RECVOX && trs_cmd.al_long_val1 == OFFSET_END) 
+            s = ast_writefile(temp, ext, NULL, O_CREAT|O_APPEND|O_WRONLY , 0, 0666);
+		   else s = ast_writefile(temp, ext, NULL, O_CREAT|O_TRUNC|O_WRONLY , 0, 0666);
+      }
+      // If IVX file
+      else
+      {
+   	   if (trs_cmd.cmd_id == RECVOX && trs_cmd.al_long_val1 == OFFSET_END) 
+            fp = fopen( trs_cmd.prompt_id, "ab" );
+		   else fp = fopen( trs_cmd.prompt_id, "wb" );
+         if (!fp) ret_error = INVALID_VOICE_FILE_PARAMETER;
+      }
+		if (s != NULL || fp != NULL)
+		{
+			build_action(chan_vars, &trs_cmd, ACTION_RECVOI, RECORD_VOICE_COMPLETED);
+	   	if (trs_cmd.clear_dig_buf) chan_vars->digit_buffer[0] = '\0';
+         strncpy(chan_vars->action.FILE_URL, trs_cmd.prompt_id, sizeof(chan_vars->action.FILE_URL));
+			chan_vars->action.record = s;
+         chan_vars->action.fp = fp;
+         build_terminator(chan, chan_vars, trs_cmd);
+			return;
+		}
+	}
+	post_error(trs_cmd, chan_vars, RECORD_VOICE_COMPLETED, ret_error);
+}
+
+/******************************************************************************
+ *        NAME: route_endpoint()
+ * DESCRIPTION: 
+ *              
+ *****************************************************************************/
+void route_endpoint(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars)
+{
+	struct ast_channel *rch;
+
+   //_DebugSay(VOICE, INFO, 5, 0, "[ASTERISK] route_endpoint() called");
+   if ((rch = (struct ast_channel *)trs_cmd.in_ast_chan) == NULL)
+	{
+		post_error(trs_cmd, chan_vars, ROUTE_ENDPOINT_COMPLETED, RESOURCE_ERROR);
+		ast_log(LOG_WARNING, "rch is NULL %s\n", ast_channel_name(chan));
+		return;
+	}
+	if (ast_bridged_channel(chan) || chan_vars->action.type != NO_ACTION || chan_vars->conference.id)
+	{
+		post_error(trs_cmd, chan_vars, ROUTE_ENDPOINT_COMPLETED, RESOURCE_ERROR);
+		ast_log(LOG_NOTICE, "device busy on ch %03d - %s\n", trs_cmd.ch_index, ast_channel_name(chan));
+		return;
+	}
+   if (ast_channel_make_compatible(chan, rch))
+	{
+		post_error(trs_cmd, chan_vars, ROUTE_ENDPOINT_COMPLETED, RESOURCE_ERROR);
+		ast_log(LOG_NOTICE, "channels not compatible on %s\n", ast_channel_name(chan));
+		return;
+	}
+
+	// Keep track of bridge 
+	ast_channel_internal_bridged_channel_set(chan, rch);
+	ast_channel_internal_bridged_channel_set(rch, chan);
+
+	manager_event(EVENT_FLAG_CALL, "Link", 
+			"Channel1: %s\r\n"
+			"Channel2: %s\r\n"
+			"Uniqueid1: %s\r\n"
+			"Uniqueid2: %s\r\n",
+			ast_channel_name(chan), ast_channel_name(rch), ast_channel_uniqueid(chan), ast_channel_uniqueid(rch));
+
+	build_action(chan_vars, &trs_cmd, ACTION_ROUEND, ROUTE_ENDPOINT_COMPLETED);
+
+   //Must be after build_action
+   chan_vars->action.cs[0] = chan;
+	chan_vars->action.cs[1] = rch;
+
+   //This makes a native bridge if canreinvite = yes
+   //ast_rtp_make_compatible(chan, rch, 1);
+   //ast_rtp_make_compatible(rch, chan, 1);
+
+	if (trs_cmd.rouend_param.ret_key_active) chan_vars->action.bridge_retkey = trs_cmd.rouend_param.ret_key[0];
+	else chan_vars->action.bridge_retkey = '\0';
+
+	chan_vars->action.record = NULL;
+
+	build_reply(chan_vars);
+	asteriskSendReply(&chan_vars->trs_reply, chan_vars);
+}
+
+//--- AUX FUNCTION -------------------------------------------------------------
+/******************************************************************************
+ *        NAME: get_rtsp_chan()
+ * DESCRIPTION:
+ *
+ *****************************************************************************/
+static struct ast_channel *get_rtsp_chan(struct ast_channel *chan, char *rtsp_address)
+{
+   long res;
+   int cause, to=10000;
+   struct inast_localuser *outgoing=NULL, *tmp = NULL;
+   struct ast_channel *rtsp_chan;
+
+   if ((tmp = calloc(1, sizeof(struct inast_localuser))) == NULL)
+   {
+      ast_log(LOG_WARNING, "Out of memory\n");
+      return NULL;
+   }
+
+   // chan->nativeformats should be jointcapability???
+   if ((tmp->chan = ast_request("RTSP", ast_channel_jointcapability(chan), NULL, (void *)ast_channel_name(chan), &cause)) == NULL)
+   {
+      ast_log(LOG_NOTICE, "Unable to create channel of type RTSP\n");
+      free(tmp);
+      return NULL;
+   }
+   ast_channel_appl_set(tmp->chan, "WMSApp");
+   ast_channel_data_set(tmp->chan, "(Outgoing Line)");
+   ast_channel_language_set(tmp->chan, ast_channel_language(chan));
+   ast_channel_adsicpe_set(tmp->chan, ast_channel_adsicpe(chan));
+
+   // Place the call, but don't wait on the answer
+   if ((res = ast_call(tmp->chan, rtsp_address, 0)))
+   {
+      ast_log(LOG_WARNING, "Unable to place call on chan %s\n", ast_channel_name(chan));
+      ast_hangup(tmp->chan);
+      free(tmp);
+      return NULL;
+   }
+   tmp->stillgoing = -1;
+   tmp->next = outgoing;
+   outgoing = tmp;
+
+   if ((rtsp_chan = wait_for_answer(chan, outgoing, &to)) == NULL)
+   {
+      if (to) res = -1; // Musta gotten hung up
+      else res = 0; // Nobody answered, next please?
+
+      ast_log(LOG_WARNING, "Wait for answer returned error: %ld\n", res);
+      ast_hangup(tmp->chan);
+      free(tmp);
+
+      return NULL;
+   }
+   return rtsp_chan;
+}
+
+/******************************************************************************
+ *        NAME: wait_for_answer()
+ * DESCRIPTION: 
+ *              
+ *****************************************************************************/
+static struct ast_channel *wait_for_answer(struct ast_channel *in,
+   struct inast_localuser *outgoing, int *to)
+{
+	struct inast_localuser *o;
+	int found;
+	int numlines;
+	int numbusies = 0;
+	struct ast_frame *f;
+	struct ast_channel *peer = NULL;
+	struct ast_channel *watchers[256];
+	int pos;
+	int single;
+	struct ast_channel *winner;
+	
+   single = (outgoing && !outgoing->next);
+	
+   if (!in || !ast_channel_tech(in)) return NULL;
+
+	if (single) 
+   {
+		// Turn off hold music, etc 
+		ast_indicate(in, -1);
+		// If we are calling a single channel, make them compatible for in-band tone purpose 
+		ast_channel_make_compatible(outgoing->chan, in);
+	}
+	while(*to && !peer) 
+   {
+		o = outgoing;
+		found = -1;
+		pos = 1;
+		numlines = 0;
+		watchers[0] = in;
+		while(o) 
+      {
+			// Keep track of important channels 
+			if (o->stillgoing && o->chan) 
+         {
+				watchers[pos++] = o->chan;
+				found = 1;
+			}
+			o = o->next;
+			numlines++;
+		}
+		if (found < 0) 
+      {
+			*to = 0;
+			return NULL;
+		}
+		winner = ast_waitfor_n(watchers, pos, to);
+		o = outgoing;
+		while(o) 
+      {
+			if (o->stillgoing && o->chan && (ast_channel_state(o->chan) == AST_STATE_UP))
+         {
+				if (!peer) 
+            {
+					peer = o->chan;
+
+				}
+         }
+			else if (o->chan && (o->chan == winner)) 
+         {
+            if ((f = ast_read(winner)))
+            {
+					if (f->frametype == AST_FRAME_CONTROL) 
+               {
+                  switch(f->subclass.integer)
+                  {
+					    case AST_CONTROL_ANSWER:
+							// This is our guy if someone answered. 
+							if (!peer) 
+                     {
+								peer = o->chan;
+							}
+							break;
+						case AST_CONTROL_BUSY:
+						   ast_channel_hangupcause_set(in, ast_channel_hangupcause(o->chan));
+							ast_hangup(o->chan);
+							o->chan = NULL;
+							o->stillgoing = 0;
+							numbusies++;
+							break;
+						case AST_CONTROL_CONGESTION:
+						   ast_channel_hangupcause_set(in, ast_channel_hangupcause(o->chan));
+							ast_hangup(o->chan);
+							o->chan = NULL;
+							o->stillgoing = 0;
+							numbusies++;
+							break;
+						case AST_CONTROL_RINGING:
+							break;
+						case AST_CONTROL_PROGRESS:
+							ast_indicate(in, AST_CONTROL_PROGRESS);
+							break;
+						case AST_CONTROL_OFFHOOK:
+							// Ignore going off hook 
+							break;
+						case -1:
+							break;
+						default:
+                     ast_log(LOG_DEBUG, "Dunno what to do with control type %d\n", f->subclass.integer);
+						}
+					} 
+               else if (single && (f->frametype == AST_FRAME_VOICE))
+               {
+						if (ast_write(in, f)) 
+							ast_log(LOG_WARNING, "Unable to forward frame\n");
+					} 
+               else if (single && (f->frametype == AST_FRAME_IMAGE))
+               {
+						if (ast_write(in, f))
+							ast_log(LOG_WARNING, "Unable to forward image\n");
+					}
+					if (f != NULL) ast_frfree(f);
+				} 
+            else 
+            {
+               ast_channel_hangupcause_set(in, ast_channel_hangupcause(o->chan));
+					ast_hangup(o->chan);
+					o->chan = NULL;
+					o->stillgoing = 0;
+				}
+			}
+			o = o->next;
+		}
+		if (winner == in) 
+      {
+			f = ast_read(in);
+
+         if (!f || ((f->frametype == AST_FRAME_CONTROL) && (f->subclass.integer == AST_CONTROL_HANGUP)))
+         {
+				// Got hung up
+				*to=-1;
+				return NULL;
+			}
+         if (f && (f->frametype == AST_FRAME_DTMF) &&
+            (f->subclass.integer == '*'))
+         {
+				*to=0;
+				return NULL;
+			}
+			if (single && ((f->frametype == AST_FRAME_VOICE) || (f->frametype == AST_FRAME_DTMF)))  
+         {
+				if (ast_write(outgoing->chan, f))
+					ast_log(LOG_WARNING, "Unable to forward voice\n");
+				if (f != NULL) ast_frfree(f);
+			}
+		}
+	}
+	return peer;
+}
+
+
+
+
+
+
+
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/apps/wms_inoapi.h asterisk-11.3.0.p000/apps/wms_inoapi.h
--- asterisk-base-11.3.0/apps/wms_inoapi.h	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-11.3.0.p000/apps/wms_inoapi.h	2013-05-13 14:00:47.692437811 +0100
@@ -0,0 +1,40 @@
+/*******************************************************************************
+ *        FILE: 
+ * DESCRIPTION: 
+ *              
+ * 
+ * $Archive: $
+ * $Revision: 1.0 $
+ * $Author: $
+ * $History: $
+ * 
+ * 
+ *   Copyright (c) 2005 PT Inovação SA. All Rights Reserved
+ ******************************************************************************/
+#ifndef ASTERISK_INOAPI_H
+#define ASTERISK_INOAPI_H
+
+/********************************************************************************
+*
+* FUNCTION PROTOTYPES
+*
+*********************************************************************************/
+void accept_icall(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars);
+void attach_capabilities(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars);
+void connect_call(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars);
+void exec_asterisk(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars);
+void get_digits(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars);
+void play_announcement(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars);
+void play_digits(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars);
+void record_voice(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars);
+void reject_icall(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars);
+void release_endpoint(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars);
+void reset_endpoint(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars);
+void route_endpoint(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars);
+void stop_operation(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars);
+void conference_call(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars);
+
+//- Aux functions
+void kill_conference_thread(ast_vars *chan_vars);
+
+#endif 
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/include/asterisk/channel.h asterisk-11.3.0.p000/include/asterisk/channel.h
--- asterisk-base-11.3.0/include/asterisk/channel.h	2013-05-02 16:10:15.704437749 +0100
+++ asterisk-11.3.0.p000/include/asterisk/channel.h	2013-05-13 14:00:36.124437583 +0100
@@ -165,6 +165,30 @@
 #define AST_GENERATOR_FD	(AST_MAX_FDS-4)	/*!< used by generator */
 #define AST_JITTERBUFFER_FD	(AST_MAX_FDS-5)	/*!< used by generator */
 
+   /* sip_extended_params support */
+#define AST_MAX_PARAMS        512
+#define AST_NUM_ACCEPTED_CODECS   20
+#define AST_AUDIO_SDP             0
+#define AST_VIDEO_SDP             1
+
+#define MEETME_DO_PLAY        (1 << 0)
+#define MEETME_STOP_PLAY      (1 << 1)
+#define MEETME_MUTE_USER      (1 << 2)
+#define MEETME_UNMUTE_USER    (1 << 3)
+#define MEETME_MUTE_ALL       (1 << 4)
+#define MEETME_UNMUTE_ALL     (1 << 5)
+#define MEETME_BROADCAST_ME   (1 << 6)
+#define MEETME_BROADCASTING   (1 << 7)
+#define MEETME_STOP_BROADCAST (1 << 8)
+#define MEETME_LOCK           (1 << 9)
+#define MEETME_UNLOCK         (1 << 10)
+#define MEETME_KICK_USERS     (1 << 11)
+#define MEETME_KICK_LAST      (1 << 12)
+#define MEETME_DO_RECORD      (1 << 13)
+
+#define EXEC_APP_EXIT         (1 << 17)
+#define SIP_GOT_REINVITE      (1 << 18)
+
 enum ast_bridge_result {
 	AST_BRIDGE_COMPLETE = 0,
 	AST_BRIDGE_FAILED = -1,
@@ -206,6 +230,64 @@
 	AST_PARTY_CHAR_SET_ISO10646_UTF_8STRING = 9,
 };
 
+/*! \brief Manager Originate extra parameters */
+struct originate_params {
+   char extradata[2048];
+   char callerid[AST_MAX_EXTENSION];
+   char rtpa_ip[20];
+   unsigned short rtpa_port;
+   char rtpv_ip[20];
+   unsigned short rtpv_port;
+   int privacy;
+};
+
+// Codec structures to pass to inovox
+typedef struct
+{
+   int         payload;
+   unsigned long long type;
+   char  fmtp[128];
+   char  rtpmap[64];
+} SDPFormat;
+
+typedef struct
+{
+   SDPFormat codec[AST_NUM_ACCEPTED_CODECS];
+   unsigned int bandwidth;
+   int num;
+} SDPCodec;
+
+typedef struct
+{
+   SDPCodec media[2];
+   unsigned int bandwidth;
+   unsigned int framerate;
+   unsigned int dtmfpayload;
+} SDPMedia;
+
+/* SRMA ports for SDP */
+typedef struct
+{
+   char rtpa_ip[20];
+   unsigned short rtpa_port;
+   char rtpv_ip[20];
+   unsigned short rtpv_port;
+}AST_SMRA_ATTRIB;
+
+/*! \brief Structure for all kinds of caller ID identifications.
+ * \note All string fields here are malloc'ed, so they need to be
+ * freed when the structure is deleted.
+ * Also, NULL and "" must be considered equivalent.
+ */
+struct ast_callerid {
+   char *cid_ani_url;
+   char *cid_dnis_url;
+   char *cid_req_uri;
+   char *callid;
+   char *cid_asserted_id;
+   char *cid_privacy;
+};
+
 /*!
  * \since 1.8
  * \brief Information needed to specify a name in a call.
@@ -1312,7 +1394,7 @@
  * to know if the call was answered or not.
  */
 struct ast_channel *__ast_request_and_dial(const char *type, struct ast_format_cap *cap, const struct ast_channel *requestor, const char *addr,
-	int timeout, int *reason, const char *cid_num, const char *cid_name, struct outgoing_helper *oh);
+	int timeout, int *reason, const char *cid_num, const char *cid_name, struct outgoing_helper *oh, struct originate_params *origparm);
 
 /*!
  * \brief Forwards a call to a new channel specified by the original channel's call_forward str.  If possible, the new forwarded channel is created and returned while the original one is terminated.
@@ -3811,6 +3893,41 @@
 void ast_channel_outsmpl_set(struct ast_channel *chan, unsigned long value);
 void *ast_channel_generatordata(const struct ast_channel *chan);
 void ast_channel_generatordata_set(struct ast_channel *chan, void *value);
+
+const char *ast_channel_url_params(const struct ast_channel *chan);
+void ast_channel_url_params_set(struct ast_channel *chan, char *value);
+const char *ast_channel_conf_playann(const struct ast_channel *chan);
+void ast_channel_conf_playann_set(struct ast_channel *chan, char *value);
+const char *ast_channel_conf_record(const struct ast_channel *chan);
+void ast_channel_conf_record_set(struct ast_channel *chan, char *value);
+const char *ast_channel_conf_record_format(const struct ast_channel *chan);
+void ast_channel_conf_record_format_set(struct ast_channel *chan, char *value);
+const char *ast_channel_extradata(const struct ast_channel *chan);
+void ast_channel_extradata_set(struct ast_channel *chan, char *value);
+const AST_SMRA_ATTRIB *ast_channel_server_smra_attrib(const struct ast_channel *chan);
+void ast_channel_server_smra_attrib_set(struct ast_channel *chan, AST_SMRA_ATTRIB *server_smra_attrib);
+const AST_SMRA_ATTRIB *ast_channel_client_smra_attrib(const struct ast_channel *chan);
+void ast_channel_client_smra_attrib_set(struct ast_channel *chan, AST_SMRA_ATTRIB *client_smra_attrib);
+char *ast_channel_cid_ani(const struct ast_channel *chan);
+void ast_channel_cid_ani_set(struct ast_channel *chan, char *value);
+char *ast_channel_cid_dnis(const struct ast_channel *chan);
+void ast_channel_cid_dnis_set(struct ast_channel *chan, char *value);
+char *ast_channel_cid_asserted_id(const struct ast_channel *chan);
+void ast_channel_cid_asserted_id_set(struct ast_channel *chan, char *value);
+char *ast_channel_cid_callid(const struct ast_channel *chan);
+void ast_channel_cid_callid_set(struct ast_channel *chan, char *value);
+char *ast_channel_cid_privacy(const struct ast_channel *chan);
+void ast_channel_cid_privacy_set(struct ast_channel *chan, char *value);
+const struct ast_format_cap *ast_channel_jointcapability(const struct ast_channel *chan);
+void ast_channel_jointcapability_set(struct ast_channel *chan, struct ast_format_cap *value);
+const SDPMedia *ast_channel_client_sdp(const struct ast_channel *chan);
+void ast_channel_client_sdp_set(struct ast_channel *chan, SDPMedia *value);
+int ast_channel_defhangcause(const struct ast_channel *chan);
+void ast_channel_defhangcause_set(struct ast_channel *chan, int value);
+struct ast_flags *ast_channel_inoflags(const struct ast_channel *chan);
+int ast_channel_charge_type(const struct ast_channel *chan);
+void ast_channel_charge_type_set(struct ast_channel *chan, int value);
+
 void *ast_channel_music_state(const struct ast_channel *chan);
 void ast_channel_music_state_set(struct ast_channel *chan, void *value);
 void *ast_channel_tech_pvt(const struct ast_channel *chan);
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/include/asterisk/format.h asterisk-11.3.0.p000/include/asterisk/format.h
--- asterisk-base-11.3.0/include/asterisk/format.h	2013-05-02 16:10:15.944437807 +0100
+++ asterisk-11.3.0.p000/include/asterisk/format.h	2013-05-13 14:00:37.456937737 +0100
@@ -101,6 +101,13 @@
 	AST_FORMAT_SLINEAR192       = 27 + AST_FORMAT_TYPE_AUDIO,
 	AST_FORMAT_SPEEX32          = 28 + AST_FORMAT_TYPE_AUDIO,
 	AST_FORMAT_CELT             = 29 + AST_FORMAT_TYPE_AUDIO,
+	//- New Audio codecs ---
+	/*! AMR-NB */
+	AST_FORMAT_AMRNB            = 30 + AST_FORMAT_TYPE_AUDIO,
+	/*! AMR-WB */
+	AST_FORMAT_AMRWB            = 31 + AST_FORMAT_TYPE_AUDIO, // Asterisk supports on passthrough mode only
+	/*! AAC */
+	AST_FORMAT_MPEG4_AUDIO      = 32 + AST_FORMAT_TYPE_AUDIO, // Asterisk supports on passthrough mode only
 
 	/*! H.261 Video */
 	AST_FORMAT_H261             = 1 + AST_FORMAT_TYPE_VIDEO,
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/include/asterisk/frame.h asterisk-11.3.0.p000/include/asterisk/frame.h
--- asterisk-base-11.3.0/include/asterisk/frame.h	2013-05-02 16:10:15.920437809 +0100
+++ asterisk-11.3.0.p000/include/asterisk/frame.h	2013-05-13 14:00:37.432937733 +0100
@@ -233,6 +233,14 @@
 /*! Reject link request */
 #define AST_HTML_LINKREJECT	20
 
+/* TEXT subclasses */
+/*! SIP MESSAGE */
+#define AST_TEXT_SIP           1
+/*! Zaptel message */
+#define AST_TEXT_ZAP           2
+/*! SIP INFO w/ XML */
+#define AST_TEXT_XML           3
+
 enum ast_control_frame_type {
 	AST_CONTROL_HANGUP = 1,			/*!< Other end has hungup */
 	AST_CONTROL_RING = 2,			/*!< Local ring */
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/include/asterisk/options.h asterisk-11.3.0.p000/include/asterisk/options.h
--- asterisk-base-11.3.0/include/asterisk/options.h	2013-05-02 16:10:15.744437812 +0100
+++ asterisk-11.3.0.p000/include/asterisk/options.h	2013-05-13 14:00:36.160437796 +0100
@@ -100,6 +100,18 @@
 	AST_OPT_FLAG_GENERIC_PLC = (1 << 30),
 };
 
+/*! \ingroup main_options */
+enum ast_option_flags2 {
+   /*! Enable SMRA Media */
+   AST_OPT_FLAG2_USE_SMRA = (1 << 0),
+   /*! Send 180 ringing */
+   AST_OPT_FLAG2_SEND_RINGING = (1 << 1),
+   /*! Call Status = REJECT */
+   AST_OPT_FLAG2_REJECT_MODE = (1 << 2),
+};
+#define AST_DEFAULT_OPTIONS2 0
+
+
 /*! These are the options that set by default when Asterisk starts */
 #if (defined(HAVE_DAHDI_VERSION) && HAVE_DAHDI_VERSION >= 230)
 #define AST_DEFAULT_OPTIONS AST_OPT_FLAG_TRANSCODE_VIA_SLIN | AST_OPT_FLAG_INTERNAL_TIMING
@@ -138,7 +150,11 @@
 #define ast_opt_hide_connect		ast_test_flag(&ast_options, AST_OPT_FLAG_HIDE_CONSOLE_CONNECT)
 #define ast_opt_lock_confdir		ast_test_flag(&ast_options, AST_OPT_FLAG_LOCK_CONFIG_DIR)
 #define ast_opt_generic_plc         ast_test_flag(&ast_options, AST_OPT_FLAG_GENERIC_PLC)
+#define ast_opt_use_smra               ast_test_flag(&ast_options2, AST_OPT_FLAG2_USE_SMRA)
+#define ast_opt_send_ringing           ast_test_flag(&ast_options2, AST_OPT_FLAG2_SEND_RINGING)
+#define ast_opt_reject_mode             ast_test_flag(&ast_options2, AST_OPT_FLAG2_REJECT_MODE)
 
+extern struct ast_flags ast_options2;
 extern struct ast_flags ast_options;
 
 enum ast_compat_flags {
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/include/asterisk/pbx.h asterisk-11.3.0.p000/include/asterisk/pbx.h
--- asterisk-base-11.3.0/include/asterisk/pbx.h	2013-05-02 16:10:16.028446201 +0100
+++ asterisk-11.3.0.p000/include/asterisk/pbx.h	2013-05-13 14:00:42.869187949 +0100
@@ -1078,7 +1078,7 @@
 
 /*! Synchronously or asynchronously make an outbound call and send it to a
    particular application with given extension */
-int ast_pbx_outgoing_app(const char *type, struct ast_format_cap *cap, const char *addr, int timeout, const char *app, const char *appdata, int *reason, int sync, const char *cid_num, const char *cid_name, struct ast_variable *vars, const char *account, struct ast_channel **locked_channel);
+int ast_pbx_outgoing_app(const char *type, struct ast_format_cap *cap, const char *addr, int timeout, const char *app, const char *appdata, int *reason, int sync, const char *cid_num, const char *cid_name, struct ast_variable *vars, const char *account, struct ast_channel **locked_channel, struct originate_params *origparm);
 
 /*!
  * \brief Evaluate a condition
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/main/asterisk.c asterisk-11.3.0.p000/main/asterisk.c
--- asterisk-base-11.3.0/main/asterisk.c	2013-05-02 16:11:05.924437662 +0100
+++ asterisk-11.3.0.p000/main/asterisk.c	2013-05-13 14:01:43.120437819 +0100
@@ -189,6 +189,7 @@
 /*! @{ */
 
 struct ast_flags ast_options = { AST_DEFAULT_OPTIONS };
+struct ast_flags ast_options2 = { AST_DEFAULT_OPTIONS2 };
 struct ast_flags ast_compat = { 0 };
 
 int option_verbose;				/*!< Verbosity level */
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/main/channel.c asterisk-11.3.0.p000/main/channel.c
--- asterisk-base-11.3.0/main/channel.c	2013-05-02 16:11:05.996443375 +0100
+++ asterisk-11.3.0.p000/main/channel.c	2013-05-13 14:01:43.180438001 +0100
@@ -5618,7 +5618,7 @@
 	return new_chan;
 }
 
-struct ast_channel *__ast_request_and_dial(const char *type, struct ast_format_cap *cap, const struct ast_channel *requestor, const char *addr, int timeout, int *outstate, const char *cid_num, const char *cid_name, struct outgoing_helper *oh)
+struct ast_channel *__ast_request_and_dial(const char *type, struct ast_format_cap *cap, const struct ast_channel *requestor, const char *addr, int timeout, int *outstate, const char *cid_num, const char *cid_name, struct outgoing_helper *oh, struct originate_params *origparm)
 {
 	int dummy_outstate;
 	int cause = 0;
@@ -5626,6 +5626,7 @@
 	int res = 0;
 	int last_subclass = 0;
 	struct ast_party_connected_line connected;
+	AST_SMRA_ATTRIB temp_smra_attrib;
 
 	if (outstate)
 		*outstate = 0;
@@ -5690,6 +5691,22 @@
 	}
 	ast_channel_set_connected_line(chan, &connected, NULL);
 
+	if (origparm != NULL) {
+	   if (origparm->callerid[0] != '\0') {
+	      if (ast_channel_cid_ani(chan))
+	         free(ast_channel_cid_ani(chan));
+	      ast_channel_cid_ani_set(chan, ast_strdup(origparm->callerid));
+	   }
+	   ast_channel_extradata_set(chan, origparm->extradata);
+
+	   temp_smra_attrib.rtpa_port = origparm->rtpa_port;
+	   temp_smra_attrib.rtpv_port = origparm->rtpv_port;
+	   ast_copy_string(temp_smra_attrib.rtpa_ip, origparm->rtpa_ip, sizeof(temp_smra_attrib.rtpa_ip));
+	   ast_copy_string(temp_smra_attrib.rtpv_ip, origparm->rtpv_ip, sizeof(temp_smra_attrib.rtpv_ip));
+
+	   ast_channel_server_smra_attrib_set(chan, &temp_smra_attrib);
+	}
+
 	if (ast_call(chan, addr, 0)) {	/* ast_call failed... */
 		ast_log(LOG_NOTICE, "Unable to call channel %s/%s\n", type, addr);
 	} else {
@@ -5782,6 +5799,8 @@
 		}
 	}
 
+	*outstate = ast_channel_hangupcause(chan);
+
 	/* Final fixups */
 	if (oh) {
 		if (!ast_strlen_zero(oh->context))
@@ -5826,7 +5845,7 @@
 
 struct ast_channel *ast_request_and_dial(const char *type, struct ast_format_cap *cap, const struct ast_channel *requestor, const char *addr, int timeout, int *outstate, const char *cidnum, const char *cidname)
 {
-	return __ast_request_and_dial(type, cap, requestor, addr, timeout, outstate, cidnum, cidname, NULL);
+	return __ast_request_and_dial(type, cap, requestor, addr, timeout, outstate, cidnum, cidname, NULL, NULL);
 }
 
 static int set_security_requirements(const struct ast_channel *requestor, struct ast_channel *out)
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/main/channel_internal_api.c asterisk-11.3.0.p000/main/channel_internal_api.c
--- asterisk-base-11.3.0/main/channel_internal_api.c	2013-05-02 16:11:06.372437977 +0100
+++ asterisk-11.3.0.p000/main/channel_internal_api.c	2013-05-13 14:01:46.768687565 +0100
@@ -59,6 +59,30 @@
 struct ast_channel {
 	const struct ast_channel_tech *tech;		/*!< Technology (point to channel driver) */
 	void *tech_pvt;					/*!< Private data used by the technology driver */
+
+	/* sip_extended_params support */
+	char url_params[AST_MAX_PARAMS];
+	int siphangupcause;
+	struct ast_format_cap *jointcapability;
+	int defhangcause;
+	char extradata[2048];
+
+	struct ast_flags inoflags;
+	char conf_playann[128];
+	char conf_record[256];
+	char conf_record_format[8];
+
+	//- SMRA Stuff
+	AST_SMRA_ATTRIB server_smra_attrib;
+	AST_SMRA_ATTRIB client_smra_attrib;
+
+	SDPMedia client_sdp_codecs;
+	SDPMedia server_sdp_codecs;
+
+	struct ast_callerid cid;                    /*!< Caller ID, name, presentation etc */
+
+	int charge_type;
+
 	void *music_state;				/*!< Music State*/
 	void *generatordata;				/*!< Current generator data if there is any */
 	struct ast_generator *generator;		/*!< Current active data generator */
@@ -691,6 +715,139 @@
 {
 	chan->generatordata = value;
 }
+const char *ast_channel_url_params(const struct ast_channel *chan)
+{
+   return chan->url_params;
+}
+void ast_channel_url_params_set(struct ast_channel *chan, char *value)
+{
+   snprintf(chan->url_params, sizeof(chan->extradata), "%s", value);
+}
+const char *ast_channel_conf_playann(const struct ast_channel *chan)
+{
+   return chan->conf_playann;
+}
+void ast_channel_conf_playann_set(struct ast_channel *chan, char *value)
+{
+   snprintf(chan->conf_playann, sizeof(chan->conf_playann), "%s", value);
+}
+const char *ast_channel_conf_record(const struct ast_channel *chan)
+{
+   return chan->conf_record;
+}
+void ast_channel_conf_record_set(struct ast_channel *chan, char *value)
+{
+   snprintf(chan->conf_record, sizeof(chan->conf_record), "%s", value);
+}
+const char *ast_channel_conf_record_format(const struct ast_channel *chan)
+{
+   return chan->conf_record_format;
+}
+void ast_channel_conf_record_format_set(struct ast_channel *chan, char *value)
+{
+   snprintf(chan->conf_record_format, sizeof(chan->conf_record_format), "%s", value);
+}
+const char *ast_channel_extradata(const struct ast_channel *chan)
+{
+   return chan->extradata;
+}
+void ast_channel_extradata_set(struct ast_channel *chan, char *value)
+{
+   snprintf(chan->extradata, sizeof(chan->extradata), "%s", value);
+}
+const AST_SMRA_ATTRIB *ast_channel_server_smra_attrib(const struct ast_channel *chan)
+{
+   return &chan->server_smra_attrib;
+}
+void ast_channel_server_smra_attrib_set(struct ast_channel *chan, AST_SMRA_ATTRIB *server_smra_attrib)
+{
+   memcpy(&(chan->server_smra_attrib), server_smra_attrib, sizeof(AST_SMRA_ATTRIB));
+}
+const AST_SMRA_ATTRIB *ast_channel_client_smra_attrib(const struct ast_channel *chan)
+{
+   return &(chan->client_smra_attrib);
+}
+void ast_channel_client_smra_attrib_set(struct ast_channel *chan, AST_SMRA_ATTRIB *client_smra_attrib)
+{
+   memcpy(&(chan->client_smra_attrib), client_smra_attrib, sizeof(AST_SMRA_ATTRIB));
+}
+char *ast_channel_cid_ani(const struct ast_channel *chan)
+{
+   return chan->cid.cid_ani_url;
+}
+void ast_channel_cid_ani_set(struct ast_channel *chan, char *value)
+{
+   chan->cid.cid_ani_url = ast_strdup(value);
+}
+char *ast_channel_cid_dnis(const struct ast_channel *chan)
+{
+   return chan->cid.cid_dnis_url;
+}
+void ast_channel_cid_dnis_set(struct ast_channel *chan, char *value)
+{
+   chan->cid.cid_dnis_url = ast_strdup(value);
+}
+char *ast_channel_cid_asserted_id(const struct ast_channel *chan)
+{
+   return chan->cid.cid_asserted_id;
+}
+void ast_channel_cid_asserted_id_set(struct ast_channel *chan, char *value)
+{
+   chan->cid.cid_asserted_id = ast_strdup(value);
+}
+char *ast_channel_cid_callid(const struct ast_channel *chan)
+{
+   return chan->cid.callid;
+}
+void ast_channel_cid_callid_set(struct ast_channel *chan, char *value)
+{
+   chan->cid.callid = ast_strdup(value);
+}
+char *ast_channel_cid_privacy(const struct ast_channel *chan)
+{
+   return chan->cid.cid_privacy;
+}
+void ast_channel_cid_privacy_set(struct ast_channel *chan, char *value)
+{
+   chan->cid.cid_privacy = ast_strdup(value);
+}
+const struct ast_format_cap *ast_channel_jointcapability(const struct ast_channel *chan)
+{
+   return chan->jointcapability;
+}
+void ast_channel_jointcapability_set(struct ast_channel *chan, struct ast_format_cap *value)
+{
+   chan->jointcapability = value;
+}
+const SDPMedia *ast_channel_client_sdp(const struct ast_channel *chan)
+{
+   return &(chan->client_sdp_codecs);
+}
+void ast_channel_client_sdp_set(struct ast_channel *chan, SDPMedia *value)
+{
+   memcpy(&chan->client_sdp_codecs, value, sizeof(chan->client_sdp_codecs));
+}
+int ast_channel_defhangcause(const struct ast_channel *chan)
+{
+   return chan->defhangcause;
+}
+void ast_channel_defhangcause_set(struct ast_channel *chan, int value)
+{
+   chan->defhangcause = value;
+}
+struct ast_flags *ast_channel_inoflags(const struct ast_channel *chan)
+{
+   return &(chan->inoflags);
+}
+int ast_channel_charge_type(const struct ast_channel *chan)
+{
+   return chan->charge_type;
+}
+void ast_channel_charge_type_set(struct ast_channel *chan, int value)
+{
+   chan->charge_type = value;
+}
+
 void *ast_channel_music_state(const struct ast_channel *chan)
 {
 	return chan->music_state;
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/main/format.c asterisk-11.3.0.p000/main/format.c
--- asterisk-base-11.3.0/main/format.c	2013-05-02 16:11:05.944439746 +0100
+++ asterisk-11.3.0.p000/main/format.c	2013-05-13 14:01:43.136437770 +0100
@@ -434,6 +434,13 @@
 	case AST_FORMAT_TESTLAW:
 		return (1ULL << 47);
 
+	case AST_FORMAT_AMRNB:
+	   return (1ULL << 34);
+	case AST_FORMAT_AMRWB:
+	   return (1ULL << 35);
+	case AST_FORMAT_MPEG4_AUDIO:
+	   return (1ULL << 36);
+
 	/*! H.261 Video */
 	case AST_FORMAT_H261:
 		return (1ULL << 18);
@@ -536,6 +543,13 @@
 	case (1ULL << 47):
 		return ast_format_set(dst, AST_FORMAT_TESTLAW, 0);
 
+	case (1ULL << 34):
+      return ast_format_set(dst, AST_FORMAT_AMRNB, 0);
+	case (1ULL << 35):
+      return ast_format_set(dst, AST_FORMAT_AMRWB, 0);
+	case (1ULL << 36):
+      return ast_format_set(dst, AST_FORMAT_MPEG4_AUDIO, 0);
+
 	/*! H.261 Video */
 	case (1ULL << 18):
 		return ast_format_set(dst, AST_FORMAT_H261, 0);
@@ -731,6 +745,7 @@
 {
 	switch (format->id) {
 	case AST_FORMAT_SLINEAR12:
+	case AST_FORMAT_MPEG4_AUDIO:
 		return 12000;
 	case AST_FORMAT_SLINEAR24:
 		return 24000;
@@ -748,6 +763,7 @@
 	case AST_FORMAT_SLINEAR16:
 	case AST_FORMAT_SIREN7:
 	case AST_FORMAT_SPEEX16:
+	case AST_FORMAT_AMRWB:
 		return 16000;
 	case AST_FORMAT_SIREN14:
 	case AST_FORMAT_SPEEX32:
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/main/manager.c asterisk-11.3.0.p000/main/manager.c
--- asterisk-base-11.3.0/main/manager.c	2013-05-02 16:11:06.024437741 +0100
+++ asterisk-11.3.0.p000/main/manager.c	2013-05-13 14:01:43.204437835 +0100
@@ -4006,6 +4006,7 @@
 	);
 	int priority;
 	struct ast_variable *vars;
+	struct originate_params orig_extra;
 };
 
 /*!
@@ -4031,12 +4032,19 @@
 	struct ast_channel *chan = NULL, *chans[1];
 	char requested_channel[AST_CHANNEL_NAME];
 
+       //int len = strlen(in->data);
+       //char *str = in->data + len + 1;
+
+       //if (len < 200) {
+       //   sprintf(str, in->idtext);
+       //}
+
 	if (!ast_strlen_zero(in->app)) {
 		res = ast_pbx_outgoing_app(in->tech, in->cap, in->data,
 			in->timeout, in->app, in->appdata, &reason, 1,
 			S_OR(in->cid_num, NULL),
 			S_OR(in->cid_name, NULL),
-			in->vars, in->account, &chan);
+			in->vars, in->account, &chan, &in->orig_extra);
 	} else {
 		res = ast_pbx_outgoing_exten(in->tech, in->cap, in->data,
 			in->timeout, in->context, in->exten, in->priority, &reason, 1,
@@ -4322,6 +4330,12 @@
 	const char *id = astman_get_header(m, "ActionID");
 	const char *codecs = astman_get_header(m, "Codecs");
 	const char *early_media = astman_get_header(m, "Earlymedia");
+	const char *privacy = astman_get_header(m, "Privacy");
+	const char *extradata = astman_get_header(m, "Extra");
+	const char *server_video_port = astman_get_header(m, "LVidPort");
+	const char *server_audio_port = astman_get_header(m, "LAudPort");
+	const char *server_video_ip = astman_get_header(m, "LVidIP");
+	const char *server_audio_ip = astman_get_header(m, "LAudIP");
 	struct ast_variable *vars = NULL;
 	char *tech, *data;
 	char *l = NULL, *n = NULL;
@@ -4375,7 +4389,9 @@
 		}
 	}
 	if (l) {
-		ast_shrink_phone_number(l);
+	   // we could do this if :ani "teste" <sip:ola@ola.pt> so that ola.pt doesn't become olapt
+	   if (!strchr(l, '@'))
+	      ast_shrink_phone_number(l);
 		if (ast_strlen_zero(l)) {
 			l = NULL;
 		}
@@ -4468,6 +4484,16 @@
 			fast->timeout = to;
 			fast->early_media = bridge_early;
 			fast->priority = pi;
+			if (ast_true(privacy)) fast->orig_extra.privacy = 1;
+			if (callerid)
+			   ast_copy_string(fast->orig_extra.callerid, callerid, sizeof(fast->orig_extra.callerid));
+			else fast->orig_extra.callerid[0] = '\0';
+			ast_copy_string(fast->orig_extra.extradata, extradata, sizeof(fast->orig_extra.extradata));
+			ast_copy_string(fast->orig_extra.rtpa_ip, server_audio_ip, sizeof(fast->orig_extra.rtpa_ip));
+			ast_copy_string(fast->orig_extra.rtpv_ip, server_video_ip, sizeof(fast->orig_extra.rtpv_ip));
+			fast->orig_extra.rtpa_port = atoi(server_audio_port);
+			fast->orig_extra.rtpv_port = atoi(server_video_port);
+
 			if (ast_pthread_create_detached(&th, NULL, fast_originate, fast)) {
 				destroy_fast_originate_helper(fast);
 				res = -1;
@@ -4476,7 +4502,7 @@
 			}
 		}
 	} else if (!ast_strlen_zero(app)) {
-		res = ast_pbx_outgoing_app(tech, cap, data, to, app, appdata, &reason, 1, l, n, vars, account, NULL);
+		res = ast_pbx_outgoing_app(tech, cap, data, to, app, appdata, &reason, 1, l, n, vars, account, NULL, NULL);
 		/* Any vars memory was passed to ast_pbx_outgoing_app(). */
 	} else {
 		if (exten && context && pi) {
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/main/pbx.c asterisk-11.3.0.p000/main/pbx.c
--- asterisk-base-11.3.0/main/pbx.c	2013-05-02 16:11:06.384437215 +0100
+++ asterisk-11.3.0.p000/main/pbx.c	2013-05-13 14:01:46.776687800 +0100
@@ -10129,7 +10129,7 @@
 		oh.vars = vars;
 		oh.parent_channel = NULL;
 
-		chan = __ast_request_and_dial(type, cap, NULL, addr, timeout, reason, cid_num, cid_name, &oh);
+		chan = __ast_request_and_dial(type, cap, NULL, addr, timeout, reason, cid_num, cid_name, &oh, NULL);
 		if (channel) {
 			*channel = chan;
 			if (chan)
@@ -10305,7 +10305,7 @@
 	return NULL;
 }
 
-int ast_pbx_outgoing_app(const char *type, struct ast_format_cap *cap, const char *addr, int timeout, const char *app, const char *appdata, int *reason, int synchronous, const char *cid_num, const char *cid_name, struct ast_variable *vars, const char *account, struct ast_channel **locked_channel)
+int ast_pbx_outgoing_app(const char *type, struct ast_format_cap *cap, const char *addr, int timeout, const char *app, const char *appdata, int *reason, int synchronous, const char *cid_num, const char *cid_name, struct ast_variable *vars, const char *account, struct ast_channel **locked_channel, struct originate_params *extradata)
 {
 	struct ast_channel *chan;
 	struct app_tmp *tmp;
@@ -10328,7 +10328,7 @@
 		goto outgoing_app_cleanup;
 	}
 	if (synchronous) {
-		chan = __ast_request_and_dial(type, cap, NULL, addr, timeout, reason, cid_num, cid_name, &oh);
+		chan = __ast_request_and_dial(type, cap, NULL, addr, timeout, reason, cid_num, cid_name, &oh, extradata);
 		if (chan) {
 			/* Bind the newly created callid to the channel if it doesn't already have one on creation */
 			struct ast_callid *channel_callid = ast_channel_callid(chan);
@@ -10407,7 +10407,7 @@
 			res = -1;
 			goto outgoing_app_cleanup;
 		}
-		chan = __ast_request_and_dial(type, cap, NULL, addr, timeout, reason, cid_num, cid_name, &oh);
+		chan = __ast_request_and_dial(type, cap, NULL, addr, timeout, reason, cid_num, cid_name, &oh, extradata);
 		if (!chan) {
 			ast_free(as);
 			res = -1;
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/menuselect/example_menuselect-tree asterisk-11.3.0.p000/menuselect/example_menuselect-tree
--- asterisk-base-11.3.0/menuselect/example_menuselect-tree	2013-05-02 16:10:21.009188011 +0100
+++ asterisk-11.3.0.p000/menuselect/example_menuselect-tree	2013-05-13 14:00:47.820437681 +0100
@@ -153,6 +153,8 @@
 		</member>
 		<member name="app_while" displayname="While Loops and Conditional Execution" remove_on_change="apps/app_while.o apps/app_while.so">
 		</member>
+		<member name="app_wms" displayname="WMS Call Control Application" remove_on_change="apps/app_wms.o apps/app_wms.so">
+		</member>
 		<member name="app_zapateller" displayname="Block Telemarketers with Special Information Tone" remove_on_change="apps/app_zapateller.o apps/app_zapateller.so">
 		</member>
 		<member name="app_zapbarge" displayname="Barge in on Zap channel application" remove_on_change="apps/app_zapbarge.o apps/app_zapbarge.so">
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/menuselect-tree asterisk-11.3.0.p000/menuselect-tree
--- asterisk-base-11.3.0/menuselect-tree	1970-01-01 01:00:00.000000000 +0100
+++ asterisk-11.3.0.p000/menuselect-tree	2013-05-13 14:01:47.080438022 +0100
@@ -0,0 +1,1075 @@
+<?xml version="1.0"?>
+
+<menu name="Asterisk Module and Build Option Selection">
+<category name="MENUSELECT_ADDONS" displayname="Add-ons (See README-addons.txt)" remove_on_change="addons/modules.link">
+<member name="app_mysql" displayname="Simple Mysql Interface" remove_on_change="addons/app_mysql.o addons/app_mysql.so">
+	<depend>mysqlclient</depend>
+	<defaultenabled>no</defaultenabled>
+</member>
+<member name="app_saycountpl" displayname="Say polish counting words" remove_on_change="addons/app_saycountpl.o addons/app_saycountpl.so">
+	<defaultenabled>no</defaultenabled>
+</member>
+<member name="cdr_mysql" displayname="MySQL CDR Backend" remove_on_change="addons/cdr_mysql.o addons/cdr_mysql.so">
+	<depend>mysqlclient</depend>
+	<defaultenabled>no</defaultenabled>
+</member>
+<member name="chan_mobile" displayname="Bluetooth Mobile Device Channel Driver" remove_on_change="addons/chan_mobile.o addons/chan_mobile.so">
+	<depend>bluetooth</depend>
+	<defaultenabled>no</defaultenabled>
+</member>
+<member name="chan_ooh323" displayname="Objective Systems H323 Channel" remove_on_change="addons/chan_ooh323.o addons/chan_ooh323.so">
+	<defaultenabled>no</defaultenabled>
+</member>
+<member name="format_mp3" displayname="MP3 format [Any rate but 8000hz mono is optimal]" remove_on_change="addons/format_mp3.o addons/format_mp3.so">
+	<defaultenabled>no</defaultenabled>
+</member>
+<member name="res_config_mysql" displayname="MySQL RealTime Configuration Driver" remove_on_change="addons/res_config_mysql.o addons/res_config_mysql.so">
+	<depend>mysqlclient</depend>
+	<defaultenabled>no</defaultenabled>
+</member>
+</category>
+<category name="MENUSELECT_APPS" displayname="Applications" remove_on_change="apps/modules.link">
+<member name="app_adsiprog" displayname="Asterisk ADSI Programming Application" remove_on_change="apps/app_adsiprog.o apps/app_adsiprog.so">
+	<depend>res_adsi</depend>
+</member>
+<member name="app_alarmreceiver" displayname="Alarm Receiver for Asterisk" remove_on_change="apps/app_alarmreceiver.o apps/app_alarmreceiver.so">
+</member>
+<member name="app_amd" displayname="Answering Machine Detection Application" remove_on_change="apps/app_amd.o apps/app_amd.so">
+</member>
+<member name="app_authenticate" displayname="Authentication Application" remove_on_change="apps/app_authenticate.o apps/app_authenticate.so">
+</member>
+<member name="app_cdr" displayname="Tell Asterisk to not maintain a CDR for the current call" remove_on_change="apps/app_cdr.o apps/app_cdr.so">
+</member>
+<member name="app_celgenuserevent" displayname="Generate an User-Defined CEL event" remove_on_change="apps/app_celgenuserevent.o apps/app_celgenuserevent.so">
+</member>
+<member name="app_chanisavail" displayname="Check channel availability" remove_on_change="apps/app_chanisavail.o apps/app_chanisavail.so">
+</member>
+<member name="app_channelredirect" displayname="Redirects a given channel to a dialplan target" remove_on_change="apps/app_channelredirect.o apps/app_channelredirect.so">
+</member>
+<member name="app_chanspy" displayname="Listen to the audio of an active channel" remove_on_change="apps/app_chanspy.o apps/app_chanspy.so">
+</member>
+<member name="app_confbridge" displayname="Conference Bridge Application" remove_on_change="apps/app_confbridge.o apps/app_confbridge.so">
+</member>
+<member name="app_controlplayback" displayname="Control Playback Application" remove_on_change="apps/app_controlplayback.o apps/app_controlplayback.so">
+</member>
+<member name="app_dahdibarge" displayname="Barge in on DAHDI channel application" remove_on_change="apps/app_dahdibarge.o apps/app_dahdibarge.so">
+	<depend>dahdi</depend>
+</member>
+<member name="app_dahdiras" displayname="DAHDI ISDN Remote Access Server" remove_on_change="apps/app_dahdiras.o apps/app_dahdiras.so">
+	<depend>dahdi</depend>
+</member>
+<member name="app_db" displayname="Database Access Functions" remove_on_change="apps/app_db.o apps/app_db.so">
+</member>
+<member name="app_dial" displayname="Dialing Application" remove_on_change="apps/app_dial.o apps/app_dial.so">
+	<depend>chan_local</depend>
+</member>
+<member name="app_dictate" displayname="Virtual Dictation Machine" remove_on_change="apps/app_dictate.o apps/app_dictate.so">
+</member>
+<member name="app_directed_pickup" displayname="Directed Call Pickup Application" remove_on_change="apps/app_directed_pickup.o apps/app_directed_pickup.so">
+</member>
+<member name="app_directory" displayname="Extension Directory" remove_on_change="apps/app_directory.o apps/app_directory.so">
+	<depend>app_voicemail</depend>
+</member>
+<member name="app_disa" displayname="DISA (Direct Inward System Access) Application" remove_on_change="apps/app_disa.o apps/app_disa.so">
+</member>
+<member name="app_dumpchan" displayname="Dump Info About The Calling Channel" remove_on_change="apps/app_dumpchan.o apps/app_dumpchan.so">
+</member>
+<member name="app_echo" displayname="Simple Echo Application" remove_on_change="apps/app_echo.o apps/app_echo.so">
+</member>
+<member name="app_exec" displayname="Executes dialplan applications" remove_on_change="apps/app_exec.o apps/app_exec.so">
+</member>
+<member name="app_externalivr" displayname="External IVR Interface Application" remove_on_change="apps/app_externalivr.o apps/app_externalivr.so">
+</member>
+<member name="app_fax" displayname="Simple FAX Application" remove_on_change="apps/app_fax.o apps/app_fax.so">
+	<defaultenabled>no</defaultenabled>
+	<depend>spandsp</depend>
+	<conflict>res_fax</conflict>
+</member>
+<member name="app_festival" displayname="Simple Festival Interface" remove_on_change="apps/app_festival.o apps/app_festival.so">
+</member>
+<member name="app_flash" displayname="Flash channel application" remove_on_change="apps/app_flash.o apps/app_flash.so">
+	<depend>dahdi</depend>
+</member>
+<member name="app_followme" displayname="Find-Me/Follow-Me Application" remove_on_change="apps/app_followme.o apps/app_followme.so">
+	<depend>chan_local</depend>
+</member>
+<member name="app_forkcdr" displayname="Fork The CDR into 2 separate entities" remove_on_change="apps/app_forkcdr.o apps/app_forkcdr.so">
+</member>
+<member name="app_getcpeid" displayname="Get ADSI CPE ID" remove_on_change="apps/app_getcpeid.o apps/app_getcpeid.so">
+</member>
+<member name="app_ices" displayname="Encode and Stream via icecast and ices" remove_on_change="apps/app_ices.o apps/app_ices.so">
+</member>
+<member name="app_image" displayname="Image Transmission Application" remove_on_change="apps/app_image.o apps/app_image.so">
+</member>
+<member name="app_ivrdemo" displayname="IVR Demo Application" remove_on_change="apps/app_ivrdemo.o apps/app_ivrdemo.so">
+	<defaultenabled>no</defaultenabled>
+</member>
+<member name="app_jack" displayname="JACK Interface" remove_on_change="apps/app_jack.o apps/app_jack.so">
+	<depend>jack</depend>
+	<depend>resample</depend>
+</member>
+<member name="app_macro" displayname="Extension Macros" remove_on_change="apps/app_macro.o apps/app_macro.so">
+</member>
+<member name="app_meetme" displayname="MeetMe conference bridge" remove_on_change="apps/app_meetme.o apps/app_meetme.so">
+	<depend>dahdi</depend>
+</member>
+<member name="app_milliwatt" displayname="Digital Milliwatt (mu-law) Test Application" remove_on_change="apps/app_milliwatt.o apps/app_milliwatt.so">
+</member>
+<member name="app_minivm" displayname="Mini VoiceMail (A minimal Voicemail e-mail System)" remove_on_change="apps/app_minivm.o apps/app_minivm.so">
+</member>
+<member name="app_mixmonitor" displayname="Mixed Audio Monitoring Application" remove_on_change="apps/app_mixmonitor.o apps/app_mixmonitor.so">
+</member>
+<member name="app_morsecode" displayname="Morse code" remove_on_change="apps/app_morsecode.o apps/app_morsecode.so">
+</member>
+<member name="app_mp3" displayname="Silly MP3 Application" remove_on_change="apps/app_mp3.o apps/app_mp3.so">
+</member>
+<member name="app_nbscat" displayname="Silly NBS Stream Application" remove_on_change="apps/app_nbscat.o apps/app_nbscat.so">
+</member>
+<member name="app_originate" displayname="Originate call" remove_on_change="apps/app_originate.o apps/app_originate.so">
+</member>
+<member name="app_osplookup" displayname="Open Settlement Protocol Applications" remove_on_change="apps/app_osplookup.o apps/app_osplookup.so">
+	<depend>osptk</depend>
+	<depend>openssl</depend>
+</member>
+<member name="app_page" displayname="Page Multiple Phones" remove_on_change="apps/app_page.o apps/app_page.so">
+	<depend>dahdi</depend>
+	<depend>app_meetme</depend>
+</member>
+<member name="app_parkandannounce" displayname="Call Parking and Announce Application" remove_on_change="apps/app_parkandannounce.o apps/app_parkandannounce.so">
+</member>
+<member name="app_playback" displayname="Sound File Playback Application" remove_on_change="apps/app_playback.o apps/app_playback.so">
+</member>
+<member name="app_playtones" displayname="Playtones Application" remove_on_change="apps/app_playtones.o apps/app_playtones.so">
+</member>
+<member name="app_privacy" displayname="Require phone number to be entered, if no CallerID sent" remove_on_change="apps/app_privacy.o apps/app_privacy.so">
+</member>
+<member name="app_queue" displayname="True Call Queueing" remove_on_change="apps/app_queue.o apps/app_queue.so">
+	<use>res_monitor</use>
+</member>
+<member name="app_read" displayname="Read Variable Application" remove_on_change="apps/app_read.o apps/app_read.so">
+</member>
+<member name="app_readexten" displayname="Read and evaluate extension validity" remove_on_change="apps/app_readexten.o apps/app_readexten.so">
+</member>
+<member name="app_readfile" displayname="Stores output of file into a variable" remove_on_change="apps/app_readfile.o apps/app_readfile.so">
+</member>
+<member name="app_record" displayname="Trivial Record Application" remove_on_change="apps/app_record.o apps/app_record.so">
+</member>
+<member name="app_rpt" displayname="Radio Repeater/Remote Base Application" remove_on_change="apps/app_rpt.o apps/app_rpt.so">
+	<depend>dahdi</depend>
+	<depend>tonezone</depend>
+	<defaultenabled>no</defaultenabled>
+</member>
+<member name="app_rtsp" displayname="RTSP applications" remove_on_change="apps/app_rtsp.o apps/app_rtsp.so">
+</member>
+<member name="app_saycounted" displayname="Decline words according to channel language" remove_on_change="apps/app_saycounted.o apps/app_saycounted.so">
+	<defaultenabled>no</defaultenabled>
+</member>
+<member name="app_sayunixtime" displayname="Say time" remove_on_change="apps/app_sayunixtime.o apps/app_sayunixtime.so">
+</member>
+<member name="app_senddtmf" displayname="Send DTMF digits Application" remove_on_change="apps/app_senddtmf.o apps/app_senddtmf.so">
+</member>
+<member name="app_sendtext" displayname="Send Text Applications" remove_on_change="apps/app_sendtext.o apps/app_sendtext.so">
+</member>
+<member name="app_setcallerid" displayname="Set CallerID Presentation Application" remove_on_change="apps/app_setcallerid.o apps/app_setcallerid.so">
+</member>
+<member name="app_skel" displayname="Skeleton (sample) Application" remove_on_change="apps/app_skel.o apps/app_skel.so">
+	<defaultenabled>no</defaultenabled>
+</member>
+<member name="app_sms" displayname="SMS/PSTN handler" remove_on_change="apps/app_sms.o apps/app_sms.so">
+</member>
+<member name="app_softhangup" displayname="Hangs up the requested channel" remove_on_change="apps/app_softhangup.o apps/app_softhangup.so">
+</member>
+<member name="app_speech_utils" displayname="Dialplan Speech Applications" remove_on_change="apps/app_speech_utils.o apps/app_speech_utils.so">
+</member>
+<member name="app_stack" displayname="Dialplan subroutines (Gosub, Return, etc)" remove_on_change="apps/app_stack.o apps/app_stack.so">
+	<use>res_agi</use>
+</member>
+<member name="app_system" displayname="Generic System() application" remove_on_change="apps/app_system.o apps/app_system.so">
+</member>
+<member name="app_talkdetect" displayname="Playback with Talk Detection" remove_on_change="apps/app_talkdetect.o apps/app_talkdetect.so">
+</member>
+<member name="app_test" displayname="Interface Test Application" remove_on_change="apps/app_test.o apps/app_test.so">
+</member>
+<member name="app_transfer" displayname="Transfers a caller to another extension" remove_on_change="apps/app_transfer.o apps/app_transfer.so">
+</member>
+<member name="app_url" displayname="Send URL Applications" remove_on_change="apps/app_url.o apps/app_url.so">
+</member>
+<member name="app_userevent" displayname="Custom User Event Application" remove_on_change="apps/app_userevent.o apps/app_userevent.so">
+</member>
+<member name="app_verbose" displayname="Send verbose output" remove_on_change="apps/app_verbose.o apps/app_verbose.so">
+</member>
+<member name="app_voicemail" displayname="Comedian Mail (Voicemail System)" remove_on_change="apps/app_voicemail.o apps/app_voicemail.so">
+	<use>res_adsi</use>
+	<use>res_smdi</use>
+</member>
+<member name="app_waitforring" displayname="Waits until first ring after time" remove_on_change="apps/app_waitforring.o apps/app_waitforring.so">
+</member>
+<member name="app_waitforsilence" displayname="Wait For Silence" remove_on_change="apps/app_waitforsilence.o apps/app_waitforsilence.so">
+</member>
+<member name="app_waituntil" displayname="Wait until specified time" remove_on_change="apps/app_waituntil.o apps/app_waituntil.so">
+</member>
+<member name="app_while" displayname="While Loops and Conditional Execution" remove_on_change="apps/app_while.o apps/app_while.so">
+</member>
+<member name="app_wms" displayname="WMS Call Control Application" remove_on_change="apps/app_wms.o apps/app_wms.so">
+</member>
+<member name="app_zapateller" displayname="Block Telemarketers with Special Information Tone" remove_on_change="apps/app_zapateller.o apps/app_zapateller.so">
+</member>
+</category>
+<category name="MENUSELECT_BRIDGES" displayname="Bridging Modules" remove_on_change="bridges/modules.link">
+<member name="bridge_builtin_features" displayname="Built in bridging features" remove_on_change="bridges/bridge_builtin_features.o bridges/bridge_builtin_features.so">
+</member>
+<member name="bridge_multiplexed" displayname="Multiplexed two channel bridging module" remove_on_change="bridges/bridge_multiplexed.o bridges/bridge_multiplexed.so">
+</member>
+<member name="bridge_simple" displayname="Simple two channel bridging module" remove_on_change="bridges/bridge_simple.o bridges/bridge_simple.so">
+</member>
+<member name="bridge_softmix" displayname="Multi-party software based channel mixing" remove_on_change="bridges/bridge_softmix.o bridges/bridge_softmix.so">
+</member>
+</category>
+<category name="MENUSELECT_CDR" displayname="Call Detail Recording" remove_on_change="cdr/modules.link">
+<member name="cdr_adaptive_odbc" displayname="Adaptive ODBC CDR backend" remove_on_change="cdr/cdr_adaptive_odbc.o cdr/cdr_adaptive_odbc.so">
+	<depend>res_odbc</depend>
+</member>
+<member name="cdr_csv" displayname="Comma Separated Values CDR Backend" remove_on_change="cdr/cdr_csv.o cdr/cdr_csv.so">
+</member>
+<member name="cdr_custom" displayname="Customizable Comma Separated Values CDR Backend" remove_on_change="cdr/cdr_custom.o cdr/cdr_custom.so">
+</member>
+<member name="cdr_manager" displayname="Asterisk Manager Interface CDR Backend" remove_on_change="cdr/cdr_manager.o cdr/cdr_manager.so">
+</member>
+<member name="cdr_odbc" displayname="ODBC CDR Backend" remove_on_change="cdr/cdr_odbc.o cdr/cdr_odbc.so">
+	<depend>res_odbc</depend>
+</member>
+<member name="cdr_pgsql" displayname="PostgreSQL CDR Backend" remove_on_change="cdr/cdr_pgsql.o cdr/cdr_pgsql.so">
+	<depend>pgsql</depend>
+</member>
+<member name="cdr_radius" displayname="RADIUS CDR Backend" remove_on_change="cdr/cdr_radius.o cdr/cdr_radius.so">
+	<depend>radius</depend>
+</member>
+<member name="cdr_sqlite3_custom" displayname="SQLite3 Custom CDR Module" remove_on_change="cdr/cdr_sqlite3_custom.o cdr/cdr_sqlite3_custom.so">
+	<depend>sqlite3</depend>
+</member>
+<member name="cdr_sqlite" displayname="SQLite CDR Backend" remove_on_change="cdr/cdr_sqlite.o cdr/cdr_sqlite.so">
+	<depend>sqlite</depend>
+</member>
+<member name="cdr_syslog" displayname="Customizable syslog CDR Backend" remove_on_change="cdr/cdr_syslog.o cdr/cdr_syslog.so">
+	 <depend>syslog</depend>
+</member>
+<member name="cdr_tds" displayname="FreeTDS CDR Backend" remove_on_change="cdr/cdr_tds.o cdr/cdr_tds.so">
+	<depend>freetds</depend>
+</member>
+</category>
+<category name="MENUSELECT_CEL" displayname="Channel Event Logging" remove_on_change="cel/modules.link">
+<member name="cel_custom" displayname="Customizable Comma Separated Values CEL Backend" remove_on_change="cel/cel_custom.o cel/cel_custom.so">
+</member>
+<member name="cel_manager" displayname="Asterisk Manager Interface CEL Backend" remove_on_change="cel/cel_manager.o cel/cel_manager.so">
+</member>
+<member name="cel_odbc" displayname="ODBC CEL backend" remove_on_change="cel/cel_odbc.o cel/cel_odbc.so">
+	<depend>res_odbc</depend>
+</member>
+<member name="cel_pgsql" displayname="PostgreSQL CEL Backend" remove_on_change="cel/cel_pgsql.o cel/cel_pgsql.so">
+	<depend>pgsql</depend>
+</member>
+<member name="cel_radius" displayname="RADIUS CEL Backend" remove_on_change="cel/cel_radius.o cel/cel_radius.so">
+	<depend>radius</depend>
+</member>
+<member name="cel_sqlite3_custom" displayname="SQLite3 Custom CEL Module" remove_on_change="cel/cel_sqlite3_custom.o cel/cel_sqlite3_custom.so">
+	<depend>sqlite3</depend>
+</member>
+<member name="cel_tds" displayname="FreeTDS CEL Backend" remove_on_change="cel/cel_tds.o cel/cel_tds.so">
+	<depend>freetds</depend>
+</member>
+</category>
+<category name="MENUSELECT_CHANNELS" displayname="Channel Drivers" remove_on_change="channels/modules.link">
+<member name="chan_agent" displayname="Agent Proxy Channel" remove_on_change="channels/chan_agent.o channels/chan_agent.so">
+        <depend>chan_local</depend>
+        <depend>res_monitor</depend>
+</member>
+<member name="chan_alsa" displayname="ALSA Console Channel Driver" remove_on_change="channels/chan_alsa.o channels/chan_alsa.so">
+	<depend>alsa</depend>
+</member>
+<member name="chan_bridge" displayname="Bridge Interaction Channel" remove_on_change="channels/chan_bridge.o channels/chan_bridge.so">
+</member>
+<member name="chan_console" displayname="Console Channel Driver" remove_on_change="channels/chan_console.o channels/chan_console.so">
+	<depend>portaudio</depend>
+</member>
+<member name="chan_dahdi" displayname="DAHDI Telephony" remove_on_change="channels/chan_dahdi.o channels/chan_dahdi.so">
+	<use>res_smdi</use>
+	<depend>dahdi</depend>
+	<depend>tonezone</depend>
+	<use>pri</use>
+	<use>ss7</use>
+	<use>openr2</use>
+</member>
+<member name="chan_gtalk" displayname="Gtalk Channel Driver" remove_on_change="channels/chan_gtalk.o channels/chan_gtalk.so">
+	<depend>iksemel</depend>
+	<depend>res_jabber</depend>
+	<use>openssl</use>
+</member>
+<member name="chan_h323" displayname="The NuFone Network's OpenH323 Channel Driver" remove_on_change="channels/chan_h323.o channels/chan_h323.so">
+	<depend>openh323</depend>
+	<defaultenabled>yes</defaultenabled>
+</member>
+<member name="chan_iax2" displayname="Inter Asterisk eXchange (Ver 2)" remove_on_change="channels/chan_iax2.o channels/chan_iax2.so">
+	<use>crypto</use>
+</member>
+<member name="chan_jingle" displayname="Jingle Channel Driver" remove_on_change="channels/chan_jingle.o channels/chan_jingle.so">
+	<depend>iksemel</depend>
+	<depend>res_jabber</depend>
+	<use>openssl</use>
+</member>
+<member name="chan_local" displayname="Local Proxy Channel (Note: used internally by other modules)" remove_on_change="channels/chan_local.o channels/chan_local.so">
+</member>
+<member name="chan_mgcp" displayname="Media Gateway Control Protocol (MGCP)" remove_on_change="channels/chan_mgcp.o channels/chan_mgcp.so">
+        <use>res_pktccops</use>
+</member>
+<member name="chan_misdn" displayname="Channel driver for mISDN Support (BRI/PRI)" remove_on_change="channels/chan_misdn.o channels/chan_misdn.so">
+	<depend>isdnnet</depend>
+	<depend>misdn</depend>
+	<depend>suppserv</depend>
+</member>
+<member name="chan_multicast_rtp" displayname="Multicast RTP Paging Channel" remove_on_change="channels/chan_multicast_rtp.o channels/chan_multicast_rtp.so">
+</member>
+<member name="chan_nbs" displayname="Network Broadcast Sound Support" remove_on_change="channels/chan_nbs.o channels/chan_nbs.so">
+	<depend>nbs</depend>
+</member>
+<member name="chan_oss" displayname="OSS Console Channel Driver" remove_on_change="channels/chan_oss.o channels/chan_oss.so">
+	<depend>oss</depend>
+</member>
+<member name="chan_phone" displayname="Linux Telephony API Support" remove_on_change="channels/chan_phone.o channels/chan_phone.so">
+	<depend>ixjuser</depend>
+</member>
+<member name="chan_rtsp" displayname="Real Time Streaming Protocol (RTSP)" remove_on_change="channels/chan_rtsp.o channels/chan_rtsp.so">
+</member>
+<member name="chan_sip" displayname="Session Initiation Protocol (SIP)" remove_on_change="channels/chan_sip.o channels/chan_sip.so">
+	<use>res_crypto</use>
+	<depend>chan_local</depend>
+</member>
+<member name="chan_skinny" displayname="Skinny Client Control Protocol (Skinny)" remove_on_change="channels/chan_skinny.o channels/chan_skinny.so">
+</member>
+<member name="chan_unistim" displayname="UNISTIM Protocol (USTM)" remove_on_change="channels/chan_unistim.o channels/chan_unistim.so">
+</member>
+<member name="chan_usbradio" displayname="usb Console Channel Driver" remove_on_change="channels/chan_usbradio.o channels/chan_usbradio.so">
+	<depend>oss</depend>
+	<depend>alsa</depend>
+	<depend>usb</depend>
+	<defaultenabled>no</defaultenabled>
+</member>
+<member name="chan_vpb" displayname="Voicetronix API driver" remove_on_change="channels/chan_vpb.oo channels/chan_vpb.so">
+	<depend>vpb</depend>
+</member>
+</category>
+<category name="MENUSELECT_CODECS" displayname="Codec Translators" remove_on_change="codecs/modules.link">
+<member name="codec_a_mu" displayname="A-law and Mulaw direct Coder/Decoder" remove_on_change="codecs/codec_a_mu.o codecs/codec_a_mu.so">
+</member>
+<member name="codec_adpcm" displayname="Adaptive Differential PCM Coder/Decoder" remove_on_change="codecs/codec_adpcm.o codecs/codec_adpcm.so">
+</member>
+<member name="codec_alaw" displayname="A-law Coder/Decoder" remove_on_change="codecs/codec_alaw.o codecs/codec_alaw.so">
+</member>
+<member name="codec_amr" displayname="AMR Coder/Decoder" remove_on_change="codecs/codec_amr.o codecs/codec_amr.so">
+	
+</member>
+<member name="codec_dahdi" displayname="Generic DAHDI Transcoder Codec Translator" remove_on_change="codecs/codec_dahdi.o codecs/codec_dahdi.so">
+	<depend>dahdi</depend>
+</member>
+<member name="codec_g722" displayname="ITU G.722-64kbps G722 Transcoder" remove_on_change="codecs/codec_g722.o codecs/codec_g722.so">
+</member>
+<member name="codec_g726" displayname="ITU G.726-32kbps G726 Transcoder" remove_on_change="codecs/codec_g726.o codecs/codec_g726.so">
+</member>
+<member name="codec_gsm" displayname="GSM Coder/Decoder" remove_on_change="codecs/codec_gsm.o codecs/codec_gsm.so">
+	<depend>gsm</depend>
+</member>
+<member name="codec_ilbc" displayname="iLBC Coder/Decoder" remove_on_change="codecs/codec_ilbc.o codecs/codec_ilbc.so">
+	<defaultenabled>no</defaultenabled>
+</member>
+<member name="codec_lpc10" displayname="LPC10 2.4kbps Coder/Decoder" remove_on_change="codecs/codec_lpc10.o codecs/codec_lpc10.so">
+</member>
+<member name="codec_resample" displayname="SLIN Resampling Codec" remove_on_change="codecs/codec_resample.o codecs/codec_resample.so">
+	<depend>resample</depend>
+</member>
+<member name="codec_speex" displayname="Speex Coder/Decoder" remove_on_change="codecs/codec_speex.o codecs/codec_speex.so">
+	<depend>speex</depend>
+	<depend>speex_preprocess</depend>
+	<use>speexdsp</use>
+</member>
+<member name="codec_ulaw" displayname="mu-Law Coder/Decoder" remove_on_change="codecs/codec_ulaw.o codecs/codec_ulaw.so">
+</member>
+</category>
+<category name="MENUSELECT_FORMATS" displayname="Format Interpreters" remove_on_change="formats/modules.link">
+<member name="format_g719" displayname="ITU G.719" remove_on_change="formats/format_g719.o formats/format_g719.so">
+</member>
+<member name="format_g723" displayname="G.723.1 Simple Timestamp File Format" remove_on_change="formats/format_g723.o formats/format_g723.so">
+</member>
+<member name="format_g726" displayname="Raw G.726 (16/24/32/40kbps) data" remove_on_change="formats/format_g726.o formats/format_g726.so">
+</member>
+<member name="format_g729" displayname="Raw G.729 data" remove_on_change="formats/format_g729.o formats/format_g729.so">
+</member>
+<member name="format_gsm" displayname="Raw GSM data" remove_on_change="formats/format_gsm.o formats/format_gsm.so">
+</member>
+<member name="format_h263" displayname="Raw H.263 data" remove_on_change="formats/format_h263.o formats/format_h263.so">
+</member>
+<member name="format_h264" displayname="Raw H.264 data" remove_on_change="formats/format_h264.o formats/format_h264.so">
+</member>
+<member name="format_ilbc" displayname="Raw iLBC data" remove_on_change="formats/format_ilbc.o formats/format_ilbc.so">
+</member>
+<member name="format_jpeg" displayname="jpeg (joint picture experts group) image format" remove_on_change="formats/format_jpeg.o formats/format_jpeg.so">
+</member>
+<member name="format_ogg_vorbis" displayname="OGG/Vorbis audio" remove_on_change="formats/format_ogg_vorbis.o formats/format_ogg_vorbis.so">
+	<depend>vorbis</depend>
+	<depend>ogg</depend>
+</member>
+<member name="format_pcm" displayname="Raw/Sun uLaw/ALaw 8KHz (PCM,PCMA,AU), G.722 16Khz" remove_on_change="formats/format_pcm.o formats/format_pcm.so">
+</member>
+<member name="format_siren14" displayname="ITU G.722.1 Annex C (Siren14, licensed from Polycom)" remove_on_change="formats/format_siren14.o formats/format_siren14.so">
+</member>
+<member name="format_siren7" displayname="ITU G.722.1 (Siren7, licensed from Polycom)" remove_on_change="formats/format_siren7.o formats/format_siren7.so">
+</member>
+<member name="format_sln" displayname="Raw Signed Linear Audio support (SLN)" remove_on_change="formats/format_sln.o formats/format_sln.so">
+</member>
+<member name="format_sln16" displayname="Raw Signed Linear 16KHz Audio support (SLN16)" remove_on_change="formats/format_sln16.o formats/format_sln16.so">
+</member>
+<member name="format_vox" displayname="Dialogic VOX (ADPCM) File Format" remove_on_change="formats/format_vox.o formats/format_vox.so">
+</member>
+<member name="format_wav" displayname="Microsoft WAV/WAV16 format (8kHz/16kHz Signed Linear)" remove_on_change="formats/format_wav.o formats/format_wav.so">
+</member>
+<member name="format_wav_gsm" displayname="Microsoft WAV format (Proprietary GSM)" remove_on_change="formats/format_wav_gsm.o formats/format_wav_gsm.so">
+</member>
+</category>
+<category name="MENUSELECT_FUNCS" displayname="Dialplan Functions" remove_on_change="funcs/modules.link">
+<member name="func_aes" displayname="AES dialplan functions" remove_on_change="funcs/func_aes.o funcs/func_aes.so">
+	<use>crypto</use>
+</member>
+<member name="func_audiohookinherit" displayname="Audiohook inheritance function" remove_on_change="funcs/func_audiohookinherit.o funcs/func_audiohookinherit.so">
+</member>
+<member name="func_base64" displayname="base64 encode/decode dialplan functions" remove_on_change="funcs/func_base64.o funcs/func_base64.so">
+</member>
+<member name="func_blacklist" displayname="Look up Caller*ID name/number from blacklist database" remove_on_change="funcs/func_blacklist.o funcs/func_blacklist.so">
+</member>
+<member name="func_callcompletion" displayname="Call Control Configuration Function" remove_on_change="funcs/func_callcompletion.o funcs/func_callcompletion.so">
+</member>
+<member name="func_callerid" displayname="Party ID related dialplan functions (Caller-ID, Connected-line, Redirecting)" remove_on_change="funcs/func_callerid.o funcs/func_callerid.so">
+</member>
+<member name="func_cdr" displayname="Call Detail Record (CDR) dialplan function" remove_on_change="funcs/func_cdr.o funcs/func_cdr.so">
+</member>
+<member name="func_channel" displayname="Channel information dialplan functions" remove_on_change="funcs/func_channel.o funcs/func_channel.so">
+</member>
+<member name="func_config" displayname="Asterisk configuration file variable access" remove_on_change="funcs/func_config.o funcs/func_config.so">
+</member>
+<member name="func_curl" displayname="Load external URL" remove_on_change="funcs/func_curl.o funcs/func_curl.so">
+	<depend>curl</depend>
+</member>
+<member name="func_cut" displayname="Cut out information from a string" remove_on_change="funcs/func_cut.o funcs/func_cut.so">
+</member>
+<member name="func_db" displayname="Database (astdb) related dialplan functions" remove_on_change="funcs/func_db.o funcs/func_db.so">
+</member>
+<member name="func_devstate" displayname="Gets or sets a device state in the dialplan" remove_on_change="funcs/func_devstate.o funcs/func_devstate.so">
+</member>
+<member name="func_dialgroup" displayname="Dialgroup dialplan function" remove_on_change="funcs/func_dialgroup.o funcs/func_dialgroup.so">
+</member>
+<member name="func_dialplan" displayname="Dialplan Context/Extension/Priority Checking Functions" remove_on_change="funcs/func_dialplan.o funcs/func_dialplan.so">
+</member>
+<member name="func_enum" displayname="ENUM related dialplan functions" remove_on_change="funcs/func_enum.o funcs/func_enum.so">
+</member>
+<member name="func_env" displayname="Environment/filesystem dialplan functions" remove_on_change="funcs/func_env.o funcs/func_env.so">
+</member>
+<member name="func_extstate" displayname="Gets an extension's state in the dialplan" remove_on_change="funcs/func_extstate.o funcs/func_extstate.so">
+</member>
+<member name="func_frame_trace" displayname="Frame Trace for internal ast_frame debugging." remove_on_change="funcs/func_frame_trace.o funcs/func_frame_trace.so">
+</member>
+<member name="func_global" displayname="Variable dialplan functions" remove_on_change="funcs/func_global.o funcs/func_global.so">
+</member>
+<member name="func_groupcount" displayname="Channel group dialplan functions" remove_on_change="funcs/func_groupcount.o funcs/func_groupcount.so">
+</member>
+<member name="func_iconv" displayname="Charset conversions" remove_on_change="funcs/func_iconv.o funcs/func_iconv.so">
+    <depend>iconv</depend>
+</member>
+<member name="func_lock" displayname="Dialplan mutexes" remove_on_change="funcs/func_lock.o funcs/func_lock.so">
+</member>
+<member name="func_logic" displayname="Logical dialplan functions" remove_on_change="funcs/func_logic.o funcs/func_logic.so">
+</member>
+<member name="func_math" displayname="Mathematical dialplan function" remove_on_change="funcs/func_math.o funcs/func_math.so">
+</member>
+<member name="func_md5" displayname="MD5 digest dialplan functions" remove_on_change="funcs/func_md5.o funcs/func_md5.so">
+</member>
+<member name="func_module" displayname="Checks if Asterisk module is loaded in memory" remove_on_change="funcs/func_module.o funcs/func_module.so">
+</member>
+<member name="func_odbc" displayname="ODBC lookups" remove_on_change="funcs/func_odbc.o funcs/func_odbc.so">
+	<depend>res_odbc</depend>
+</member>
+<member name="func_pitchshift" displayname="Audio Effects Dialplan Functions" remove_on_change="funcs/func_pitchshift.o funcs/func_pitchshift.so">
+</member>
+<member name="func_rand" displayname="Random number dialplan function" remove_on_change="funcs/func_rand.o funcs/func_rand.so">
+</member>
+<member name="func_realtime" displayname="Read/Write/Store/Destroy values from a RealTime repository" remove_on_change="funcs/func_realtime.o funcs/func_realtime.so">
+</member>
+<member name="func_sha1" displayname="SHA-1 computation dialplan function" remove_on_change="funcs/func_sha1.o funcs/func_sha1.so">
+</member>
+<member name="func_shell" displayname="Returns the output of a shell command" remove_on_change="funcs/func_shell.o funcs/func_shell.so">
+</member>
+<member name="func_speex" displayname="Noise reduction and Automatic Gain Control (AGC)" remove_on_change="funcs/func_speex.o funcs/func_speex.so">
+	<depend>speex</depend>
+	<depend>speex_preprocess</depend>
+	<use>speexdsp</use>
+</member>
+<member name="func_sprintf" displayname="SPRINTF dialplan function" remove_on_change="funcs/func_sprintf.o funcs/func_sprintf.so">
+</member>
+<member name="func_srv" displayname="SRV related dialplan functions" remove_on_change="funcs/func_srv.o funcs/func_srv.so">
+</member>
+<member name="func_strings" displayname="String handling dialplan functions" remove_on_change="funcs/func_strings.o funcs/func_strings.so">
+</member>
+<member name="func_sysinfo" displayname="System information related functions" remove_on_change="funcs/func_sysinfo.o funcs/func_sysinfo.so">
+</member>
+<member name="func_timeout" displayname="Channel timeout dialplan functions" remove_on_change="funcs/func_timeout.o funcs/func_timeout.so">
+</member>
+<member name="func_uri" displayname="URI encode/decode dialplan functions" remove_on_change="funcs/func_uri.o funcs/func_uri.so">
+</member>
+<member name="func_version" displayname="Get Asterisk Version/Build Info" remove_on_change="funcs/func_version.o funcs/func_version.so">
+</member>
+<member name="func_vmcount" displayname="Indicator for whether a voice mailbox has messages in a given folder." remove_on_change="funcs/func_vmcount.o funcs/func_vmcount.so">
+</member>
+<member name="func_volume" displayname="Technology independent volume control" remove_on_change="funcs/func_volume.o funcs/func_volume.so">
+</member>
+</category>
+<category name="MENUSELECT_PBX" displayname="PBX Modules" remove_on_change="pbx/modules.link">
+<member name="pbx_ael" displayname="Asterisk Extension Language Compiler" remove_on_change="pbx/pbx_ael.o pbx/pbx_ael.so">
+	<depend>res_ael_share</depend>
+</member>
+<member name="pbx_config" displayname="Text Extension Configuration" remove_on_change="pbx/pbx_config.o pbx/pbx_config.so">
+</member>
+<member name="pbx_dundi" displayname="Distributed Universal Number Discovery (DUNDi)" remove_on_change="pbx/pbx_dundi.o pbx/pbx_dundi.so">
+	<depend>zlib</depend>
+	<use>crypto</use>
+</member>
+<member name="pbx_loopback" displayname="Loopback Switch" remove_on_change="pbx/pbx_loopback.o pbx/pbx_loopback.so">
+</member>
+<member name="pbx_lua" displayname="Lua PBX Switch" remove_on_change="pbx/pbx_lua.o pbx/pbx_lua.so">
+	<depend>lua</depend>
+</member>
+<member name="pbx_realtime" displayname="Realtime Switch" remove_on_change="pbx/pbx_realtime.o pbx/pbx_realtime.so">
+</member>
+<member name="pbx_spool" displayname="Outgoing Spool Support" remove_on_change="pbx/pbx_spool.o pbx/pbx_spool.so">
+</member>
+</category>
+<category name="MENUSELECT_RES" displayname="Resource Modules" remove_on_change="res/modules.link">
+<member name="res_adsi" displayname="ADSI Resource" remove_on_change="res/res_adsi.o res/res_adsi.so">
+</member>
+<member name="res_ael_share" displayname="share-able code for AEL" remove_on_change="res/res_ael_share.o res/res_ael_share.so">
+</member>
+<member name="res_agi" displayname="Asterisk Gateway Interface (AGI)" remove_on_change="res/res_agi.o res/res_agi.so">
+</member>
+<member name="res_ais" displayname="SAForum AIS" remove_on_change="res/res_ais.o res/res_ais.so">
+	<depend>ais</depend>
+</member>
+<member name="res_calendar" displayname="Asterisk Calendar integration" remove_on_change="res/res_calendar.o res/res_calendar.so">
+</member>
+<member name="res_calendar_caldav" displayname="Asterisk CalDAV Calendar Integration" remove_on_change="res/res_calendar_caldav.o res/res_calendar_caldav.so">
+	<depend>neon</depend>
+	<depend>ical</depend>
+	<depend>libxml2</depend>
+</member>
+<member name="res_calendar_ews" displayname="Asterisk MS Exchange Web Service Calendar Integration" remove_on_change="res/res_calendar_ews.o res/res_calendar_ews.so">
+	<depend>neon29</depend>
+</member>
+<member name="res_calendar_exchange" displayname="Asterisk MS Exchange Calendar Integration" remove_on_change="res/res_calendar_exchange.o res/res_calendar_exchange.so">
+	<depend>neon</depend>
+	<depend>ical</depend>
+	<depend>iksemel</depend>
+</member>
+<member name="res_calendar_icalendar" displayname="Asterisk iCalendar .ics file integration" remove_on_change="res/res_calendar_icalendar.o res/res_calendar_icalendar.so">
+	<depend>neon</depend>
+	<depend>ical</depend>
+</member>
+<member name="res_clialiases" displayname="CLI Aliases" remove_on_change="res/res_clialiases.o res/res_clialiases.so">
+</member>
+<member name="res_clioriginate" displayname="Call origination and redirection from the CLI" remove_on_change="res/res_clioriginate.o res/res_clioriginate.so">
+</member>
+<member name="res_config_curl" displayname="Realtime Curl configuration" remove_on_change="res/res_config_curl.o res/res_config_curl.so">
+	<depend>curl</depend>
+</member>
+<member name="res_config_ldap" displayname="LDAP realtime interface" remove_on_change="res/res_config_ldap.o res/res_config_ldap.so">
+	<depend>ldap</depend>
+</member>
+<member name="res_config_odbc" displayname="Realtime ODBC configuration" remove_on_change="res/res_config_odbc.o res/res_config_odbc.so">
+	<depend>res_odbc</depend>
+</member>
+<member name="res_config_pgsql" displayname="PostgreSQL RealTime Configuration Driver" remove_on_change="res/res_config_pgsql.o res/res_config_pgsql.so">
+	<depend>pgsql</depend>
+</member>
+<member name="res_config_sqlite" displayname="Realtime SQLite configuration" remove_on_change="res/res_config_sqlite.o res/res_config_sqlite.so">
+	<depend>sqlite</depend>
+</member>
+<member name="res_convert" displayname="File format conversion CLI command" remove_on_change="res/res_convert.o res/res_convert.so">
+</member>
+<member name="res_crypto" displayname="Cryptographic Digital Signatures" remove_on_change="res/res_crypto.o res/res_crypto.so">
+	<depend>openssl</depend>
+</member>
+<member name="res_curl" displayname="cURL Resource Module" remove_on_change="res/res_curl.o res/res_curl.so">
+	<depend>curl</depend>
+</member>
+<member name="res_fax" displayname="Generic FAX Applications" remove_on_change="res/res_fax.o res/res_fax.so">
+	<conflict>app_fax</conflict>
+</member>
+<member name="res_fax_spandsp" displayname="Spandsp G.711 and T.38 FAX Technologies" remove_on_change="res/res_fax_spandsp.o res/res_fax_spandsp.so">
+	<depend>spandsp</depend>
+	<depend>res_fax</depend>
+</member>
+<member name="res_http_post" displayname="HTTP POST support" remove_on_change="res/res_http_post.o res/res_http_post.so">
+	<depend>gmime</depend>
+</member>
+<member name="res_jabber" displayname="AJI - Asterisk Jabber Interface" remove_on_change="res/res_jabber.o res/res_jabber.so">
+	<depend>iksemel</depend>
+	<use>openssl</use>
+</member>
+<member name="res_limit" displayname="Resource limits" remove_on_change="res/res_limit.o res/res_limit.so">
+</member>
+<member name="res_monitor" displayname="Call Monitoring Resource" remove_on_change="res/res_monitor.o res/res_monitor.so">
+</member>
+<member name="res_musiconhold" displayname="Music On Hold Resource" remove_on_change="res/res_musiconhold.o res/res_musiconhold.so">
+	<conflict>win32</conflict>
+</member>
+<member name="res_mutestream" displayname="Mute audio stream resources" remove_on_change="res/res_mutestream.o res/res_mutestream.so">
+</member>
+<member name="res_odbc" displayname="ODBC resource" remove_on_change="res/res_odbc.o res/res_odbc.so">
+	<depend>generic_odbc</depend>
+	<depend>ltdl</depend>
+</member>
+<member name="res_phoneprov" displayname="HTTP Phone Provisioning" remove_on_change="res/res_phoneprov.o res/res_phoneprov.so">
+</member>
+<member name="res_pktccops" displayname="PktcCOPS manager for MGCP" remove_on_change="res/res_pktccops.o res/res_pktccops.so">
+        <defaultenabled>no</defaultenabled>
+</member>
+<member name="res_realtime" displayname="Realtime Data Lookup/Rewrite" remove_on_change="res/res_realtime.o res/res_realtime.so">
+</member>
+<member name="res_rtp_asterisk" displayname="Asterisk RTP Stack" remove_on_change="res/res_rtp_asterisk.o res/res_rtp_asterisk.so">
+</member>
+<member name="res_rtp_multicast" displayname="Multicast RTP Engine" remove_on_change="res/res_rtp_multicast.o res/res_rtp_multicast.so">
+</member>
+<member name="res_security_log" displayname="Security Event Logging" remove_on_change="res/res_security_log.o res/res_security_log.so">
+</member>
+<member name="res_smdi" displayname="Simplified Message Desk Interface (SMDI) Resource" remove_on_change="res/res_smdi.o res/res_smdi.so">
+</member>
+<member name="res_snmp" displayname="SNMP [Sub]Agent for Asterisk" remove_on_change="res/res_snmp.o res/res_snmp.so">
+	<depend>netsnmp</depend>
+</member>
+<member name="res_speech" displayname="Generic Speech Recognition API" remove_on_change="res/res_speech.o res/res_speech.so">
+</member>
+<member name="res_srtp" displayname="Secure RTP (SRTP)" remove_on_change="res/res_srtp.o res/res_srtp.so">
+         <depend>srtp</depend>
+</member>
+<member name="res_stun_monitor" displayname="STUN Network Monitor" remove_on_change="res/res_stun_monitor.o res/res_stun_monitor.so">
+</member>
+<member name="res_timing_dahdi" displayname="DAHDI Timing Interface" remove_on_change="res/res_timing_dahdi.o res/res_timing_dahdi.so">
+	<depend>dahdi</depend>
+</member>
+<member name="res_timing_kqueue" displayname="KQueue Timing Interface" remove_on_change="res/res_timing_kqueue.o res/res_timing_kqueue.so">
+	<depend>kqueue</depend>
+	<conflict>launchd</conflict>
+</member>
+<member name="res_timing_pthread" displayname="pthread Timing Interface" remove_on_change="res/res_timing_pthread.o res/res_timing_pthread.so">
+</member>
+<member name="res_timing_timerfd" displayname="Timerfd Timing Interface" remove_on_change="res/res_timing_timerfd.o res/res_timing_timerfd.so">
+	<depend>timerfd</depend>
+</member>
+</category>
+<category name="MENUSELECT_TESTS" displayname="Test Modules" remove_on_change="tests/modules.link">
+<member name="test_acl" displayname="ACL test module" remove_on_change="tests/test_acl.o tests/test_acl.so">
+	<depend>TEST_FRAMEWORK</depend>
+</member>
+<member name="test_amihooks" displayname="AMI Hook Test Module" remove_on_change="tests/test_amihooks.o tests/test_amihooks.so">
+	<defaultenabled>no</defaultenabled>
+</member>
+<member name="test_aoc" displayname="AOC unit tests" remove_on_change="tests/test_aoc.o tests/test_aoc.so">
+	<depend>TEST_FRAMEWORK</depend>
+</member>
+<member name="test_app" displayname="App unit tests" remove_on_change="tests/test_app.o tests/test_app.so">
+	<depend>TEST_FRAMEWORK</depend>
+</member>
+<member name="test_ast_format_str_reduce" displayname="ast_format_str_reduce() test module" remove_on_change="tests/test_ast_format_str_reduce.o tests/test_ast_format_str_reduce.so">
+	<depend>TEST_FRAMEWORK</depend>
+	<depend>format_g723</depend>
+	<depend>format_g726</depend>
+	<depend>format_g729</depend>
+	<depend>format_gsm</depend>
+	<depend>format_ogg_vorbis</depend>
+	<depend>format_pcm</depend>
+	<depend>format_siren14</depend>
+	<depend>format_siren7</depend>
+	<depend>format_sln</depend>
+	<depend>format_wav</depend>
+	<depend>format_wav_gsm</depend>
+</member>
+<member name="test_astobj2" displayname="ASTOBJ2 Unit Test" remove_on_change="tests/test_astobj2.o tests/test_astobj2.so">
+	<depend>TEST_FRAMEWORK</depend>
+</member>
+<member name="test_devicestate" displayname="Device State Test" remove_on_change="tests/test_devicestate.o tests/test_devicestate.so">
+	<depend>TEST_FRAMEWORK</depend>
+</member>
+<member name="test_dlinklists" displayname="Test Doubly-Linked Lists" remove_on_change="tests/test_dlinklists.o tests/test_dlinklists.so">
+	<defaultenabled>no</defaultenabled>
+</member>
+<member name="test_event" displayname="ast_event API Tests" remove_on_change="tests/test_event.o tests/test_event.so">
+	<depend>TEST_FRAMEWORK</depend>
+</member>
+<member name="test_expr" displayname="Expression evaluation tests" remove_on_change="tests/test_expr.o tests/test_expr.so">
+	<depend>TEST_FRAMEWORK</depend>
+</member>
+<member name="test_func_file" displayname="FILE() Tests" remove_on_change="tests/test_func_file.o tests/test_func_file.so">
+	<depend>TEST_FRAMEWORK</depend>
+</member>
+<member name="test_gosub" displayname="Gosub Tests" remove_on_change="tests/test_gosub.o tests/test_gosub.so">
+	<depend>TEST_FRAMEWORK</depend>
+</member>
+<member name="test_heap" displayname="Heap test module" remove_on_change="tests/test_heap.o tests/test_heap.so">
+	<depend>TEST_FRAMEWORK</depend>
+</member>
+<member name="test_locale" displayname="Locale tests" remove_on_change="tests/test_locale.o tests/test_locale.so">
+	<defaultenabled>no</defaultenabled>
+</member>
+<member name="test_logger" displayname="Logger Test Module" remove_on_change="tests/test_logger.o tests/test_logger.so">
+	<defaultenabled>no</defaultenabled>
+</member>
+<member name="test_pbx" displayname="PBX test module" remove_on_change="tests/test_pbx.o tests/test_pbx.so">
+	<depend>TEST_FRAMEWORK</depend>
+</member>
+<member name="test_poll" displayname="Poll test" remove_on_change="tests/test_poll.o tests/test_poll.so">
+	<depend>TEST_FRAMEWORK</depend>
+</member>
+<member name="test_sched" displayname="ast_sched performance test module" remove_on_change="tests/test_sched.o tests/test_sched.so">
+	<depend>TEST_FRAMEWORK</depend>
+</member>
+<member name="test_security_events" displayname="Test Security Event Generation" remove_on_change="tests/test_security_events.o tests/test_security_events.so">
+	<defaultenabled>no</defaultenabled>
+</member>
+<member name="test_skel" displayname="Skeleton (sample) Test" remove_on_change="tests/test_skel.o tests/test_skel.so">
+	<depend>TEST_FRAMEWORK</depend>
+</member>
+<member name="test_stringfields" displayname="String Fields Test" remove_on_change="tests/test_stringfields.o tests/test_stringfields.so">
+	<depend>TEST_FRAMEWORK</depend>
+</member>
+<member name="test_strings" displayname="Dynamic string test module" remove_on_change="tests/test_strings.o tests/test_strings.so">
+	<depend>TEST_FRAMEWORK</depend>
+</member>
+<member name="test_substitution" displayname="Substitution tests" remove_on_change="tests/test_substitution.o tests/test_substitution.so">
+	<depend>TEST_FRAMEWORK</depend>
+	<depend>func_curl</depend>
+</member>
+<member name="test_time" displayname="Time Tests" remove_on_change="tests/test_time.o tests/test_time.so">
+	<depend>TEST_FRAMEWORK</depend>
+</member>
+<member name="test_utils" displayname="Utils test module" remove_on_change="tests/test_utils.o tests/test_utils.so">
+	<depend>TEST_FRAMEWORK</depend>
+</member>
+</category>
+	<category name="MENUSELECT_CFLAGS" displayname="Compiler Flags" positive_output="yes" remove_on_change=".lastclean">
+		<member name="DONT_OPTIMIZE" displayname="Disable Optimizations by the Compiler">
+		</member>
+		<member name="DEBUG_THREADS" displayname="Enable Thread Debugging">
+		</member>
+		<member name="STATIC_BUILD" displayname="Build static binaries">
+		</member>
+		<member name="LOADABLE_MODULES" displayname="Runtime module loading">
+			<defaultenabled>yes</defaultenabled>
+		</member>
+		<member name="DEBUG_FD_LEAKS" displayname="Enable File Descriptor Leak Detection">
+		</member>
+		<member name="REBUILD_PARSERS" displayname="Rebuild AEL and expression parsers from bison/flex source files">
+			<depend>bison</depend>
+			<depend>flex</depend>
+			<defaultenabled>no</defaultenabled>
+		</member>
+		<member name="LOW_MEMORY" displayname="Optimize for Low Memory Usage">
+		</member>
+		<member name="USE_HOARD_ALLOCATOR" displayname="Use the Hoard Memory Allocator instead of the default system one">
+			<defaultenabled>no</defaultenabled>
+			<depend>hoard</depend>
+		</member>
+		<member name="LOTS_OF_SPANS" displayname="More than 32 DAHDI spans">
+		</member>
+		<member name="RADIO_RELAX" displayname="Relax DTMF for Radio Applications">
+		</member>
+		<member name="G711_NEW_ALGORITHM" displayname="Use the NEW ulaw/alaw codecs (slower, but cleaner)">
+			<defaultenabled>no</defaultenabled>
+		</member>
+		<member name="G711_REDUCED_BRANCHING" displayname="New ulaw/alaw codec, reduced branching (might help it run faster in some architectures)">
+			<depend>G711_NEW_ALGORITHM</depend>
+		</member>
+		<member name="TEST_CODING_TABLES" displayname="New ulaw/alaw codec, turn on table tests on init">
+			<depend>G711_NEW_ALGORITHM</depend>
+		</member>
+		<member name="TEST_TANDEM_TRANSCODING" displayname="New ulaw/alaw codec, turn on transcoding tests on init">
+			<depend>G711_NEW_ALGORITHM</depend>
+		</member>
+		<member name="MALLOC_DEBUG" displayname="Keep Track of Memory Allocations">
+		</member>
+		<member name="BUSYDETECT_TONEONLY" displayname="Enable additional comparision of only the tone duration not the silence part">
+			<conflict>BUSYDETECT_COMPARE_TONE_AND_SILENCE</conflict>
+			<defaultenabled>no</defaultenabled>
+		</member>
+		<member name="BUSYDETECT_COMPARE_TONE_AND_SILENCE" displayname="Assume that tone and silence have the same duration">
+			<conflict>BUSYDETECT_TONEONLY</conflict>
+			<defaultenabled>no</defaultenabled>
+		</member>
+		<member name="BUSYDETECT_DEBUG" displayname="Enable additional busy detection debugging">
+			<defaultenabled>no</defaultenabled>
+		</member>
+		<member name="IAX_OLD_FIND" displayname="Use the old, slow method of searching for IAX callnos">
+		</member>
+		<member name="INTEGER_CALLERID" displayname="Use the (less accurate) integer-based method for decoding FSK tones (for embedded systems)">
+		</member>
+	</category>
+<category name="MENUSELECT_OPTS_app_voicemail" displayname="Voicemail Build Options" positive_output="yes" touch_on_change="apps/app_voicemail.c apps/app_directory.c">
+	<member name="FILE_STORAGE" displayname="Storage of Voicemail using filesystem">
+		<conflict>ODBC_STORAGE</conflict>
+		<conflict>IMAP_STORAGE</conflict>
+		<defaultenabled>yes</defaultenabled>
+	</member>
+	<member name="ODBC_STORAGE" displayname="Storage of Voicemail using ODBC">
+		<depend>generic_odbc</depend>
+		<depend>ltdl</depend>
+		<conflict>IMAP_STORAGE</conflict>
+		<conflict>FILE_STORAGE</conflict>
+		<defaultenabled>no</defaultenabled>
+	</member>
+	<member name="IMAP_STORAGE" displayname="Storage of Voicemail using IMAP4">
+		<depend>imap_tk</depend>
+		<conflict>ODBC_STORAGE</conflict>
+		<conflict>FILE_STORAGE</conflict>
+		<use>openssl</use>
+		<defaultenabled>no</defaultenabled>
+	</member>
+</category>
+<category name="MENUSELECT_CFLAGS" displayname="Compiler Flags" positive_output="yes">
+	<member name="RADIO_RTX" displayname="Build RTX/DTX Radio Programming" touch_on_change="channels/chan_usbradio.c channels/xpmr/xpmr.h">
+		<defaultenabled>no</defaultenabled>
+		<depend>chan_usbradio</depend>
+	</member>
+	<member name="RADIO_XPMRX" displayname="Build Experimental Radio Protocols" touch_on_change="channels/chan_usbradio.c">
+		<defaultenabled>no</defaultenabled>
+		<depend>chan_usbradio</depend>
+	</member>
+</category>
+<category name="MENUSELECT_UTILS" displayname="Utilities" positive_output="yes">
+  <member name="aelparse">
+	<defaultenabled>no</defaultenabled>
+  </member>
+  <member name="astcanary">
+	<defaultenabled>yes</defaultenabled>
+  </member>
+  <member name="astman">
+	<defaultenabled>no</defaultenabled>
+	<depend>newt</depend>
+  </member>
+  <member name="check_expr">
+	<defaultenabled>no</defaultenabled>
+  </member>
+  <member name="check_expr2">
+	<defaultenabled>no</defaultenabled>
+  </member>
+  <member name="conf2ael">
+	<defaultenabled>no</defaultenabled>
+  </member>
+  <member name="hashtest">
+	<defaultenabled>no</defaultenabled>
+  </member>
+  <member name="hashtest2">
+	<defaultenabled>no</defaultenabled>
+  </member>
+  <member name="muted">
+	<defaultenabled>no</defaultenabled>
+  </member>
+  <member name="refcounter">
+	<defaultenabled>no</defaultenabled>
+  </member>
+  <member name="smsq">
+	<defaultenabled>no</defaultenabled>
+	<depend>popt</depend>
+  </member>
+  <member name="stereorize">
+	<defaultenabled>no</defaultenabled>
+  </member>
+  <member name="streamplayer">
+	<defaultenabled>no</defaultenabled>
+  </member>
+</category>
+<category name="MENUSELECT_AGIS" displayname="AGI Samples" positive_output="yes">
+  <member name="agi-test.agi">
+	<defaultenabled>no</defaultenabled>
+  </member>
+  <member name="eagi-test">
+	<defaultenabled>no</defaultenabled>
+  </member>
+  <member name="eagi-sphinx-test">
+	<defaultenabled>no</defaultenabled>
+  </member>
+  <member name="jukebox.agi">
+	<defaultenabled>no</defaultenabled>
+  </member>
+</category>
+	<category name="MENUSELECT_EMBED" displayname="Module Embedding" positive_output="yes" remove_on_change="main/asterisk">
+		<member name="ADDONS" displayname="Add-ons" remove_on_change="addons/*.o addons/*.oo">
+			<depend>gnu_ld</depend>
+		</member>
+		<member name="APPS" displayname="Applications" remove_on_change="apps/*.o apps/*.oo">
+			<depend>gnu_ld</depend>
+		</member>
+		<member name="BRIDGES" displayname="Bridging Technologies" remove_on_change="bridges/*.o bridges/*.oo">
+			<depend>gnu_ld</depend>
+		</member>
+		<member name="CDR" displayname="Call Detail Recording" remove_on_change="cdr/*.o cdr/*.oo">
+			<depend>gnu_ld</depend>
+		</member>
+		<member name="CHANNELS" displayname="Channels" remove_on_change="channels/*.o channels/*/*.o channels/*.oo channels/*/*.oo">
+			<depend>gnu_ld</depend>
+		</member>
+		<member name="CODECS" displayname="Coders/Decoders" remove_on_change="codecs/*.o codecs/*/*.o codecs/*/*/*.o codecs/*/*.a codecs/*/*/*.a codecs/*.oo codecs/*/*.oo">
+			<depend>gnu_ld</depend>
+		</member>
+		<member name="FORMATS" displayname="File Formats" remove_on_change="formats/*.o formats/*.oo">
+			<depend>gnu_ld</depend>
+		</member>
+		<member name="FUNCS" displayname="Dialplan Functions" remove_on_change="funcs/*.o funcs/*.oo">
+			<depend>gnu_ld</depend>
+		</member>
+		<member name="PBX" displayname="PBX Functionality" remove_on_change="pbx/*.o pbx/*/*.o pbx/*.oo pbx/*/*.oo">
+			<depend>gnu_ld</depend>
+		</member>
+		<member name="RES" displayname="Resource Modules" remove_on_change="res/*.o res/*/*.o res/*.oo res/*/*.oo">
+			<depend>gnu_ld</depend>
+		</member>
+		<member name="TEST" displayname="Test Modules" remove_on_change="tests/*.o tests/*.oo">
+			<depend>gnu_ld</depend>
+		</member>
+	</category>
+	<category name="MENUSELECT_CORE_SOUNDS" displayname="Core Sound Packages" positive_output="yes">
+		<member name="CORE-SOUNDS-EN-WAV" displayname="English, WAV format">
+		</member>
+		<member name="CORE-SOUNDS-EN-ULAW" displayname="English, mu-Law format">
+		</member>
+		<member name="CORE-SOUNDS-EN-ALAW" displayname="English, a-Law format">
+		</member>
+		<member name="CORE-SOUNDS-EN-GSM" displayname="English, GSM format" >
+			<defaultenabled>yes</defaultenabled>
+		</member>
+		<member name="CORE-SOUNDS-EN-G729" displayname="English, G.729 format">
+		</member>
+		<member name="CORE-SOUNDS-EN-G722" displayname="English, G.722 format">
+		</member>
+		<member name="CORE-SOUNDS-EN-SLN16" displayname="English, Signed-linear 16kHz format">
+		</member>
+		<member name="CORE-SOUNDS-EN-SIREN7" displayname="English, G.722.1 (Siren7) format">
+		</member>
+		<member name="CORE-SOUNDS-EN-SIREN14" displayname="English, G.722.1C (Siren14) format">
+		</member>
+		<member name="CORE-SOUNDS-ES-WAV" displayname="Spanish, WAV format">
+		</member>
+		<member name="CORE-SOUNDS-ES-ULAW" displayname="Spanish, mu-Law format">
+		</member>
+		<member name="CORE-SOUNDS-ES-ALAW" displayname="Spanish, a-Law format">
+		</member>
+		<member name="CORE-SOUNDS-ES-GSM" displayname="Spanish, GSM format">
+		</member>
+		<member name="CORE-SOUNDS-ES-G729" displayname="Spanish, G.729 format">
+		</member>
+		<member name="CORE-SOUNDS-ES-G722" displayname="Spanish, G.722 format">
+		</member>
+		<member name="CORE-SOUNDS-ES-SLN16" displayname="Spanish, Signed-linear 16kHz format">
+		</member>
+		<member name="CORE-SOUNDS-ES-SIREN7" displayname="Spanish, G.722.1 (Siren7) format">
+		</member>
+		<member name="CORE-SOUNDS-ES-SIREN14" displayname="Spanish, G.722.1C (Siren14) format">
+		</member>
+		<member name="CORE-SOUNDS-FR-WAV" displayname="French, WAV format">
+		</member>
+		<member name="CORE-SOUNDS-FR-ULAW" displayname="French, mu-Law format">
+		</member>
+		<member name="CORE-SOUNDS-FR-ALAW" displayname="French, a-Law format">
+		</member>
+		<member name="CORE-SOUNDS-FR-GSM" displayname="French, GSM format">
+		</member>
+		<member name="CORE-SOUNDS-FR-G729" displayname="French, G.729 format">
+		</member>
+		<member name="CORE-SOUNDS-FR-G722" displayname="French, G.722 format">
+		</member>
+		<member name="CORE-SOUNDS-FR-SLN16" displayname="French, Signed-linear 16kHz format">
+		</member>
+		<member name="CORE-SOUNDS-FR-SIREN7" displayname="French, G.722.1 (Siren7) format">
+		</member>
+		<member name="CORE-SOUNDS-FR-SIREN14" displayname="French, G.722.1C (Siren14) format">
+		</member>
+		<member name="CORE-SOUNDS-EN_AU-WAV" displayname="English (Australian Accent), WAV format">
+		</member>
+		<member name="CORE-SOUNDS-EN_AU-ULAW" displayname="English (Australian Accent), mu-Law format">
+		</member>
+		<member name="CORE-SOUNDS-EN_AU-ALAW" displayname="English (Australian Accent), a-Law format">
+		</member>
+		<member name="CORE-SOUNDS-EN_AU-GSM" displayname="English (Australian Accent), GSM format">
+		</member>
+		<member name="CORE-SOUNDS-EN_AU-G729" displayname="English (Australian Accent), G.729 format">
+		</member>
+		<member name="CORE-SOUNDS-EN_AU-G722" displayname="English (Australian Accent), G.722 format">
+		</member>
+		<member name="CORE-SOUNDS-EN_AU-SLN16" displayname="English (Australian Accent), Signed-linear 16kHz format">
+		</member>
+		<member name="CORE-SOUNDS-EN_AU-SIREN7" displayname="English (Australian Accent), G.722.1 (Siren7) format">
+		</member>
+		<member name="CORE-SOUNDS-EN_AU-SIREN14" displayname="English (Australian Accent), G.722.1C (Siren14) format">
+		</member>
+	</category>
+	<category name="MENUSELECT_MOH" displayname="Music On Hold File Packages" positive_output="yes">
+		<member name="MOH-OPSOUND-WAV" displayname="opsound.org Music On Hold Files, WAV format" >
+			<defaultenabled>yes</defaultenabled>
+		</member>
+		<member name="MOH-OPSOUND-ULAW" displayname="opsound.org Music On Hold Files, mu-Law format" >
+		</member>
+		<member name="MOH-OPSOUND-ALAW" displayname="opsound.org Music On Hold Files, a-Law format" >
+		</member>
+		<member name="MOH-OPSOUND-GSM" displayname="opsound.org Music On Hold Files, GSM format" >
+		</member>
+		<member name="MOH-OPSOUND-G729" displayname="opsound.org Music On Hold Files, G.729 format" >
+		</member>
+		<member name="MOH-OPSOUND-G722" displayname="opsound.org Music On Hold Files, G.722 format" >
+		</member>
+		<member name="MOH-OPSOUND-SLN16" displayname="opsound.org Music On Hold Files, Signed-linear 16kHz format" >
+		</member>
+		<member name="MOH-OPSOUND-SIREN7" displayname="opsound.org Music On Hold Files, G.722.1 (Siren7) format" >
+		</member>
+		<member name="MOH-OPSOUND-SIREN14" displayname="opsound.org Music On Hold Files, G.722.1C (Siren14) format" >
+		</member>
+	</category>
+	<category name="MENUSELECT_EXTRA_SOUNDS" displayname="Extras Sound Packages" positive_output="yes">
+		<member name="EXTRA-SOUNDS-EN-WAV" displayname="English, WAV format">
+		</member>
+		<member name="EXTRA-SOUNDS-EN-ULAW" displayname="English, mu-Law format">
+		</member>
+		<member name="EXTRA-SOUNDS-EN-ALAW" displayname="English, a-Law format">
+		</member>
+		<member name="EXTRA-SOUNDS-EN-GSM" displayname="English, GSM format" >
+		</member>
+		<member name="EXTRA-SOUNDS-EN-G729" displayname="English, G.729 format">
+		</member>
+		<member name="EXTRA-SOUNDS-EN-G722" displayname="English, G.722 format">
+		</member>
+		<member name="EXTRA-SOUNDS-EN-SLN16" displayname="English, Signed-linear 16kHz format">
+		</member>
+		<member name="EXTRA-SOUNDS-EN-SIREN7" displayname="English, G.722.1 (Siren7) format">
+		</member>
+		<member name="EXTRA-SOUNDS-EN-SIREN14" displayname="English, G.722.1C (Siren14) format">
+		</member>
+		<member name="EXTRA-SOUNDS-FR-WAV" displayname="French, WAV format">
+		</member>
+		<member name="EXTRA-SOUNDS-FR-ULAW" displayname="French, mu-Law format">
+		</member>
+		<member name="EXTRA-SOUNDS-FR-ALAW" displayname="French, a-Law format">
+		</member>
+		<member name="EXTRA-SOUNDS-FR-GSM" displayname="French, GSM format" >
+		</member>
+		<member name="EXTRA-SOUNDS-FR-G729" displayname="French, G.729 format">
+		</member>
+		<member name="EXTRA-SOUNDS-FR-G722" displayname="French, G.722 format">
+		</member>
+		<member name="EXTRA-SOUNDS-FR-SLN16" displayname="French, Signed-linear 16kHz format">
+		</member>
+		<member name="EXTRA-SOUNDS-FR-SIREN7" displayname="French, G.722.1 (Siren7) format">
+		</member>
+		<member name="EXTRA-SOUNDS-FR-SIREN14" displayname="French, G.722.1C (Siren14) format">
+		</member>
+	</category>
+</menu>
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/pbx/pbx_spool.c asterisk-11.3.0.p000/pbx/pbx_spool.c
--- asterisk-base-11.3.0/pbx/pbx_spool.c	2013-05-02 16:10:15.129187830 +0100
+++ asterisk-11.3.0.p000/pbx/pbx_spool.c	2013-05-13 14:00:35.052687652 +0100
@@ -375,7 +375,7 @@
 		ast_verb(3, "Attempting call on %s/%s for application %s(%s) (Retry %d)\n", o->tech, o->dest, o->app, o->data, o->retries);
 		res = ast_pbx_outgoing_app(o->tech, o->capabilities, o->dest, o->waittime * 1000,
 			o->app, o->data, &reason, 2 /* wait to finish */, o->cid_num, o->cid_name,
-			o->vars, o->account, NULL);
+			o->vars, o->account, NULL, NULL);
 		o->vars = NULL;
 	} else {
 		ast_verb(3, "Attempting call on %s/%s for %s@%s:%d (Retry %d)\n", o->tech, o->dest, o->exten, o->context,o->priority, o->retries);
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/res/res_clioriginate.c asterisk-11.3.0.p000/res/res_clioriginate.c
--- asterisk-base-11.3.0/res/res_clioriginate.c	2013-05-02 16:11:05.608444737 +0100
+++ asterisk-11.3.0.p000/res/res_clioriginate.c	2013-05-13 14:01:42.996437812 +0100
@@ -74,7 +74,7 @@
 		return CLI_FAILURE;
 	}
 	ast_format_cap_add(cap, ast_format_set(&tmpfmt, AST_FORMAT_SLINEAR, 0));
-	ast_pbx_outgoing_app(chantech, cap, chandata, TIMEOUT * 1000, app, appdata, &reason, 0, NULL, NULL, NULL, NULL, NULL);
+	ast_pbx_outgoing_app(chantech, cap, chandata, TIMEOUT * 1000, app, appdata, &reason, 0, NULL, NULL, NULL, NULL, NULL, NULL);
 	cap = ast_format_cap_destroy(cap);
 
 	return CLI_SUCCESS;
