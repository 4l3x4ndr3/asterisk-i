diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/apps/app_wms.c asterisk-11.3.0/apps/app_wms.c
--- asterisk-base-11.3.0/apps/app_wms.c	2013-10-28 10:11:56.063637000 +0000
+++ asterisk-11.3.0/apps/app_wms.c	2013-11-18 14:03:16.751637193 +0000
@@ -166,6 +166,7 @@
    snprintf(chan_vars->trs_reply.body.userData, sizeof(chan_vars->trs_reply.body.userData), ast_channel_uniqueid(chan));
    snprintf(chan_vars->trs_reply.body.channelId, sizeof(chan_vars->trs_reply.body.channelId), ast_channel_name(chan));
    chan_vars->conf_thread = AST_PTHREADT_NULL;
+   chan_vars->fax_thread = AST_PTHREADT_NULL;
 
 	/* --> */
 	if (strchr((char *)data,'#') == NULL)	// INBOUND CALL
@@ -436,11 +437,17 @@
    if (!ast_opt_use_smra) run_asterisk_channel(chan, chan_vars);
    else run_smra_channel(chan, chan_vars);
 
+   if(chan_vars->fax_thread != AST_PTHREADT_NULL)
+   {
+      pthread_join(chan_vars->fax_thread, NULL);
+      chan_vars->fax_thread = AST_PTHREADT_NULL;
+   }
+
    shutdown(trs_sock_fd, SHUT_RDWR);
 	close(trs_sock_fd);
 	trs_sock_fd = -1;
 
-   if (chan_vars != NULL) 
+   if (chan_vars != NULL)
    {
       free(chan_vars);
       chan_vars = NULL;
@@ -583,6 +590,8 @@
    struct ast_frame *f;
    cmd_ast trs_cmd;
    int nbytes = 0;
+   int s_fax_tone_detected = 0;
+   reply_ast trs_reply;
 
    tempcs[0] = chan;
    numcs = 1;
@@ -598,7 +607,7 @@
          break;
 	   }
       // If conference is enabled or we are the 2nd channel in a route_endpoint, don't lock channel
-      if (chan_vars->conference.id || (ast_bridged_channel(chan) && chan_vars->action.type != ACTION_ROUEND)) 
+      if (chan_vars->conference.id || (ast_bridged_channel(chan) && chan_vars->action.type != ACTION_ROUEND) || chan_vars->fax.enabled)
       {
          //don't block channel 
          tempcs[0] = 0; numcs = 0;
@@ -635,6 +644,51 @@
          ast_indicate(chan, AST_CONTROL_PROGRESS);
          chan_vars->early_media = ast_tvnow();
       }
+
+      if(chan_vars->fax.enabled == FALSE)
+      {
+         if (ast_test_flag(ast_channel_inoflags(chan), FAX_TONE_CNG_DETECTED))
+         {
+            if (option_verbose >= 3)
+               ast_verbose(VERBOSE_PREFIX_3 "Fax Tone CNG detected on channel %s\n", ast_channel_name(chan));
+
+            s_fax_tone_detected = 1;
+
+            trs_reply.body.g_ret_value = 153; //FAX CNG Calling Tone (153)
+
+            trs_reply.error = FALSE;
+
+            trs_reply.event = UNSOLICITED_EVENT;
+            trs_reply.evt_type = USR_DEF_TONE_DETECTED;
+
+            asteriskSendReply(&trs_reply, chan_vars);
+
+            ast_channel_lock(chan);
+            ast_clear_flag(ast_channel_inoflags(chan), FAX_TONE_CNG_DETECTED);
+            ast_channel_unlock(chan);
+         }
+         else if(ast_test_flag(ast_channel_inoflags(chan), FAX_TONE_CED_DETECTED))
+         {
+            if (option_verbose >= 3)
+               ast_verbose(VERBOSE_PREFIX_3 "Fax Tone CED detected on channel %s\n", ast_channel_name(chan));
+
+            s_fax_tone_detected = 1;
+
+            trs_reply.body.g_ret_value = 150; //FAX CED Answer Tone (150)
+
+            trs_reply.error = FALSE;
+
+            trs_reply.event = UNSOLICITED_EVENT;
+            trs_reply.evt_type = USR_DEF_TONE_DETECTED;
+
+            asteriskSendReply(&trs_reply, chan_vars);
+
+            ast_channel_lock(chan);
+            ast_clear_flag(ast_channel_inoflags(chan), FAX_TONE_CED_DETECTED);
+            ast_channel_unlock(chan);
+         }
+      }
+
       who = ast_waitfor_nandfds(tempcs, numcs, &chan_vars->trs_fd, 1, NULL, &data_available, &chan_vars->ms);
 		if (!who && (data_available < 0) && (chan_vars->ms)) 
       {
@@ -654,7 +708,7 @@
          while ((nbytes = recv(chan_vars->trs_fd, &trs_cmd, sizeof(trs_cmd), 0)) > 0)
          {
             if (nbytes != sizeof(trs_cmd))
-         {
+            {
                ast_log(LOG_ERROR, "Got incomplete command on chan %s\n", ast_channel_name(chan));
                sleep(1000);
                continue;
@@ -685,24 +739,33 @@
                case CONCAL: connect_call(chan, trs_cmd, chan_vars); break;
 					case ACCICA: accept_icall(chan, trs_cmd, chan_vars); break;
                case REJICA: reject_icall(chan, trs_cmd, chan_vars); break;                  
+               case SNDFAX: send_fax(chan, trs_cmd, chan_vars); break;
+               case RCVFAX: receive_fax(chan, trs_cmd, chan_vars); break;
                default: ast_log(LOG_ERROR, "Got unknown cmd_id %d\n", trs_cmd.cmd_id); break;
 				}
          }
          if (!nbytes || (errno != EWOULDBLOCK && errno != EAGAIN))
          {
-            // Don't hangup again if already hanging up
-            if (chan_vars->shutdown) break;
-            
-            if (!nbytes || errno == ECONNRESET) ast_log(LOG_WARNING, "TRS socket closed on channel %s\n", ast_channel_name(chan));
-            else ast_log(LOG_ERROR, "TRS socket error (%d: %s) on channel %s\n", errno, strerror(errno), ast_channel_name(chan));
+            if (chan_vars->fax.enabled == FALSE)
+            {
+               // Don't hangup again if already hanging up
+               if (chan_vars->shutdown) break;
 
-				chan_vars->shutdown = 1;
-				
-            if (ast_channel_state(chan) != AST_STATE_UP)
-               ast_channel_hangupcause_set(chan, ast_channel_defhangcause(chan));
-            
-				// ast_softhangup(chan, AST_CAUSE_NORMAL);// hangup line
-            break;
+               //avoid error log if release endpoint during fax transmission
+               if(!ast_test_flag(ast_channel_inoflags(chan), EXEC_APP_EXIT))
+               {
+                  if (!nbytes || errno == ECONNRESET) ast_log(LOG_WARNING, "TRS socket closed on channel %s\n", ast_channel_name(chan));
+                  else ast_log(LOG_ERROR, "TRS socket error (%d: %s) on channel %s\n", errno, strerror(errno), ast_channel_name(chan));
+               }
+
+               chan_vars->shutdown = 1;
+
+               if (ast_channel_state(chan) != AST_STATE_UP)
+                  ast_channel_hangupcause_set(chan, ast_channel_defhangcause(chan));
+
+                ast_softhangup(chan, AST_CAUSE_NORMAL);// hangup line
+               break;
+            }
          }		
 		}
 
@@ -737,7 +800,10 @@
 	               asteriskSendReply(&chan_vars->trs_reply, chan_vars);
                }
             }
-				else if (f->frametype == AST_FRAME_DTMF && who == chan) process_digit(chan, chan_vars, f->subclass.integer);
+				else if (f->frametype == AST_FRAME_DTMF && who == chan && s_fax_tone_detected != 1)
+				{
+				   process_digit(chan, chan_vars, f->subclass.integer);
+				}
 				else if (f->frametype == AST_FRAME_CONTROL && who == chan && (f->subclass.integer == AST_CONTROL_HANGUP ||
                          f->subclass.integer == AST_CONTROL_BUSY || f->subclass.integer == AST_CONTROL_CONGESTION || f->subclass.integer == AST_CONTROL_TRANSFER))
 				{
@@ -859,6 +925,10 @@
             }
 				if (f) ast_frfree(f);
 			}
+         else if(s_fax_tone_detected == 1)
+         {
+            s_fax_tone_detected = 0;
+         }
 			else
 			{
             if (option_verbose >= 3)
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/apps/app_wms.h asterisk-11.3.0/apps/app_wms.h
--- asterisk-base-11.3.0/apps/app_wms.h	2013-10-28 10:11:56.055637000 +0000
+++ asterisk-11.3.0/apps/app_wms.h	2013-11-18 14:14:20.075887017 +0000
@@ -65,6 +65,9 @@
    asr_struct asr;
 	reply_ast trs_reply;
    int chan_id;                  // InoVox Channel ID
+   unsigned long con_id;      // connection id
+   unsigned long cmd_cnt;     // command count
+   endpoint_id edp_id;        // endpoint id
    struct
    {
       rec_frame recFrame;
@@ -107,7 +110,16 @@
 	   struct ast_channel *cs[2];		// channel queue used in route endpoint command
 	   char bridge_retkey;				// key used to return from bridged mode
 	   char FILE_URL[256];
-   }  action;
+   } action;
+   struct
+   {
+      int enabled;    // flag TRUE / FALSE
+      char fax_file[FAX_FILENAME_SIZE];     // file to send / receive
+      char csid[FAX_CSID_STR_SIZE];         // Customer Subscriber Identification
+      char header[FAX_HEADER_STR_SIZE+1];   // fax header to send
+      unsigned short max_baudrate;           // maximum transmission baud rate (2400 to 14400)
+   } fax;
+   pthread_t fax_thread;
 } ast_vars;
 
 #endif
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/apps/vsrvdefs.h asterisk-11.3.0/apps/vsrvdefs.h
--- asterisk-base-11.3.0/apps/vsrvdefs.h	2013-10-28 10:11:56.067637000 +0000
+++ asterisk-11.3.0/apps/vsrvdefs.h	2013-11-18 14:14:25.091637180 +0000
@@ -56,6 +56,18 @@
 /* Conference_event */
 #define USER_EXITED_CONFERENCE   0
 
+/* Fax Definitions */
+#define  FAX_FILENAME_SIZE    1024
+#define  FAX_COVERFNAME_SIZE  256
+#define  FAX_CSID_STR_SIZE    32
+#define  FAX_HEADER_STR_SIZE  132
+#define  FAX_MAXIO_FILES      10
+#define  FAX_HEADER_SHORT     0
+#define  FAX_HEADER_LONG      1
+#define  FAX_ERROR_MASK       0xD00 // Fax mask from SV_ERROR_MASK (see InoVox definition)
+
+#define  FAX_FORMAT_TIFF      0 // fax storage format
+
 /* Digit Streaming Definitions */
 #define STREAM_IGNORE      -1
 #define STREAM_STOP        0
@@ -94,7 +106,7 @@
 typedef char			   dnis[DIGIT_LENGTH];
 typedef char            loc_t[DIGIT_LENGTH];
 
-
+#define FAX_RESOURCE    0x0080   /* 0000 0000 1000 0000 Mask for FAX resource */
 
 /* Errors returned in the reply data structure */
 typedef enum error_value
@@ -229,6 +241,29 @@
    char trans_rec_fname[256];
 } ROUEND_PARAM;
 
+typedef struct
+{
+   char  fax_file[FAX_FILENAME_SIZE];     // file to send / receive
+   short source_type;                     // fax file type (0 - single file / 1 - list of files)
+   char  fn_cover[FAX_COVERFNAME_SIZE];   // cover filename to send
+   char  csid[FAX_CSID_STR_SIZE];         // Customer Subscriber Identification
+   char  header[FAX_HEADER_STR_SIZE+1];   // fax header to send
+   short header_type;                     // type of header to send (FAX_HEADER_SHORT or FAX_HEADER_LONG)
+   unsigned short max_baudrate;           // maximum transmission baud rate (2400 to 14400)
+}FAX_RES_PARAM;
+
+typedef struct
+{
+   int   event;      // event returned
+   int   chID;       // channel ID
+   int   status;     // status code of the operation (0 = OK)
+   int   pages;      // number of pages sent/received
+   int   speed;      // operation duration
+   int   resolution; // resolution of fax transmition
+   int   format;     // fax storage format
+   int   trsize;     // transfer size (bytes)
+}FAXREPLY;
+
 /* Termination conditions */
 typedef struct
 {
@@ -497,6 +532,7 @@
    char use_smra;
    SMRA_ATTRIB       smra_attrib;      // SMRA Attributes
    sdp_media sdp;
+   FAX_RES_PARAM fax_param;      // Fax parameters
 } cmd_ast;
 
 
@@ -526,6 +562,7 @@
       char              channelId[32];
       SMRA_ATTRIB       smra_attrib;      // SMRA Attributes
       sdp_media sdp;
+      FAXREPLY          fax_reply;
    } body;
 } reply_ast;
 // - LR - WARNING - LOOK OUT FOR SIZEOF(reply_ast) ...
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/apps/wms_aux.c asterisk-11.3.0/apps/wms_aux.c
--- asterisk-base-11.3.0/apps/wms_aux.c	2013-10-28 10:11:56.039637000 +0000
+++ asterisk-11.3.0/apps/wms_aux.c	2013-11-12 14:23:27.432926000 +0000
@@ -721,7 +721,21 @@
 }
 
 
+/******************************************************************************
+ *        NAME: fax_error_to_code
+ * DESCRIPTION: res_fax error to wms error code
+ *
+ *****************************************************************************/
+int fax_error_to_code(const char *fax_error)
+{
+
+   if (strcmp(fax_error, "FILE_ERROR") == 0)
+   {
+      return FILE_NOT_FOUND; // error reading file
+   }
 
+   return RESOURCE_ERROR;
+}
 
 
 
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/apps/wms_aux.h asterisk-11.3.0/apps/wms_aux.h
--- asterisk-base-11.3.0/apps/wms_aux.h	2013-10-28 10:11:56.043637000 +0000
+++ asterisk-11.3.0/apps/wms_aux.h	2013-11-18 14:14:30.095714876 +0000
@@ -44,5 +44,6 @@
 void post_error(cmd_ast trs_cmd, ast_vars *chan_vars, int event, int error);
 void send_asr(struct ast_frame *, ast_vars *);
 int asteriskSendReply(reply_ast *, ast_vars *);
+int fax_error_to_code(const char *fax_error);
 
 #endif
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/apps/wms_inoapi.c asterisk-11.3.0/apps/wms_inoapi.c
--- asterisk-base-11.3.0/apps/wms_inoapi.c	2013-10-28 10:11:56.059637000 +0000
+++ asterisk-11.3.0/apps/wms_inoapi.c	2013-11-18 14:14:35.099806989 +0000
@@ -80,6 +80,8 @@
  *  
  ******************************************************************************/
 static void *conference_thread(void *);
+static void *send_fax_thread(void *);
+static void *receive_fax_thread(void *);
 static struct ast_channel *wait_for_answer(struct ast_channel *, struct inast_localuser *, int *);
 static struct ast_channel *get_rtsp_chan(struct ast_channel *, char *);
 
@@ -385,16 +387,25 @@
    if (option_verbose >= 3)
       ast_verbose(VERBOSE_PREFIX_3 "Release on channel %s\n", ast_channel_name(chan));
 
-	if (chan_vars->asr.asr_sock > 2)
-	{
-		close(chan_vars->asr.asr_sock);
-		chan_vars->asr.asr_sock = -1;
-	}
-   if (trs_cmd.al_int_val2 >= 100) 
-      ast_channel_hangupcause_set(chan, trs_cmd.al_int_val2);
+   // stop fax operation
+   if (chan_vars->fax.enabled)
+   {
+      ast_verbose(VERBOSE_PREFIX_3 "FAX Release on channel %s\n", ast_channel_name(chan));
+      ast_set_flag(ast_channel_inoflags(chan), EXEC_APP_EXIT);
+   }
+   else
+   {
+      if (chan_vars->asr.asr_sock > 2)
+      {
+         close(chan_vars->asr.asr_sock);
+         chan_vars->asr.asr_sock = -1;
+      }
+      if (trs_cmd.al_int_val2 >= 100)
+         ast_channel_hangupcause_set(chan, trs_cmd.al_int_val2);
 
-	//ast_softhangup(chan, AST_CAUSE_NORMAL);// hangup line
-	chan_vars->shutdown = 1;
+      //ast_softhangup(chan, AST_CAUSE_NORMAL);// hangup line
+      chan_vars->shutdown = 1;
+   }
 }
 
 /******************************************************************************
@@ -429,6 +440,16 @@
 {
 	reply_ast trs_reply;
 
+   if (option_verbose >= 4)
+      ast_verbose(VERBOSE_PREFIX_4 "Stop Operation %d\n",trs_cmd.al_int_val1);
+
+   // stop fax operation
+   if (chan_vars->fax.enabled)
+   {
+      if(trs_cmd.al_int_val1 |= FAX_RESOURCE)
+      ast_set_flag(ast_channel_inoflags(chan), EXEC_APP_EXIT);
+   }
+
    // stop play announcement in conference
    if (chan_vars->conference.id) 
    {
@@ -1409,8 +1430,592 @@
 }
 
 
+/******************************************************************************
+ *        NAME: send_fax()
+ * DESCRIPTION:
+ *
+ *****************************************************************************/
+void send_fax(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars)
+{
+   char s_chid[256];
+   reply_ast trs_reply;
+
+   chan_vars->con_id = trs_cmd.con_id;
+   chan_vars->cmd_cnt = trs_cmd.cmd_cnt;
+   chan_vars->edp_id = trs_cmd.edp_id;
+
+   memset(&trs_reply, 0, sizeof(trs_reply));
+   trs_reply.cmd_cnt = trs_cmd.cmd_cnt;
+   trs_reply.con_id = trs_cmd.con_id;
+   trs_reply.sender = trs_cmd.edp_id;
+   trs_reply.event = SEND_FAX_COMPLETED;
+   trs_reply.error = TRUE;
+
+   trs_reply.body.fax_reply.event = SEND_FAX_COMPLETED;      // event returned
+   trs_reply.body.fax_reply.chID = chan_vars->trs_reply.chan_id;   // channel ID
+   trs_reply.body.fax_reply.format = FAX_FORMAT_TIFF;     // fax storage format
+
+   if (option_verbose >= 4)
+       ast_verbose(VERBOSE_PREFIX_4 "send_fax: Fax call on channel %s\n",ast_channel_name(chan));
+
+   if (chan == NULL)
+   {
+      ast_log(LOG_ERROR, "send_fax: Chan is NULL\n");
+   }
+   else if (chan_vars->fax.enabled)
+   {
+      ast_log(LOG_ERROR, "send_fax: Fax already in use on ch %04d\n",trs_cmd.ch_index);
+   }
+   else
+   {
+      chan_vars->fax.enabled = TRUE;
+
+      if (!chan_vars->chan_id) chan_vars->chan_id = trs_cmd.ch_index; //channel id
+
+      snprintf(s_chid, sizeof(s_chid), "%d", trs_cmd.ch_index);
+
+      ast_channel_lock(chan);
+      pbx_builtin_setvar_helper(chan, "FAXCHINDEX", S_OR(s_chid, NULL));
+      pbx_builtin_setvar_helper(chan, "FAXCSID", S_OR(trs_cmd.fax_param.csid, NULL));
+      pbx_builtin_setvar_helper(chan, "FAXTRTOTALSIZE", NULL);
+      ast_channel_unlock(chan);
+
+      if(trs_cmd.fax_param.fax_file)
+      {
+         snprintf(chan_vars->fax.fax_file, sizeof(chan_vars->fax.fax_file), "%s", trs_cmd.fax_param.fax_file);
+
+         if (option_verbose >= 3)
+            ast_verbose(VERBOSE_PREFIX_3 "send_fax: |%s| on channel %s\n", trs_cmd.fax_param.fax_file, ast_channel_name(chan));
+
+         snprintf(chan_vars->fax.csid, sizeof(chan_vars->fax.fax_file), "%s", trs_cmd.fax_param.csid);
+         snprintf(chan_vars->fax.header, sizeof(chan_vars->fax.fax_file), "%s", trs_cmd.fax_param.header);
+         chan_vars->fax.max_baudrate = trs_cmd.fax_param.max_baudrate;
+
+         if (ast_pthread_create_background(&chan_vars->fax_thread, NULL, send_fax_thread, chan_vars) < 0)
+         {
+            ast_log(LOG_ERROR, "send_fax: thread creation ERROR |%s| for fax %s on ch %04d - %s\n", strerror(errno),
+                  trs_cmd.fax_param.fax_file, trs_cmd.ch_index, ast_channel_name(chan));
+         }
+         else
+         {
+            // Thread create with success, it is not necessary to send a event reply
+            if (option_verbose >= 3)
+                 ast_verbose(VERBOSE_PREFIX_3 "send_fax: thread created for |%s| on channel %s\n",
+                       trs_cmd.fax_param.fax_file, ast_channel_name(chan));
+
+            return;
+         }
+
+      }
+      else  // error file missing
+      {
+         ast_log(LOG_WARNING, "send_fax: File missing on channel %s\n", ast_channel_name(chan));
+         trs_reply.body.error_value = FILE_NOT_FOUND;
+      }
+   }
+
+   ast_log(LOG_ERROR, "send_fax: error, sending event on ch %04d\n", trs_cmd.ch_index);
+   //Something wrong happen, send a event with error
+   asteriskSendReply(&trs_reply, chan_vars);
+
+   chan_vars->fax.enabled = FALSE;
+   return;
+}
+
+/******************************************************************************
+ *        NAME: send_fax_thread()
+ * DESCRIPTION: thread function, it is necessary to create a new thread because
+ *              pbx_exec blocks the thread. If the main thread is blocked it is
+ *              not possible to interrupt the operation.
+ *              (stop_operation, release_enpoint, ...)
+ *****************************************************************************/
+static void *send_fax_thread(void *data)
+{
+   char execCmd[FAX_FILENAME_SIZE+10];
+   char s_maxbaudrate[20];
+   struct ast_app *app; // AGI RELATED
+   reply_ast trs_reply;
+   int s_error = 0;
+   const char *s_tmp, *s_tmp2;
+   int s_result = 0;
+   time_t s_timeout;
+
+   struct ast_channel *chan;
+   ast_vars *chan_vars;
+
+   chan_vars = (ast_vars *) data;
+   chan = chan_vars->chan;
+
+   memset(&trs_reply, 0, sizeof(trs_reply));
+
+   trs_reply.con_id = chan_vars->con_id;
+   trs_reply.cmd_cnt = chan_vars->cmd_cnt;
+   trs_reply.sender = chan_vars->edp_id;
+
+   trs_reply.event = SEND_FAX_COMPLETED;
+   trs_reply.error = TRUE;
+
+   trs_reply.body.fax_reply.event = SEND_FAX_COMPLETED;      // event returned
+   trs_reply.body.fax_reply.chID = chan_vars->trs_reply.chan_id;   // channel ID
+   trs_reply.body.fax_reply.format = FAX_FORMAT_TIFF;     // fax storage format
+
+   // ->$CSID->$HEADER->$FAX_FILE->$FAX_COVER->#HEADER_TYPE->#MAX_BAUD->
+   if ((app = pbx_findapp("SendFAX"))) // application found// AGI RELATED
+   {
+
+      snprintf(execCmd, sizeof(execCmd), "%s,dfzs", chan_vars->fax.fax_file);
+
+      if(chan_vars->fax.csid)
+      {
+         ast_func_write(chan, "FAXOPT(LocalStationID)", chan_vars->fax.csid);
+      }
+
+      if (chan_vars->fax.header)
+      {
+         ast_func_write(chan, "FAXOPT(headerinfo)", chan_vars->fax.header);
+      }
+
+      if (chan_vars->fax.max_baudrate)
+      {
+         sprintf(s_maxbaudrate, "%d",chan_vars->fax.max_baudrate);
+         ast_func_write(chan, "FAXOPT(maxrate)", (const char *)s_maxbaudrate);
+      }
+
+      ast_channel_ref(chan); // when calling a new app is necessary to increase the channel ref
+      s_result = pbx_exec(chan, app, execCmd);
+      ast_channel_unref(chan);
+
+      if(ast_test_flag(ast_channel_inoflags(chan), EXEC_APP_EXIT))
+      {
+         // event changed, maybe a release_enpoind or stop_operation
+         // return without sending an event
+         if (option_verbose >= 3)
+            ast_verbose(VERBOSE_PREFIX_3 "send_fax_thread: Fax stopped on channel %s\n", ast_channel_name(chan));
+
+         // Clear FAX_TONE_DETECTED flag in case it was activated
+         ast_channel_lock(chan);
+         ast_clear_flag(ast_channel_inoflags(chan), FAX_TONE_CNG_DETECTED);
+         ast_clear_flag(ast_channel_inoflags(chan), FAX_TONE_CED_DETECTED);
+         ast_channel_unlock(chan);
+
+         chan_vars->fax.enabled = FALSE;
+
+         return NULL;
+      }
+
+      if(s_result != 0)
+      {
+         ast_log(LOG_ERROR, "send_fax_thread: pbx_exec result: %d on channel %s\n",s_result, ast_channel_name(chan));
+
+         ast_channel_lock(chan);
+         if((s_tmp = pbx_builtin_getvar_helper(chan, "FAXERROR")))
+         {
+            if((s_tmp2 = pbx_builtin_getvar_helper(chan, "FAXERRORVALUE")))
+            {
+               sscanf(s_tmp2,"%d", &s_error);
+               ast_log(LOG_ERROR, "send_fax_thread: FAXERRORVALUE is s_error: %d + FAX_ERROR_MASK: %d\n", s_error, FAX_ERROR_MASK);
+               trs_reply.body.fax_reply.status = s_error + FAX_ERROR_MASK; // FAILED
+               trs_reply.body.error_value = s_error + FAX_ERROR_MASK; // FAILED
+            }
+            else
+            {
+               s_error = fax_error_to_code(s_tmp);
+               ast_log(LOG_ERROR, "send_fax_thread: FAXERROR is s_error: %d\n", s_error);
+
+               trs_reply.body.fax_reply.status = s_error; // FAILED
+               trs_reply.body.error_value = s_error; // FAILED
+            }
+         }
+         else
+         {
+            ast_log(LOG_ERROR, "send_fax_thread: FAXERROR is NULL\n");
+            trs_reply.body.fax_reply.status = RESOURCE_ERROR;
+            trs_reply.body.error_value = RESOURCE_ERROR; // FAILED
+         }
+         ast_channel_unlock(chan);
+
+      }
+      else
+      { // wait for phase E callback to return
+
+         ast_verbose(VERBOSE_PREFIX_3 "send_fax_thread: Wait for phase E callback on ch %d\n",
+                                   chan_vars->trs_reply.chan_id);
+
+         s_timeout = ast_tvnow().tv_sec + 30; // wait 30 seconds before timeout
+
+         while(1)
+         {
+            if (ast_test_flag(ast_channel_inoflags(chan), FAX_PHASE_E_EXIT))
+            {
+
+               ast_channel_lock(chan);
+
+               if((s_tmp = pbx_builtin_getvar_helper(chan, "FAXSTATUS")) != NULL )
+               {
+                  if(strncmp(s_tmp,"SUCCESS",7))
+                  {
+                     if((s_tmp = pbx_builtin_getvar_helper(chan, "FAXERRORVALUE")))
+                     {
+                        sscanf(s_tmp,"%d", &s_error);
+                        ast_log(LOG_ERROR, "send_fax_thread: FAXERRORVALUE is s_error: %d + FAX_ERROR_MASK: %d\n", s_error, FAX_ERROR_MASK);
+                        trs_reply.body.fax_reply.status = s_error + FAX_ERROR_MASK; // FAILED
+                        trs_reply.body.error_value = s_error + FAX_ERROR_MASK; // FAILED
+                     }
+                     else
+                     {
+                        ast_log(LOG_ERROR, "send_fax_thread: FAXERRORVALUE is NULL\n");
+                        trs_reply.body.fax_reply.status = FAX_ERROR_MASK;
+                        trs_reply.body.error_value = FAX_ERROR_MASK; // FAILED
+                     }
+                  }
+                  else
+                  {
+                     if (option_verbose >= 3)
+                        ast_verbose(VERBOSE_PREFIX_3 "send_fax_thread: Fax status successful on ch %d\n",
+                                   chan_vars->trs_reply.chan_id);
+
+                     trs_reply.body.fax_reply.status = 0; // SUCCESS
+                     trs_reply.error = FALSE;
+                  }
+
+               }
+               else
+               {
+                  ast_log(LOG_ERROR, "send_fax_thread: FAXERRORVALUE is NULL\n");
+                  trs_reply.body.fax_reply.status = FAX_ERROR_MASK;
+                  trs_reply.body.error_value = FAX_ERROR_MASK; // FAILED
+               }
+
+               if((s_tmp = pbx_builtin_getvar_helper(chan, "FAXBITRATE")))
+                  sscanf(s_tmp,"%d",&trs_reply.body.fax_reply.speed);
+               if((s_tmp = pbx_builtin_getvar_helper(chan, "FAXRESOLUTION")))
+                  sscanf(s_tmp,"%d",&trs_reply.body.fax_reply.resolution);
+               if((s_tmp = pbx_builtin_getvar_helper(chan, "FAXPAGES")))
+                  sscanf(s_tmp,"%d",&trs_reply.body.fax_reply.pages);
+               if((s_tmp = pbx_builtin_getvar_helper(chan, "FAXTRTOTALSIZE")))
+                  sscanf(s_tmp,"%d",&trs_reply.body.fax_reply.trsize);
+
+               ast_channel_unlock(chan);
+
+               ast_clear_flag(ast_channel_inoflags(chan), FAX_PHASE_E_EXIT);
+               break;
+            }
+
+            if (s_timeout < ast_tvnow().tv_sec)
+               break;
+
+            usleep(100000);
+         }
+      }
+
+   }
+   else // application doesn't exist
+   {
+      ast_log(LOG_WARNING, "send_fax_thread: pbx_findapp failed on channel %s\n", ast_channel_name(chan));
+      trs_reply.body.error_value = RESOURCE_ERROR;
+   }
+
+   // Clear FAX_TONE_DETECTED flag in case it was activated
+   ast_channel_lock(chan);
+   ast_clear_flag(ast_channel_inoflags(chan), FAX_TONE_CNG_DETECTED);
+   ast_clear_flag(ast_channel_inoflags(chan), FAX_TONE_CED_DETECTED);
+   ast_channel_unlock(chan);
+
+   if (option_verbose >= 3)
+      ast_verbose(VERBOSE_PREFIX_3 "send_fax_thread: Sending event SEND_FAX_COMPLETED on ch %d\n",
+                 chan_vars->trs_reply.chan_id);
+   // send event
+   asteriskSendReply(&trs_reply, chan_vars);
+
+   chan_vars->fax.enabled = FALSE;
+
+   return NULL;
+}
+
+/******************************************************************************
+ *        NAME: receive_fax()
+ * DESCRIPTION:
+ *
+ *****************************************************************************/
+void receive_fax(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars)
+{
+   reply_ast trs_reply;
+   char s_chid[8];
+
+   chan_vars->con_id = trs_cmd.con_id;
+   chan_vars->cmd_cnt = trs_cmd.cmd_cnt;
+   chan_vars->edp_id = trs_cmd.edp_id;
+
+   memset(&trs_reply, 0, sizeof(trs_reply));
+   trs_reply.cmd_cnt = trs_cmd.cmd_cnt;
+   trs_reply.con_id = trs_cmd.con_id;
+   trs_reply.sender = trs_cmd.edp_id;
+
+   trs_reply.event = RECEIVE_FAX_COMPLETED;
+   trs_reply.error = TRUE;
+
+   trs_reply.body.fax_reply.event = RECEIVE_FAX_COMPLETED;      // event returned
+   trs_reply.body.fax_reply.chID = chan_vars->trs_reply.chan_id;       // channel ID
+   trs_reply.body.fax_reply.format = FAX_FORMAT_TIFF;     // fax storage format
+
+   if (chan == NULL)
+   {
+      ast_log(LOG_ERROR, "receive_fax: Chan is NULL\n");
+   }
+   else if (chan_vars->fax.enabled)
+   {
+      ast_log(LOG_ERROR, "receive_fax: Fax already in use on ch %04d\n",trs_cmd.ch_index);
+   }
+   else
+   {
+      chan_vars->fax.enabled = TRUE;
+
+      if (!chan_vars->chan_id) chan_vars->chan_id = trs_cmd.ch_index;
+
+      snprintf(s_chid, sizeof(s_chid), "%d", trs_cmd.ch_index);
+
+      ast_channel_lock(chan);
+      pbx_builtin_setvar_helper(chan, "FAXCHINDEX", S_OR(s_chid, NULL));
+      pbx_builtin_setvar_helper(chan, "FAXCSID", S_OR(trs_cmd.fax_param.csid, NULL));
+      pbx_builtin_setvar_helper(chan, "FAXTRTOTALSIZE", NULL);
+      ast_channel_unlock(chan);
+
+      ast_clear_flag(ast_channel_inoflags(chan), EXEC_APP_EXIT);
+
+      if(trs_cmd.fax_param.fax_file)
+      {
+         snprintf(chan_vars->fax.fax_file, sizeof(chan_vars->fax.fax_file), "%s", trs_cmd.fax_param.fax_file);
+
+         if (option_verbose >= 3)
+            ast_verbose(VERBOSE_PREFIX_3 "receive_fax |%s| on channel %s\n", trs_cmd.fax_param.fax_file, ast_channel_name(chan));
+
+         snprintf(chan_vars->fax.csid, sizeof(chan_vars->fax.fax_file), "%s", trs_cmd.fax_param.csid);
+         chan_vars->fax.max_baudrate = trs_cmd.fax_param.max_baudrate;
+
+         if (ast_pthread_create_background(&chan_vars->fax_thread, NULL, receive_fax_thread, chan_vars) < 0)
+         {
+            ast_log(LOG_ERROR, "receive_fax thread creation ERROR |%s| for fax %s on ch %04d - %s\n", strerror(errno),
+                  trs_cmd.fax_param.fax_file, trs_cmd.ch_index, ast_channel_name(chan));
+         }
+         else
+         {
+            // Thread create with success, it is not necessary to send a event reply
+            if (option_verbose >= 3)
+                 ast_verbose(VERBOSE_PREFIX_3 "receive_fax thread created for |%s| on channel %s\n", trs_cmd.fax_param.fax_file, ast_channel_name(chan));
+            return;
+         }
+      }
+      else // error file missing
+      {
+         ast_log(LOG_WARNING, "receive_fax: File missing on channel %s\n", ast_channel_name(chan));
+         trs_reply.body.error_value = FILE_NOT_FOUND;
+      }
+   }
+
+   chan_vars->fax.enabled = FALSE;
+   //Something wrong happen, send a event with error
+   asteriskSendReply(&trs_reply, chan_vars);
+   return;
+}
+
+
+/******************************************************************************
+ *        NAME: receive_fax_thread()
+ * DESCRIPTION: thread function, it is necessary to create a new thread because
+ *              pbx_exec blocks the thread. If the main thread is blocked it is
+ *              not possible to interrupt the operation.
+ *              (stop_operation, release_enpoint, ...)
+ *****************************************************************************/
+static void *receive_fax_thread(void *data)
+{
+   char execCmd[FAX_FILENAME_SIZE+10];
+   struct ast_app *app; // AGI RELATED
+   reply_ast trs_reply;
+   int s_error = 0;
+   const char *s_tmp, *s_tmp2;
+   int s_result = 0;
+   time_t s_timeout;
+   char s_maxbaudrate[8];
+
+   struct ast_channel *chan;
+   ast_vars *chan_vars;
+
+   chan_vars = (ast_vars *) data;
+   chan = chan_vars->chan;
+
+   memset(&trs_reply, 0, sizeof(trs_reply));
+
+   trs_reply.con_id = chan_vars->con_id;
+   trs_reply.cmd_cnt = chan_vars->cmd_cnt;
+   trs_reply.sender = chan_vars->edp_id;
+
+   trs_reply.event = RECEIVE_FAX_COMPLETED;
+   trs_reply.error = TRUE;
+
+   trs_reply.body.fax_reply.event = RECEIVE_FAX_COMPLETED;      // event returned
+   trs_reply.body.fax_reply.chID = chan_vars->trs_reply.chan_id;   // channel ID
+   trs_reply.body.fax_reply.format = FAX_FORMAT_TIFF;     // fax storage format
 
+   // ->$FAX_FILE->$CSID->#MAX_BAUD->
+   if ((app = pbx_findapp("ReceiveFAX"))) // application found// AGI RELATED
+   {
+
+      snprintf(execCmd, sizeof(execCmd), "%s,dfzs", chan_vars->fax.fax_file);
+
+      if(chan_vars->fax.csid)
+      {
+         ast_func_write(chan, "FAXOPT(LocalStationID)", chan_vars->fax.csid);
+      }
+
+      if (chan_vars->fax.max_baudrate)
+      {
+         sprintf(s_maxbaudrate, "%d",chan_vars->fax.max_baudrate);
+
+         if (option_verbose >= 3)
+                 ast_verbose(VERBOSE_PREFIX_3 "receive_fax maxbaudrate: %s on channel %s\n", s_maxbaudrate, ast_channel_name(chan));
+
+         ast_func_write(chan, "FAXOPT(maxrate)", (const char *)s_maxbaudrate);
+      }
+
+      ast_channel_ref(chan); // when calling a new app is necessary to increase the channel ref
+      s_result = pbx_exec(chan, app, execCmd);
+      ast_channel_unref(chan);
+
+      if (option_verbose >= 3)
+         ast_verbose(VERBOSE_PREFIX_3 "receive_fax_thread: Exiting ReceiveFax on channel %s\n", ast_channel_name(chan));
+
+      if(ast_test_flag(ast_channel_inoflags(chan), EXEC_APP_EXIT))
+      {
+         // event changed, maybe a release_enpoind or stop_operation
+         // return without sending an event
+         ast_log(LOG_DEBUG, "receive_fax_thread: Event different from RECEIVE_FAX_COMPLETED on ch %d on channel %s\n",
+               chan_vars->trs_reply.chan_id, ast_channel_name(chan));
+
+         // Clear FAX_TONE_DETECTED flag in case it was activated
+         ast_channel_lock(chan);
+         ast_clear_flag(ast_channel_inoflags(chan), FAX_TONE_CED_DETECTED);
+         ast_clear_flag(ast_channel_inoflags(chan), FAX_TONE_CNG_DETECTED);
+         ast_channel_unlock(chan);
 
+         chan_vars->fax.enabled = FALSE;
 
+         return NULL;
+      }
+
+      if(s_result != 0)
+      {
+         ast_log(LOG_ERROR, "receive_fax_thread: pbx_exec result: %d\n",s_result);
+
+         ast_channel_lock(chan);
+         if((s_tmp = pbx_builtin_getvar_helper(chan, "FAXERROR")))
+         {
 
+            if((s_tmp2 = pbx_builtin_getvar_helper(chan, "FAXERRORVALUE")))
+            {
+               sscanf(s_tmp2,"%d", &s_error);
+               ast_log(LOG_ERROR, "receive_fax_thread: FAXERRORVALUE is s_error: %d + FAX_ERROR_MASK: %d\n", s_error, FAX_ERROR_MASK);
+               trs_reply.body.fax_reply.status = s_error + FAX_ERROR_MASK; // FAILED
+               trs_reply.body.error_value = s_error + FAX_ERROR_MASK; // FAILED
+            }
+            else
+            {
+               s_error = fax_error_to_code(s_tmp);
+
+               ast_log(LOG_ERROR, "receive_fax_thread FAXERROR is s_error: %d\n", s_error);
+
+               trs_reply.body.fax_reply.status = s_error; // FAILED
+               trs_reply.body.error_value = s_error; // FAILED
+            }
+
+         }
+         else
+         {
+            ast_log(LOG_ERROR, "receive_fax_thread FAXERROR is NULL\n");
+            trs_reply.body.fax_reply.status = RESOURCE_ERROR;
+            trs_reply.body.error_value = RESOURCE_ERROR; // FAILED
+         }
+         ast_channel_unlock(chan);
 
+      }
+      else
+      { // wait for phase E callback to return
+
+         s_timeout = ast_tvnow().tv_sec + 30; // wait 30 seconds before timeout
+
+         while(1)
+         {
+            if (ast_test_flag(ast_channel_inoflags(chan), FAX_PHASE_E_EXIT))
+            {
+               ast_channel_lock(chan);
+
+               if((s_tmp = pbx_builtin_getvar_helper(chan, "FAXSTATUS")) != NULL )
+               {
+                  if(strncmp(s_tmp,"SUCCESS",7))
+                  {
+                     if((s_tmp = pbx_builtin_getvar_helper(chan, "FAXERRORVALUE")))
+                     {
+                        sscanf(s_tmp,"%d", &s_error);
+                        ast_log(LOG_ERROR, "receive_fax_thread: FAXERRORVALUE is s_error: %d + FAX_ERROR_MASK: %d\n", s_error, FAX_ERROR_MASK);
+                        trs_reply.body.fax_reply.status = s_error + FAX_ERROR_MASK; // FAILED
+                        trs_reply.body.error_value = s_error + FAX_ERROR_MASK; // FAILED
+                     }
+                     else
+                     {
+                        ast_log(LOG_ERROR, "receive_fax_thread FAXERRORVALUE is NULL\n");
+                        trs_reply.body.fax_reply.status = FAX_ERROR_MASK;
+                        trs_reply.body.error_value = FAX_ERROR_MASK; // FAILED
+                     }
+                  }
+                  else
+                  {
+                     trs_reply.body.fax_reply.status = 0; // SUCCESS
+                     trs_reply.error = FALSE;
+                  }
+               }
+               else
+               {
+                  ast_log(LOG_ERROR, "receive_fax_thread FAXERRORVALUE is NULL\n");
+                  trs_reply.body.fax_reply.status = FAX_ERROR_MASK;
+                  trs_reply.body.error_value = FAX_ERROR_MASK; // FAILED
+               }
+
+               if((s_tmp = pbx_builtin_getvar_helper(chan, "FAXBITRATE")))
+                  sscanf(s_tmp,"%d",&trs_reply.body.fax_reply.speed);
+               if((s_tmp = pbx_builtin_getvar_helper(chan, "FAXRESOLUTION")))
+                  sscanf(s_tmp,"%d",&trs_reply.body.fax_reply.resolution);
+               if((s_tmp = pbx_builtin_getvar_helper(chan, "FAXPAGES")))
+                  sscanf(s_tmp,"%d",&trs_reply.body.fax_reply.pages);
+               if((s_tmp = pbx_builtin_getvar_helper(chan, "FAXTRTOTALSIZE")))
+                  sscanf(s_tmp,"%d",&trs_reply.body.fax_reply.trsize);
+
+               ast_channel_unlock(chan);
+
+               ast_clear_flag(ast_channel_inoflags(chan), FAX_PHASE_E_EXIT);
+               break;
+            }
+
+            if (s_timeout < ast_tvnow().tv_sec)
+               break;
+
+            usleep(100000);
+         }
+      }
+   }
+   else // application doesn't exist
+   {
+      ast_log(LOG_WARNING, "receive_fax_thread: pbx_findapp failed on channel %s\n", ast_channel_name(chan));
+      trs_reply.body.error_value = RESOURCE_ERROR;
+   }
+
+   // Clear FAX_TONE_DETECTED flag in case it was activated
+   ast_channel_lock(chan);
+   ast_clear_flag(ast_channel_inoflags(chan), FAX_TONE_CED_DETECTED);
+   ast_clear_flag(ast_channel_inoflags(chan), FAX_TONE_CNG_DETECTED);
+   ast_channel_unlock(chan);
+
+   chan_vars->fax.enabled = FALSE;
+   // send event
+   asteriskSendReply(&trs_reply, chan_vars);
+
+   return NULL;
+}
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/apps/wms_inoapi.h asterisk-11.3.0/apps/wms_inoapi.h
--- asterisk-base-11.3.0/apps/wms_inoapi.h	2013-10-28 10:11:56.043637000 +0000
+++ asterisk-11.3.0/apps/wms_inoapi.h	2013-11-07 17:06:03.599887000 +0000
@@ -33,6 +33,8 @@
 void route_endpoint(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars);
 void stop_operation(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars);
 void conference_call(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars);
+void send_fax(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars);
+void receive_fax(struct ast_channel *chan, cmd_ast trs_cmd, ast_vars *chan_vars);
 
 //- Aux functions
 void kill_conference_thread(ast_vars *chan_vars);
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/channels/chan_sip.c asterisk-11.3.0/channels/chan_sip.c
--- asterisk-base-11.3.0/channels/chan_sip.c	2013-10-28 10:11:50.967887000 +0000
+++ asterisk-11.3.0/channels/chan_sip.c	2013-11-13 09:17:42.346046000 +0000
@@ -6558,7 +6558,7 @@
 	/* T.38 re-INVITE FAX detection should never be done for outgoing calls,
 	 * so ensure it is disabled.
 	 */
-	ast_clear_flag(&p->flags[1], SIP_PAGE2_FAX_DETECT_T38);
+	//ast_clear_flag(&p->flags[1], SIP_PAGE2_FAX_DETECT_T38);
 
 	if (p->options->transfer) {
 		char buf[SIPBUFSIZE/2];
@@ -8823,14 +8823,12 @@
 	struct ast_frame *fr;
 	struct sip_pvt *p = ast_channel_tech_pvt(ast);
 	int faxdetected = FALSE;
-
 	sip_pvt_lock(p);
 	fr = sip_rtp_read(ast, p, &faxdetected);
 	p->lastrtprx = time(NULL);
 
 	/* If we detect a CNG tone and fax detection is enabled then send us off to the fax extension */
 	if (faxdetected && ast_test_flag(&p->flags[1], SIP_PAGE2_FAX_DETECT_CNG)) {
-		if (strcmp(ast_channel_exten(ast), "fax")) {
 			const char *target_context = S_OR(ast_channel_macrocontext(ast), ast_channel_context(ast));
 			/* We need to unlock 'ast' here because
 			 * ast_exists_extension has the potential to start and
@@ -8839,23 +8837,15 @@
 			 */
 			sip_pvt_unlock(p);
 			ast_channel_unlock(ast);
-			if (ast_exists_extension(ast, target_context, "fax", 1,
-				S_COR(ast_channel_caller(ast)->id.number.valid, ast_channel_caller(ast)->id.number.str, NULL))) {
-				ast_channel_lock(ast);
-				sip_pvt_lock(p);
-				ast_verb(2, "Redirecting '%s' to fax extension due to CNG detection\n", ast_channel_name(ast));
-				pbx_builtin_setvar_helper(ast, "FAXEXTEN", ast_channel_exten(ast));
-				if (ast_async_goto(ast, target_context, "fax", 1)) {
-					ast_log(LOG_NOTICE, "Failed to async goto '%s' into fax of '%s'\n", ast_channel_name(ast), target_context);
-				}
-				ast_frfree(fr);
-				fr = &ast_null_frame;
-			} else {
-				ast_channel_lock(ast);
-				sip_pvt_lock(p);
-				ast_log(LOG_NOTICE, "FAX CNG detected but no fax extension\n");
-			}
-		}
+			ast_verb(2, "Fax detection on channel '%s'\n", ast_channel_name(ast));
+
+		   /* inbound or outbound call ? */
+		   if (ast_test_flag(&p->flags[0], SIP_OUTGOING))  {
+		      ast_set_flag(ast_channel_inoflags(p->owner), FAX_TONE_CED_DETECTED);
+		   } else {
+		      ast_set_flag(ast_channel_inoflags(p->owner), FAX_TONE_CNG_DETECTED);
+		   }
+
 	}
 
 	/* Only allow audio through if they sent progress with SDP, or if the channel is actually answered */
@@ -11116,22 +11106,16 @@
 				/* If fax detection is enabled then send us off to the fax extension */
 				if (ast_test_flag(&p->flags[1], SIP_PAGE2_FAX_DETECT_T38)) {
 					ast_channel_lock(p->owner);
-					if (strcmp(ast_channel_exten(p->owner), "fax")) {
-						const char *target_context = S_OR(ast_channel_macrocontext(p->owner), ast_channel_context(p->owner));
-						ast_channel_unlock(p->owner);
-						if (ast_exists_extension(p->owner, target_context, "fax", 1,
-							S_COR(ast_channel_caller(p->owner)->id.number.valid, ast_channel_caller(p->owner)->id.number.str, NULL))) {
-							ast_verb(2, "Redirecting '%s' to fax extension due to peer T.38 re-INVITE\n", ast_channel_name(p->owner));
-							pbx_builtin_setvar_helper(p->owner, "FAXEXTEN", ast_channel_exten(p->owner));
-							if (ast_async_goto(p->owner, target_context, "fax", 1)) {
-								ast_log(LOG_NOTICE, "Failed to async goto '%s' into fax of '%s'\n", ast_channel_name(p->owner), target_context);
-							}
-						} else {
-							ast_log(LOG_NOTICE, "T.38 re-INVITE detected but no fax extension\n");
-						}
-					} else {
-						ast_channel_unlock(p->owner);
-					}
+					ast_verb(2, "Fax T.38 detection on channel '%s'\n", ast_channel_name(p->owner));
+
+					/* inbound or outbound call ? */
+			      if (ast_test_flag(&p->flags[0], SIP_OUTGOING))  {
+			         ast_set_flag(ast_channel_inoflags(p->owner), FAX_TONE_CED_DETECTED);
+			      } else {
+			         ast_set_flag(ast_channel_inoflags(p->owner), FAX_TONE_CNG_DETECTED);
+			      }
+
+					ast_channel_unlock(p->owner);
 				}
 			}
 		} else {
@@ -11143,7 +11127,6 @@
 	}
 
 	if ((portno == -1) && (p->t38.state != T38_DISABLED) && (p->t38.state != T38_REJECTED)) {
-		ast_debug(3, "Have T.38 but no audio, accepting offer anyway\n");
 		res = 0;
 		goto process_sdp_cleanup;
 	}
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/include/asterisk/channel.h asterisk-11.3.0/include/asterisk/channel.h
--- asterisk-base-11.3.0/include/asterisk/channel.h	2013-10-28 10:11:52.271637000 +0000
+++ asterisk-11.3.0/include/asterisk/channel.h	2013-11-14 08:48:55.659068000 +0000
@@ -186,6 +186,10 @@
 #define MEETME_KICK_LAST      (1 << 12)
 #define MEETME_DO_RECORD      (1 << 13)
 
+#define FAX_TONE_CED_DETECTED (1 << 14)
+#define FAX_TONE_CNG_DETECTED (1 << 15)
+#define FAX_PHASE_E_EXIT      (1 << 16)
+
 #define EXEC_APP_EXIT         (1 << 17)
 #define SIP_GOT_REINVITE      (1 << 18)
 
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/include/asterisk/res_fax.h asterisk-11.3.0/include/asterisk/res_fax.h
--- asterisk-base-11.3.0/include/asterisk/res_fax.h	2013-10-28 10:11:52.127637000 +0000
+++ asterisk-11.3.0/include/asterisk/res_fax.h	2013-11-07 17:06:03.671887000 +0000
@@ -141,6 +141,8 @@
 	);
 	/*! the number of pages sent/received during a fax session */
 	unsigned int pages_transferred;
+	/*! total size transferred during a fax session */
+	unsigned int total_size;
 	/*! session details flags for options */
 	union {
 		/*! dontuse dummy variable - do not ever use */	
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/res/res_fax.c asterisk-11.3.0/res/res_fax.c
--- asterisk-base-11.3.0/res/res_fax.c	2013-10-28 10:12:18.935637000 +0000
+++ asterisk-11.3.0/res/res_fax.c	2013-11-18 14:00:30.647637184 +0000
@@ -1141,31 +1141,33 @@
 static int report_fax_status(struct ast_channel *chan, struct ast_fax_session_details *details, const char *status)
 {
 	char *filenames = generate_filenames_string(details, "FileName: ", "\r\n");
-
+	const char *s_chid;
 	ast_channel_lock(chan);
 	if (details->option.statusevents) {
 		struct manager_event_info info;
 
-		get_manager_event_info(chan, &info);
-		manager_event(EVENT_FLAG_CALL,
+	   if ((s_chid = pbx_builtin_getvar_helper(chan, "FAXCHINDEX"))) {
+	      s_chid = ast_strdupa(s_chid);
+	   }
+
+	   get_manager_event_info(chan, &info);
+	   if (s_chid) {
+	      manager_event(EVENT_FLAG_CALL,
 			      "FAXStatus",
 			      "Operation: %s\r\n"
 			      "Status: %s\r\n"
 			      "Channel: %s\r\n"
-			      "Context: %s\r\n"
-			      "Exten: %s\r\n"
-			      "CallerID: %s\r\n"
 			      "LocalStationID: %s\r\n"
-			      "%s%s",
+			      "%s%s"
+			      "chid: %s\r\n",
 			      (details->caps & AST_FAX_TECH_GATEWAY) ? "gateway" : (details->caps & AST_FAX_TECH_RECEIVE) ? "receive" : "send",
 			      status,
 			      ast_channel_name(chan),
-			      info.context,
-			      info.exten,
-			      info.cid,
 			      details->localstationid,
 			      S_OR(filenames, ""),
-			      filenames ? "\r\n" : "");
+			      filenames ? "\r\n" : "",
+			      s_chid);
+	   }
 	}
 	ast_channel_unlock(chan);
 
@@ -1416,7 +1418,38 @@
 		struct ast_channel *ready_chan;
 		int ofd, exception;
 
-		ms = 1000;
+		if ((ast_check_hangup(chan) || ast_test_flag(ast_channel_flags(chan), AST_FLAG_ZOMBIE))) {
+
+		   if (fax) {
+		       ao2_lock(faxregistry.container);
+		       ao2_unlink(faxregistry.container, fax);
+		       ao2_unlock(faxregistry.container);
+		       ao2_ref(fax, -1);
+		    }
+
+		   return chancount;
+		}
+
+	   if (ast_test_flag(ast_channel_inoflags(chan), EXEC_APP_EXIT)) {
+
+	      ast_verb(3, "FAX Exit flag activated, session stopped\n");
+
+         c = NULL;
+         chancount = 0;
+
+         fax->tech->cancel_session(fax);
+
+         if (fax) {
+            ao2_lock(faxregistry.container);
+            ao2_unlink(faxregistry.container, fax);
+            ao2_unlock(faxregistry.container);
+            ao2_ref(fax, -1);
+         }
+
+         return chancount;
+	   }
+
+	   ms = 1000;
 		errno = 0;
 		ready_chan = ast_waitfor_nandfds(&c, chancount, &fax->fd, 1, &exception, &ofd, &ms);
 		if (ready_chan) {
@@ -1590,7 +1623,6 @@
 		start = ast_tvnow();
 		while ((ms = ast_remaining_ms(start, timeout_ms))) {
 			ms = ast_waitfor(chan, ms);
-
 			if (ms < 0) {
 				ast_log(LOG_ERROR, "error while generating CED tone on %s\n", ast_channel_name(chan));
 				ast_playtones_stop(chan);
@@ -1659,7 +1691,6 @@
 	start = ast_tvnow();
 	while ((ms = ast_remaining_ms(start, timeout_ms))) {
 		int break_loop = 0;
-
 		ms = ast_waitfor(chan, ms);
 		if (ms < 0) {
 			ast_log(LOG_WARNING, "error on '%s' while waiting for T.38 negotiation.\n", ast_channel_name(chan));
@@ -1745,6 +1776,7 @@
 	struct ast_flags opts = { 0, };
 	struct manager_event_info info;
 	enum ast_t38_state t38state;
+	const char *s_chid;
 
 	/* initialize output channel variables */
 	pbx_builtin_setvar_helper(chan, "FAXSTATUS", "FAILED");
@@ -1768,7 +1800,7 @@
 	set_channel_variables(chan, details);
 
 	if (details->gateway_id > 0) {
-		ast_string_field_set(details, resultstr, "can't receive a fax on a channel with a T.38 gateway");
+      ast_string_field_set(details, resultstr, "can't receive a fax on a channel with a T.38 gateway");
 		set_channel_variables(chan, details);
 		ast_log(LOG_ERROR, "executing ReceiveFAX on a channel with a T.38 Gateway is not supported\n");
 		ao2_ref(details, -1);
@@ -1933,6 +1965,12 @@
 		ast_atomic_fetchadd_int(&faxregistry.fax_failures, 1);
 	}
 
+   if ((ast_check_hangup(chan) || ast_test_flag(ast_channel_flags(chan), AST_FLAG_ZOMBIE))){
+      ao2_ref(s, -1);
+      ao2_ref(details, -1);
+      return (!channel_alive) ? -1 : 0;
+   }
+
 	if (ast_channel_get_t38_state(chan) == T38_STATE_NEGOTIATED) {
 		if (disable_t38(chan)) {
 			ast_debug(1, "error disabling T.38 mode on %s\n", ast_channel_name(chan));
@@ -1942,29 +1980,32 @@
 	/* send out the AMI completion event */
 	ast_channel_lock(chan);
 
+   if ((s_chid = pbx_builtin_getvar_helper(s->chan, "FAXCHINDEX"))) {
+      s_chid = ast_strdupa(s_chid);
+   }
+
 	get_manager_event_info(chan, &info);
-	manager_event(EVENT_FLAG_CALL,
+	if(s_chid)
+   {
+	   manager_event(EVENT_FLAG_CALL,
 		      "ReceiveFAX",
 		      "Channel: %s\r\n"
-		      "Context: %s\r\n"
-		      "Exten: %s\r\n"
-		      "CallerID: %s\r\n"
 		      "RemoteStationID: %s\r\n"
 		      "LocalStationID: %s\r\n"
 		      "PagesTransferred: %s\r\n"
 		      "Resolution: %s\r\n"
 		      "TransferRate: %s\r\n"
-		      "FileName: %s\r\n",
+		      "%s\r\n"
+		      "chid: %s\r\n",
 		      ast_channel_name(chan),
-		      info.context,
-		      info.exten,
-		      info.cid,
 		      S_OR(pbx_builtin_getvar_helper(chan, "REMOTESTATIONID"), ""),
 		      S_OR(pbx_builtin_getvar_helper(chan, "LOCALSTATIONID"), ""),
 		      S_OR(pbx_builtin_getvar_helper(chan, "FAXPAGES"), ""),
 		      S_OR(pbx_builtin_getvar_helper(chan, "FAXRESOLUTION"), ""),
 		      S_OR(pbx_builtin_getvar_helper(chan, "FAXBITRATE"), ""),
-		      args.filename);
+		      args.filename,
+		      s_chid);
+   }
 	ast_channel_unlock(chan);
 
 	ao2_ref(s, -1);
@@ -2002,7 +2043,6 @@
 	while ((ms = ast_remaining_ms(start, timeout_ms))) {
 		int break_loop = 0;
 		ms = ast_waitfor(chan, ms);
-
 		if (ms < 0) {
 			ast_log(LOG_ERROR, "error while generating CNG tone on %s\n", ast_channel_name(chan));
 			ast_playtones_stop(chan);
@@ -2074,7 +2114,6 @@
 		start = ast_tvnow();
 		while ((ms = ast_remaining_ms(start, timeout_ms))) {
 			int break_loop = 0;
-
 			ms = ast_waitfor(chan, ms);
 			if (ms < 0) {
 				ast_log(LOG_WARNING, "error on '%s' while waiting for T.38 negotiation.\n", ast_channel_name(chan));
@@ -2144,7 +2183,6 @@
 			start = ast_tvnow();
 			while ((ms = ast_remaining_ms(start, timeout_ms))) {
 				int break_loop = 0;
-
 				ms = ast_waitfor(chan, ms);
 				if (ms < 0) {
 					ast_log(LOG_ERROR, "error while generating second CNG tone on %s\n", ast_channel_name(chan));
@@ -2231,6 +2269,7 @@
 	struct ast_flags opts = { 0, };
 	struct manager_event_info info;
 	enum ast_t38_state t38state;
+   const char *s_chid;
 
 	/* initialize output channel variables */
 	pbx_builtin_setvar_helper(chan, "FAXSTATUS", "FAILED");
@@ -2443,6 +2482,12 @@
 		ast_atomic_fetchadd_int(&faxregistry.fax_failures, 1);
 	}
 
+   if ((ast_check_hangup(chan) || ast_test_flag(ast_channel_flags(chan), AST_FLAG_ZOMBIE))){
+      ao2_ref(s, -1);
+      ao2_ref(details, -1);
+      return (!channel_alive) ? -1 : 0;
+   }
+
 	if (ast_channel_get_t38_state(chan) == T38_STATE_NEGOTIATED) {
 		if (disable_t38(chan)) {
 			ast_debug(1, "error disabling T.38 mode on %s\n", ast_channel_name(chan));
@@ -2458,29 +2503,33 @@
 
 	/* send out the AMI completion event */
 	ast_channel_lock(chan);
+
+   if ((s_chid = pbx_builtin_getvar_helper(s->chan, "FAXCHINDEX"))) {
+      s_chid = ast_strdupa(s_chid);
+   }
+
 	get_manager_event_info(chan, &info);
-	manager_event(EVENT_FLAG_CALL,
+	if(s_chid)
+	{
+	   manager_event(EVENT_FLAG_CALL,
 		      "SendFAX",
 		      "Channel: %s\r\n"
-		      "Context: %s\r\n"
-		      "Exten: %s\r\n"
-		      "CallerID: %s\r\n"
 		      "RemoteStationID: %s\r\n"
 		      "LocalStationID: %s\r\n"
 		      "PagesTransferred: %s\r\n"
 		      "Resolution: %s\r\n"
 		      "TransferRate: %s\r\n"
-		      "%s\r\n",
+		      "%s\r\n"
+		      "chid: %s\r\n",
 		      ast_channel_name(chan),
-		      info.context,
-		      info.exten,
-		      info.cid,
 		      S_OR(pbx_builtin_getvar_helper(chan, "REMOTESTATIONID"), ""),
 		      S_OR(pbx_builtin_getvar_helper(chan, "LOCALSTATIONID"), ""),
 		      S_OR(pbx_builtin_getvar_helper(chan, "FAXPAGES"), ""),
 		      S_OR(pbx_builtin_getvar_helper(chan, "FAXRESOLUTION"), ""),
 		      S_OR(pbx_builtin_getvar_helper(chan, "FAXBITRATE"), ""),
-		      filenames);
+		      filenames,
+		      s_chid);
+	}
 	ast_channel_unlock(chan);
 
 	ast_free(filenames);
@@ -3757,7 +3806,6 @@
 	i = ao2_iterator_init(faxregistry.container, 0);
 	while ((s = ao2_iterator_next(&i))) {
 		ao2_lock(s);
-
 		filenames = generate_filenames_string(s->details, "", ", ");
 
 		ast_cli(a->fd, "%-20.20s %-10.10s %-10d %-5.5s %-10.10s %-15.15s %-30s\n",
diff --exclude='*.xml' --exclude='*.o.d' --exclude=.project --exclude=.cproject -Naur asterisk-base-11.3.0/res/res_fax_spandsp.c asterisk-11.3.0/res/res_fax_spandsp.c
--- asterisk-base-11.3.0/res/res_fax_spandsp.c	2013-10-28 10:12:20.515637000 +0000
+++ asterisk-11.3.0/res/res_fax_spandsp.c	2013-11-18 14:00:43.479886942 +0000
@@ -66,6 +66,9 @@
 #include "asterisk/res_fax.h"
 #include "asterisk/channel.h"
 
+#include "asterisk/manager.h"
+#include "asterisk/pbx.h"
+
 #define SPANDSP_FAX_SAMPLES 160
 #define SPANDSP_FAX_TIMER_RATE 8000 / SPANDSP_FAX_SAMPLES	/* 50 ticks per second, 20ms, 160 samples per second */
 #define SPANDSP_ENGAGE_UDPTL_NAT_RETRY 3
@@ -163,6 +166,8 @@
 static int spandsp_v21_new(struct spandsp_pvt *p);
 static void session_destroy(struct spandsp_pvt *p);
 static int t38_tx_packet_handler(t38_core_state_t *t38_core_state, void *data, const uint8_t *buf, int len, int count);
+static int t30_phase_b_handler(t30_state_t *t30_state, void *data, int completion_code);
+static int t30_phase_d_handler(t30_state_t *t30_state, void *data, int completion_code);
 static void t30_phase_e_handler(t30_state_t *t30_state, void *data, int completion_code);
 static void spandsp_log(int level, const char *msg);
 static int update_stats(struct spandsp_pvt *p, int completion_code);
@@ -346,6 +351,138 @@
 	return 0;
 }
 
+static int t30_phase_b_handler(t30_state_t *t30_state, void *data, int completion_code)
+{
+   struct ast_fax_session *s = data;
+   const char *s_tmp, *s_chid;
+   int s_result = T30_ERR_OK;
+   t30_stats_t stats;
+
+   t30_get_transfer_statistics(t30_state, &stats);
+
+   // 131 is the spandsp ok completion code for phase b when receiving
+   // 128 is the spandsp ok completion code for phase b when sending
+   if (completion_code == T30_ERR_OK || completion_code == 131 || completion_code == 128) {
+      ast_string_field_set(s->details, resultstr, "");
+   } else {
+      ast_string_field_set(s->details, resultstr, t30_completion_code_to_str(completion_code));
+      s_result = completion_code;
+   }
+
+   ast_verb(3, "FAX Phase B in Channel '%s' with result: %d (%s)\n", ast_channel_name(s->chan), completion_code, s->details->resultstr);
+
+   if ((s_tmp = t30_get_tx_ident(t30_state))) {
+      ast_string_field_set(s->details, localstationid, s_tmp);
+   }
+
+   if ((s_tmp = t30_get_rx_ident(t30_state))) {
+      ast_string_field_set(s->details, remotestationid, s_tmp);
+   }
+
+   ast_channel_lock(s->chan);
+   if ((s_chid = pbx_builtin_getvar_helper(s->chan, "FAXCHINDEX"))) {
+      s_chid = ast_strdupa(s_chid);
+   }
+   ast_channel_unlock(s->chan);
+   if(s_chid)
+   {
+      manager_event(EVENT_FLAG_CALL,
+                       "FaxPhaseB",
+                       "Operation: %s\r\n"
+                       "RemoteStationID: %s\r\n"
+                       "LocalStationID: %s\r\n"
+                       "Channel: %s\r\n"
+                       "Maxrate: %d\r\n"
+                       "TransferRate: %d\r\n"
+                       "CompletionCode: %d\r\n"
+                       "ResultStr: %s\r\n"
+                       "chid: %s\r\n",
+                       (s->details->caps & AST_FAX_TECH_GATEWAY) ? "gateway" : (s->details->caps & AST_FAX_TECH_RECEIVE) ? "receive" : "send",
+                       s->details->remotestationid,
+                       s->details->localstationid,
+                       ast_channel_name(s->chan),
+                       s->details->maxrate,
+                       stats.bit_rate,
+                       s_result,
+                       s->details->resultstr,
+                       s_chid
+                       );
+   }
+   return s_result;
+}
+
+static int t30_phase_d_handler(t30_state_t *t30_state, void *data, int completion_code)
+{
+   struct ast_fax_session *s = data;
+   t30_stats_t stats;
+   const char *s_chid;
+   char s_total_size[8];
+   t30_get_transfer_statistics(t30_state, &stats);
+   int s_result = T30_ERR_OK;
+
+   // 78 is the spandps ok completion code for phase d when receiving
+   // 140 is the spandps ok completion code for phase d when sending
+   if (completion_code == T30_ERR_OK || completion_code == 78 || completion_code == 140) {
+      ast_string_field_set(s->details, resultstr, "");
+   } else {
+      ast_string_field_set(s->details, resultstr, t30_completion_code_to_str(completion_code));
+      s_result = completion_code;
+   }
+   ast_verb(3, "FAX Phase D in Channel '%s' with result: %d (%s)\n", ast_channel_name(s->chan), completion_code, s->details->resultstr);
+
+#if SPANDSP_RELEASE_DATE >= 20090220
+   s->details->pages_transferred = (s->details->caps & AST_FAX_TECH_RECEIVE) ? stats.pages_rx : stats.pages_tx;
+#else
+   s->details->pages_transferred = stats.pages_transferred;
+#endif
+
+   ast_string_field_build(s->details, transfer_rate, "%d", stats.bit_rate);
+   ast_string_field_build(s->details, resolution, "%.0f", ceil(stats.y_resolution*0.0254)); // meter to inch
+
+   ast_channel_lock(s->chan);
+   if((s_chid = pbx_builtin_getvar_helper(s->chan, "FAXCHINDEX"))) {
+      s_chid = ast_strdupa(s_chid);
+   }
+   ast_channel_unlock(s->chan);
+
+   s->details->total_size = s->details->total_size + stats.image_size;
+
+   if(s->details->total_size > 0)
+   {
+      sprintf(s_total_size, "%u",s->details->total_size);
+      pbx_builtin_setvar_helper(s->chan, "FAXTRTOTALSIZE", s_total_size);
+   }
+
+   if(s_chid)
+   {
+      manager_event(EVENT_FLAG_CALL,
+                      "FaxPhaseD",
+                      "Operation: %s\r\n"
+                      "Channel: %s\r\n"
+                      "PagesTransferred: %d\r\n"
+                      "TransferRate: %s\r\n"
+                      "Resolution: %s\r\n"
+                      "Width: %d\r\n"
+                      "ImageSize: %d\r\n"
+                      "CompletionCode: %d\r\n"
+                      "ResultStr: %s\r\n"
+                      "chid: %s\r\n",
+                      (s->details->caps & AST_FAX_TECH_GATEWAY) ? "gateway" : (s->details->caps & AST_FAX_TECH_RECEIVE) ? "receive" : "send",
+                      ast_channel_name(s->chan),
+                      s->details->pages_transferred,
+                      s->details->transfer_rate,
+                      s->details->resolution,
+                      stats.width,
+                      stats.image_size,
+                      s_result,
+                      s->details->resultstr,
+                      s_chid
+                      );
+   }
+
+   return s_result;
+}
+
 /*! \brief Phase E handler callback.
  * \param t30_state the span t30 state
  * \param data this will be the ast_fax_session
@@ -361,8 +498,10 @@
 	char headerinfo[T30_MAX_PAGE_HEADER_INFO + 1];
 	const char *c;
 	t30_stats_t stats;
+	const char *s_chid;
+	char s_pages[8], s_size[8], s_error[8];
 
-	ast_debug(5, "FAX session '%d' entering phase E\n", s->id);
+	ast_verb(3, "FAX session entering phase E\n");
 
 	p->isdone = 1;
 
@@ -372,14 +511,16 @@
 
 	if (completion_code == T30_ERR_OK) {
 		ast_string_field_set(s->details, result, "SUCCESS");
+      ast_string_field_set(s->details, error, "");
+      ast_string_field_set(s->details, resultstr, "");
 	} else {
 		ast_string_field_set(s->details, result, "FAILED");
-		ast_string_field_set(s->details, error, t30_completion_code_to_str(completion_code));
+		sprintf(s_error,"%d",completion_code);
+		ast_string_field_set(s->details, error, s_error);
+	   ast_string_field_set(s->details, resultstr, t30_completion_code_to_str(completion_code));
 	}
 
-	ast_string_field_set(s->details, resultstr, t30_completion_code_to_str(completion_code));
-
-	ast_debug(5, "FAX session '%d' completed with result: %s (%s)\n", s->id, s->details->result, s->details->resultstr);
+	ast_verb(3, "FAX Phase E in Channel %s completed with result: %s (%s)\n", ast_channel_name(s->chan), s->details->result, s->details->resultstr);
 
 	if ((c = t30_get_tx_ident(t30_state))) {
 		ast_string_field_set(s->details, localstationid, c);
@@ -396,11 +537,66 @@
 #endif
 
 	ast_string_field_build(s->details, transfer_rate, "%d", stats.bit_rate);
-
-	ast_string_field_build(s->details, resolution, "%dx%d", stats.x_resolution, stats.y_resolution);
+	ast_string_field_build(s->details, resolution, "%.0f", ceil(stats.y_resolution*0.0254)); // meter to inch
 
 	t30_get_tx_page_header_info(t30_state, headerinfo);
 	ast_string_field_set(s->details, headerinfo, headerinfo);
+
+	ast_channel_lock(s->chan);
+   if ((s_chid = pbx_builtin_getvar_helper(s->chan, "FAXCHINDEX"))) {
+      s_chid = ast_strdupa(s_chid);
+   }
+   ast_channel_unlock(s->chan);
+
+   pbx_builtin_setvar_helper(s->chan, "FAXERRORVALUE", s->details->error);
+   pbx_builtin_setvar_helper(s->chan, "FAXBITRATE", s->details->transfer_rate);
+   pbx_builtin_setvar_helper(s->chan, "FAXRESOLUTION", s->details->resolution);
+
+   if(s->details->pages_transferred > 0)
+   {
+      sprintf(s_pages, "%u",s->details->pages_transferred);
+      pbx_builtin_setvar_helper(s->chan, "FAXPAGES", s_pages);
+   }
+
+   if(stats.image_size > 0)
+   {
+      sprintf(s_size, "%d",stats.image_size);
+      pbx_builtin_setvar_helper(s->chan, "FAXTRSIZE", s_size);
+   }
+
+   if(s_chid)
+   {
+      manager_event(EVENT_FLAG_CALL,
+                       "FaxPhaseE",
+                       "Operation: %s\r\n"
+                       "Channel: %s\r\n"
+                       "RemoteStationID: %s\r\n"
+                       "LocalStationID: %s\r\n"
+                       "HeaderInfo: %s\r\n"
+                       "PagesTransferred: %d\r\n"
+                       "TransferRate: %s\r\n"
+                       "Resolution: %s\r\n"
+                       "Width: %d\r\n"
+                       "TotalImageSize: %d\r\n"
+                       "CompletionCode: %d\r\n"
+                       "ResultStr: %s\r\n"
+                       "chid: %s\r\n",
+                       (s->details->caps & AST_FAX_TECH_GATEWAY) ? "gateway" : (s->details->caps & AST_FAX_TECH_RECEIVE) ? "receive" : "send",
+                       ast_channel_name(s->chan),
+                       s->details->remotestationid,
+                       s->details->localstationid,
+                       s->details->headerinfo,
+                       s->details->pages_transferred,
+                       s->details->transfer_rate,
+                       s->details->resolution,
+                       stats.width,
+                       s->details->total_size,
+                       completion_code,
+                       s->details->resultstr,
+                       s_chid
+                       );
+   }
+   ast_set_flag(ast_channel_inoflags(s->chan), FAX_PHASE_E_EXIT);
 }
 
 /*! \brief Send spandsp log messages to asterisk.
@@ -911,6 +1107,10 @@
 
 	/* perhaps set_transmit_on_idle() should be called */
 
+   t30_set_phase_b_handler(p->t30_state, t30_phase_b_handler, s);
+
+   t30_set_phase_d_handler(p->t30_state, t30_phase_d_handler, s);
+
 	t30_set_phase_e_handler(p->t30_state, t30_phase_e_handler, s);
 
 	/* set T.38 parameters */
